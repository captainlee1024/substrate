#![feature(prelude_import)]
//! # Contracts Pallet
//!
//! The Contracts module provides functionality for the runtime to deploy and execute WebAssembly
//! smart-contracts.
//!
//! - [`Config`]
//! - [`Call`]
//!
//! ## Overview
//!
//! This module extends accounts based on the [`Currency`] trait to have smart-contract
//! functionality. It can be used with other modules that implement accounts based on [`Currency`].
//! These "smart-contract accounts" have the ability to instantiate smart-contracts and make calls
//! to other contract and non-contract accounts.
//!
//! The smart-contract code is stored once in a code cache, and later retrievable via its hash.
//! This means that multiple smart-contracts can be instantiated from the same hash, without
//! replicating the code each time.
//!
//! When a smart-contract is called, its associated code is retrieved via the code hash and gets
//! executed. This call can alter the storage entries of the smart-contract account, instantiate new
//! smart-contracts, or call other smart-contracts.
//!
//! Finally, when an account is reaped, its associated code and storage of the smart-contract
//! account will also be deleted.
//!
//! ### Gas
//!
//! Senders must specify a gas limit with every call, as all instructions invoked by the
//! smart-contract require gas. Unused gas is refunded after the call, regardless of the execution
//! outcome.
//!
//! If the gas limit is reached, then all calls and state changes (including balance transfers) are
//! only reverted at the current call's contract level. For example, if contract A calls B and B
//! runs out of gas mid-call, then all of B's calls are reverted. Assuming correct error handling by
//! contract A, A's other calls and state changes still persist.
//!
//! ### Notable Scenarios
//!
//! Contract call failures are not always cascading. When failures occur in a sub-call, they do not
//! "bubble up", and the call will only revert at the specific contract level. For example, if
//! contract A calls contract B, and B fails, A can decide how to handle that failure, either
//! proceeding or reverting A's changes.
//!
//! ## Interface
//!
//! ### Dispatchable functions
//!
//! * [`Pallet::instantiate_with_code`] - Deploys a new contract from the supplied wasm binary,
//! optionally transferring
//! some balance. This instantiates a new smart contract account with the supplied code and
//! calls its constructor to initialize the contract.
//! * [`Pallet::instantiate`] - The same as `instantiate_with_code` but instead of uploading new
//! code an existing `code_hash` is supplied.
//! * [`Pallet::call`] - Makes a call to an account, optionally transferring some balance.
//!
//! ## Usage
//!
//! The Contracts module is a work in progress. The following examples show how this module
//! can be used to instantiate and call contracts.
//!
//! * [`ink!`](https://use.ink) is
//! an [`eDSL`](https://wiki.haskell.org/Embedded_domain_specific_language) that enables writing
//! WebAssembly based smart contracts in the Rust programming language.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod address {
    //! Functions that deal with address derivation.
    use crate::{CodeHash, Config};
    use codec::{Decode, Encode};
    use sp_runtime::traits::{Hash, TrailingZeroInput};
    /// Provides the contract address generation method.
    ///
    /// See [`DefaultAddressGenerator`] for the default implementation.
    ///
    /// # Note for implementors
    ///
    /// 1. Make sure that there are no collisions, different inputs never lead to the same output.
    /// 2. Make sure that the same inputs lead to the same output.
    pub trait AddressGenerator<T: Config> {
        /// The address of a contract based on the given instantiate parameters.
        ///
        /// Changing the formular for an already deployed chain is fine as long as no collisions
        /// with the old formular. Changes only affect existing contracts.
        fn contract_address(
            deploying_address: &T::AccountId,
            code_hash: &CodeHash<T>,
            input_data: &[u8],
            salt: &[u8],
        ) -> T::AccountId;
        /// The address of the deposit account of `contract_addr`.
        ///
        /// The address is generated once on instantiation and then stored in the contracts
        /// metadata. Hence changes do only affect newly created contracts.
        fn deposit_address(contract_addr: &T::AccountId) -> T::AccountId;
    }
    /// Default address generator.
    ///
    /// This is the default address generator used by contract instantiation. Its result
    /// is only dependent on its inputs. It can therefore be used to reliably predict the
    /// address of a contract. This is akin to the formula of eth's CREATE2 opcode. There
    /// is no CREATE equivalent because CREATE2 is strictly more powerful.
    /// Formula:
    /// `hash("contract_addr_v1" ++ deploying_address ++ code_hash ++ input_data ++ salt)`
    pub struct DefaultAddressGenerator;
    impl<T: Config> AddressGenerator<T> for DefaultAddressGenerator {
        /// Formula: `hash("contract_addr_v1" ++ deploying_address ++ code_hash ++ input_data ++ salt)`
        fn contract_address(
            deploying_address: &T::AccountId,
            code_hash: &CodeHash<T>,
            input_data: &[u8],
            salt: &[u8],
        ) -> T::AccountId {
            let entropy = (
                b"contract_addr_v1",
                deploying_address,
                code_hash,
                input_data,
                salt,
            )
                .using_encoded(T::Hashing::hash);
            Decode::decode(&mut TrailingZeroInput::new(entropy.as_ref()))
                .expect("infinite length input; no invalid inputs for type; qed")
        }
        /// Formula: `hash("contract_depo_v1" ++ contract_addr)`
        fn deposit_address(contract_addr: &T::AccountId) -> T::AccountId {
            let entropy = (b"contract_depo_v1", contract_addr).using_encoded(T::Hashing::hash);
            Decode::decode(&mut TrailingZeroInput::new(entropy.as_ref()))
                .expect("infinite length input; no invalid inputs for type; qed")
        }
    }
}
mod exec {
    use crate::{
        gas::GasMeter,
        storage::{self, DepositAccount, WriteOutcome},
        BalanceOf, CodeHash, Config, ContractInfo, ContractInfoOf, DebugBufferVec, Determinism,
        Error, Event, Nonce, Origin, Pallet as Contracts, Schedule, System, LOG_TARGET,
    };
    use frame_support::{
        crypto::ecdsa::ECDSAExt,
        dispatch::{
            fmt::Debug, DispatchError, DispatchResult, DispatchResultWithPostInfo, Dispatchable,
        },
        storage::{with_transaction, TransactionOutcome},
        traits::{
            tokens::{Fortitude::Polite, Preservation::Expendable},
            Contains, Currency, ExistenceRequirement, OriginTrait, Randomness, Time,
        },
        weights::Weight,
        Blake2_128Concat, BoundedVec, StorageHasher,
    };
    use frame_system::RawOrigin;
    use pallet_contracts_primitives::ExecReturnValue;
    use smallvec::{Array, SmallVec};
    use sp_core::{
        ecdsa::Public as ECDSAPublic,
        sr25519::{Public as SR25519Public, Signature as SR25519Signature},
    };
    use sp_io::{crypto::secp256k1_ecdsa_recover_compressed, hashing::blake2_256};
    use sp_runtime::traits::{Convert, Hash, Zero};
    use sp_std::{marker::PhantomData, mem, prelude::*, vec::Vec};
    pub type AccountIdOf<T> = <T as frame_system::Config>::AccountId;
    pub type MomentOf<T> = <<T as Config>::Time as Time>::Moment;
    pub type SeedOf<T> = <T as frame_system::Config>::Hash;
    pub type BlockNumberOf<T> = <T as frame_system::Config>::BlockNumber;
    pub type ExecResult = Result<ExecReturnValue, ExecError>;
    /// A type that represents a topic of an event. At the moment a hash is used.
    pub type TopicOf<T> = <T as frame_system::Config>::Hash;
    /// Type for variable sized storage key. Used for transparent hashing.
    type VarSizedKey<T> = BoundedVec<u8, <T as Config>::MaxStorageKeyLen>;
    /// Combined key type for both fixed and variable sized storage keys.
    pub enum Key<T: Config> {
        /// Variant for fixed sized keys.
        Fix([u8; 32]),
        /// Variant for variable sized keys.
        Var(VarSizedKey<T>),
    }
    impl<T: Config> Key<T> {
        /// Copies self into a new vec.
        pub fn to_vec(&self) -> Vec<u8> {
            match self {
                Key::Fix(v) => v.to_vec(),
                Key::Var(v) => v.to_vec(),
            }
        }
        pub fn hash(&self) -> Vec<u8> {
            match self {
                Key::Fix(v) => blake2_256(v.as_slice()).to_vec(),
                Key::Var(v) => Blake2_128Concat::hash(v.as_slice()),
            }
        }
        pub fn try_from_fix(v: Vec<u8>) -> Result<Self, Vec<u8>> {
            <[u8; 32]>::try_from(v).map(Self::Fix)
        }
        pub fn try_from_var(v: Vec<u8>) -> Result<Self, Vec<u8>> {
            VarSizedKey::<T>::try_from(v).map(Self::Var)
        }
    }
    /// Origin of the error.
    ///
    /// Call or instantiate both called into other contracts and pass through errors happening
    /// in those to the caller. This enum is for the caller to distinguish whether the error
    /// happened during the execution of the callee or in the current execution context.
    pub enum ErrorOrigin {
        /// Caller error origin.
        ///
        /// The error happened in the current execution context rather than in the one
        /// of the contract that is called into.
        Caller,
        /// The error happened during execution of the called contract.
        Callee,
    }
    /// Error returned by contract execution.
    pub struct ExecError {
        /// The reason why the execution failed.
        pub error: DispatchError,
        /// Origin of the error.
        pub origin: ErrorOrigin,
    }
    impl<T: Into<DispatchError>> From<T> for ExecError {
        fn from(error: T) -> Self {
            Self {
                error: error.into(),
                origin: ErrorOrigin::Caller,
            }
        }
    }
    /// An interface that provides access to the external environment in which the
    /// smart-contract is executed.
    ///
    /// This interface is specialized to an account of the executing code, so all
    /// operations are implicitly performed on that account.
    ///
    /// # Note
    ///
    /// This trait is sealed and cannot be implemented by downstream crates.
    ///
    /// 提供对执行智能合约的外部环境的访问的接口。
    /// 此接口专用于执行代码的帐户，因此所有操作都隐式执行在该帐户上。
    /// 注意
    /// 这种特性是密封的，不能通过下游板条箱来实现。
    pub trait Ext: sealing::Sealed {
        type T: Config;
        /// Call (possibly transferring some amount of funds) into the specified account.
        ///
        /// Returns the original code size of the called contract.
        fn call(
            &mut self,
            gas_limit: Weight,
            deposit_limit: BalanceOf<Self::T>,
            to: AccountIdOf<Self::T>,
            value: BalanceOf<Self::T>,
            input_data: Vec<u8>,
            allows_reentry: bool,
        ) -> Result<ExecReturnValue, ExecError>;
        /// Execute code in the current frame.
        ///
        /// Returns the original code size of the called contract.
        fn delegate_call(
            &mut self,
            code: CodeHash<Self::T>,
            input_data: Vec<u8>,
        ) -> Result<ExecReturnValue, ExecError>;
        /// Instantiate a contract from the given code.
        ///
        /// Returns the original code size of the called contract.
        /// The newly created account will be associated with `code`. `value` specifies the amount of
        /// value transferred from this to the newly created account.
        fn instantiate(
            &mut self,
            gas_limit: Weight,
            deposit_limit: BalanceOf<Self::T>,
            code: CodeHash<Self::T>,
            value: BalanceOf<Self::T>,
            input_data: Vec<u8>,
            salt: &[u8],
        ) -> Result<(AccountIdOf<Self::T>, ExecReturnValue), ExecError>;
        /// Transfer all funds to `beneficiary` and delete the contract.
        ///
        /// Since this function removes the self contract eagerly, if succeeded, no further actions
        /// should be performed on this `Ext` instance.
        ///
        /// This function will fail if the same contract is present on the contract
        /// call stack.
        fn terminate(&mut self, beneficiary: &AccountIdOf<Self::T>) -> Result<(), DispatchError>;
        /// Transfer some amount of funds into the specified account.
        fn transfer(
            &mut self,
            to: &AccountIdOf<Self::T>,
            value: BalanceOf<Self::T>,
        ) -> DispatchResult;
        /// Returns the storage entry of the executing account by the given `key`.
        ///
        /// Returns `None` if the `key` wasn't previously set by `set_storage` or
        /// was deleted.
        fn get_storage(&mut self, key: &Key<Self::T>) -> Option<Vec<u8>>;
        /// Returns `Some(len)` (in bytes) if a storage item exists at `key`.
        ///
        /// Returns `None` if the `key` wasn't previously set by `set_storage` or
        /// was deleted.
        fn get_storage_size(&mut self, key: &Key<Self::T>) -> Option<u32>;
        /// Sets the storage entry by the given key to the specified value. If `value` is `None` then
        /// the storage entry is deleted.
        fn set_storage(
            &mut self,
            key: &Key<Self::T>,
            value: Option<Vec<u8>>,
            take_old: bool,
        ) -> Result<WriteOutcome, DispatchError>;
        /// Returns the caller.
        fn caller(&self) -> Origin<Self::T>;
        /// Check if a contract lives at the specified `address`.
        fn is_contract(&self, address: &AccountIdOf<Self::T>) -> bool;
        /// Returns the code hash of the contract for the given `address`.
        ///
        /// Returns `None` if the `address` does not belong to a contract.
        fn code_hash(&self, address: &AccountIdOf<Self::T>) -> Option<CodeHash<Self::T>>;
        /// Returns the code hash of the contract being executed.
        fn own_code_hash(&mut self) -> &CodeHash<Self::T>;
        /// Check if the caller of the current contract is the origin of the whole call stack.
        ///
        /// This can be checked with `is_contract(self.caller())` as well.
        /// However, this function does not require any storage lookup and therefore uses less weight.
        fn caller_is_origin(&self) -> bool;
        /// Check if the caller is origin, and this origin is root.
        fn caller_is_root(&self) -> bool;
        /// Returns a reference to the account id of the current contract.
        fn address(&self) -> &AccountIdOf<Self::T>;
        /// Returns the balance of the current contract.
        ///
        /// The `value_transferred` is already added.
        fn balance(&self) -> BalanceOf<Self::T>;
        /// Returns the value transferred along with this call.
        fn value_transferred(&self) -> BalanceOf<Self::T>;
        /// Returns a reference to the timestamp of the current block
        fn now(&self) -> &MomentOf<Self::T>;
        /// Returns the minimum balance that is required for creating an account.
        fn minimum_balance(&self) -> BalanceOf<Self::T>;
        /// Returns a random number for the current block with the given subject.
        fn random(&self, subject: &[u8]) -> (SeedOf<Self::T>, BlockNumberOf<Self::T>);
        /// Deposit an event with the given topics.
        ///
        /// There should not be any duplicates in `topics`.
        fn deposit_event(&mut self, topics: Vec<TopicOf<Self::T>>, data: Vec<u8>);
        /// Returns the current block number.
        fn block_number(&self) -> BlockNumberOf<Self::T>;
        /// Returns the maximum allowed size of a storage item.
        fn max_value_size(&self) -> u32;
        /// Returns the price for the specified amount of weight.
        fn get_weight_price(&self, weight: Weight) -> BalanceOf<Self::T>;
        /// Get a reference to the schedule used by the current call.
        fn schedule(&self) -> &Schedule<Self::T>;
        /// Get a mutable reference to the nested gas meter.
        fn gas_meter(&mut self) -> &mut GasMeter<Self::T>;
        /// Append a string to the debug buffer.
        ///
        /// It is added as-is without any additional new line.
        ///
        /// This is a no-op if debug message recording is disabled which is always the case
        /// when the code is executing on-chain.
        ///
        /// Returns `true` if debug message recording is enabled. Otherwise `false` is returned.
        fn append_debug_buffer(&mut self, msg: &str) -> bool;
        /// Call some dispatchable and return the result.
        fn call_runtime(
            &self,
            call: <Self::T as Config>::RuntimeCall,
        ) -> DispatchResultWithPostInfo;
        /// Recovers ECDSA compressed public key based on signature and message hash.
        fn ecdsa_recover(
            &self,
            signature: &[u8; 65],
            message_hash: &[u8; 32],
        ) -> Result<[u8; 33], ()>;
        /// Verify a sr25519 signature.
        fn sr25519_verify(&self, signature: &[u8; 64], message: &[u8], pub_key: &[u8; 32]) -> bool;
        /// Returns Ethereum address from the ECDSA compressed public key.
        fn ecdsa_to_eth_address(&self, pk: &[u8; 33]) -> Result<[u8; 20], ()>;
        /// Sets new code hash for existing contract.
        fn set_code_hash(&mut self, hash: CodeHash<Self::T>) -> Result<(), DispatchError>;
        /// Returns the number of times the currently executing contract exists on the call stack in
        /// addition to the calling instance. A value of 0 means no reentrancy.
        fn reentrance_count(&self) -> u32;
        /// Returns the number of times the specified contract exists on the call stack. Delegated calls
        /// are not calculated as separate entrance.
        /// A value of 0 means it does not exist on the call stack.
        fn account_reentrance_count(&self, account_id: &AccountIdOf<Self::T>) -> u32;
        /// Returns a nonce that is incremented for every instantiated contract.
        fn nonce(&mut self) -> u64;
    }
    /// Describes the different functions that can be exported by an [`Executable`].
    /// 描述可由[Executable]导出的不同的function
    pub enum ExportedFunction {
        /// The constructor function which is executed on deployment of a contract.
        /// 在部署合约时执行的构造函数。
        Constructor,
        /// The function which is executed when a contract is called.
        /// 调用合约时执行的函数。
        Call,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExportedFunction {
        #[inline]
        fn clone(&self) -> ExportedFunction {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ExportedFunction {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ExportedFunction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ExportedFunction {
        #[inline]
        fn eq(&self, other: &ExportedFunction) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    /// A trait that represents something that can be executed.
    ///
    /// In the on-chain environment this would be represented by a wasm module. This trait exists in
    /// order to be able to mock the wasm logic for testing.
    ///
    /// 表示可以执行的内容的特征。
    /// 在链上环境中，这将由 wasm 模块表示。存在此特征是为了能够模拟wasm逻辑进行测试
    pub trait Executable<T: Config>: Sized {
        /// Load the executable from storage.
        ///
        /// # Note
        /// Charges size base load and instrumentation weight from the gas meter.
        fn from_storage(
            code_hash: CodeHash<T>,
            schedule: &Schedule<T>,
            gas_meter: &mut GasMeter<T>,
        ) -> Result<Self, DispatchError>;
        /// Increment the refcount of a code in-storage by one.
        ///
        /// This is needed when the code is not set via instantiate but `seal_set_code_hash`.
        ///
        /// # Errors
        ///
        /// [`Error::CodeNotFound`] is returned if the specified `code_hash` does not exist.
        fn add_user(code_hash: CodeHash<T>) -> Result<(), DispatchError>;
        /// Decrement the refcount by one if the code exists.
        fn remove_user(code_hash: CodeHash<T>);
        /// Execute the specified exported function and return the result.
        ///
        /// When the specified function is `Constructor` the executable is stored and its
        /// refcount incremented.
        ///
        /// # Note
        ///
        /// This functions expects to be executed in a storage transaction that rolls back
        /// all of its emitted storage changes.
        fn execute<E: Ext<T = T>>(
            self,
            ext: &mut E,
            function: &ExportedFunction,
            input_data: Vec<u8>,
        ) -> ExecResult;
        /// The code hash of the executable.
        fn code_hash(&self) -> &CodeHash<T>;
        /// Size of the instrumented code in bytes.
        fn code_len(&self) -> u32;
        /// The code does not contain any instructions which could lead to indeterminism.
        fn is_deterministic(&self) -> bool;
    }
    /// The complete call stack of a contract execution.
    ///
    /// The call stack is initiated by either a signed origin or one of the contract RPC calls.
    /// This type implements `Ext` and by that exposes the business logic of contract execution to
    /// the runtime module which interfaces with the contract (the wasm blob) itself.
    pub struct Stack<'a, T: Config, E> {
        /// The origin that initiated the call stack. It could either be a Signed plain account that
        /// holds an account id or Root.
        ///
        /// # Note
        ///
        /// Please note that it is possible that the id of a Signed origin belongs to a contract rather
        /// than a plain account when being called through one of the contract RPCs where the
        /// client can freely choose the origin. This usually makes no sense but is still possible.
        origin: Origin<T>,
        /// The cost schedule used when charging from the gas meter.
        schedule: &'a Schedule<T>,
        /// The gas meter where costs are charged to.
        gas_meter: &'a mut GasMeter<T>,
        /// The storage meter makes sure that the storage deposit limit is obeyed.
        storage_meter: &'a mut storage::meter::Meter<T>,
        /// The timestamp at the point of call stack instantiation.
        timestamp: MomentOf<T>,
        /// The block number at the time of call stack instantiation.
        block_number: T::BlockNumber,
        /// The nonce is cached here when accessed. It is written back when the call stack
        /// finishes executing. Please refer to [`Nonce`] to a description of
        /// the nonce itself.
        nonce: Option<u64>,
        /// The actual call stack. One entry per nested contract called/instantiated.
        /// This does **not** include the [`Self::first_frame`].
        frames: SmallVec<T::CallStack>,
        /// Statically guarantee that each call stack has at least one frame.
        first_frame: Frame<T>,
        /// A text buffer used to output human readable information.
        ///
        /// All the bytes added to this field should be valid UTF-8. The buffer has no defined
        /// structure and is intended to be shown to users as-is for debugging purposes.
        debug_message: Option<&'a mut DebugBufferVec<T>>,
        /// The determinism requirement of this call stack.
        determinism: Determinism,
        /// No executable is held by the struct but influences its behaviour.
        _phantom: PhantomData<E>,
    }
    /// Represents one entry in the call stack.
    ///
    /// For each nested contract call or instantiate one frame is created. It holds specific
    /// information for the said call and caches the in-storage `ContractInfo` data structure.
    ///
    /// # Note
    ///
    /// This is an internal data structure. It is exposed to the public for the sole reason
    /// of specifying [`Config::CallStack`].
    pub struct Frame<T: Config> {
        /// The account id of the executing contract.
        account_id: T::AccountId,
        /// The cached in-storage data of the contract.
        contract_info: CachedContract<T>,
        /// The amount of balance transferred by the caller as part of the call.
        value_transferred: BalanceOf<T>,
        /// Determines whether this is a call or instantiate frame.
        entry_point: ExportedFunction,
        /// The gas meter capped to the supplied gas limit.
        nested_gas: GasMeter<T>,
        /// The storage meter for the individual call.
        nested_storage: storage::meter::NestedMeter<T>,
        /// If `false` the contract enabled its defense against reentrance attacks.
        allows_reentry: bool,
        /// The caller of the currently executing frame which was spawned by `delegate_call`.
        delegate_caller: Option<Origin<T>>,
    }
    /// Used in a delegate call frame arguments in order to override the executable and caller.
    struct DelegatedCall<T: Config, E> {
        /// The executable which is run instead of the contracts own `executable`.
        executable: E,
        /// The caller of the contract.
        caller: Origin<T>,
    }
    /// Parameter passed in when creating a new `Frame`.
    ///
    /// It determines whether the new frame is for a call or an instantiate.
    enum FrameArgs<'a, T: Config, E> {
        Call {
            /// The account id of the contract that is to be called.
            dest: T::AccountId,
            /// If `None` the contract info needs to be reloaded from storage.
            cached_info: Option<ContractInfo<T>>,
            /// This frame was created by `seal_delegate_call` and hence uses different code than
            /// what is stored at [`Self::Call::dest`]. Its caller ([`DelegatedCall::caller`]) is the
            /// account which called the caller contract
            delegated_call: Option<DelegatedCall<T, E>>,
        },
        Instantiate {
            /// The contract or signed origin which instantiates the new contract.
            sender: T::AccountId,
            /// The nonce that should be used to derive a new trie id for the contract.
            nonce: u64,
            /// The executable whose `deploy` function is run.
            executable: E,
            /// A salt used in the contract address deriviation of the new contract.
            salt: &'a [u8],
            /// The input data is used in the contract address deriviation of the new contract.
            input_data: &'a [u8],
        },
    }
    /// Describes the different states of a contract as contained in a `Frame`.
    enum CachedContract<T: Config> {
        /// The cached contract is up to date with the in-storage value.
        Cached(ContractInfo<T>),
        /// A recursive call into the same contract did write to the contract info.
        ///
        /// In this case the cached contract is stale and needs to be reloaded from storage.
        Invalidated,
        /// The current contract executed `terminate` and removed the contract.
        ///
        /// In this case a reload is neither allowed nor possible. Please note that recursive
        /// calls cannot remove a contract as this is checked and denied.
        Terminated(DepositAccount<T>),
    }
    impl<T: Config> CachedContract<T> {
        /// Return `Some(ContractInfo)` if the contract is in cached state. `None` otherwise.
        fn into_contract(self) -> Option<ContractInfo<T>> {
            if let CachedContract::Cached(contract) = self {
                Some(contract)
            } else {
                None
            }
        }
        /// Return `Some(&mut ContractInfo)` if the contract is in cached state. `None` otherwise.
        fn as_contract(&mut self) -> Option<&mut ContractInfo<T>> {
            if let CachedContract::Cached(contract) = self {
                Some(contract)
            } else {
                None
            }
        }
        /// Returns `Some` iff the contract is not `Cached::Invalidated`.
        fn deposit_account(&self) -> Option<&DepositAccount<T>> {
            match self {
                CachedContract::Cached(contract) => Some(contract.deposit_account()),
                CachedContract::Terminated(deposit_account) => Some(&deposit_account),
                CachedContract::Invalidated => None,
            }
        }
    }
    impl<T: Config> Frame<T> {
        /// Return the `contract_info` of the current contract.
        fn contract_info(&mut self) -> &mut ContractInfo<T> {
            self.contract_info.get(&self.account_id)
        }
        /// Terminate and return the `contract_info` of the current contract.
        ///
        /// # Note
        ///
        /// Under no circumstances the contract is allowed to access the `contract_info` after
        /// a call to this function. This would constitute a programming error in the exec module.
        fn terminate(&mut self) -> ContractInfo<T> {
            self.contract_info.terminate(&self.account_id)
        }
    }
    impl<T: Config> CachedContract<T> {
        /// Load the `contract_info` from storage if necessary.
        fn load(&mut self, account_id: &T::AccountId) {
            if let CachedContract::Invalidated = self {
                let contract = <ContractInfoOf<T>>::get(&account_id);
                if let Some(contract) = contract {
                    *self = CachedContract::Cached(contract);
                }
            }
        }
        /// Return the cached contract_info.
        fn get(&mut self, account_id: &T::AccountId) -> &mut ContractInfo<T> {
            self.load(account_id);
            {
                if let CachedContract::Cached(contract) = self {
                    contract
                } else {
                    :: core :: panicking :: panic_fmt (format_args ! ("It is impossible to remove a contract that is on the call stack;See implementations of terminate;Therefore fetching a contract will never fail while using an account id\n\t\t\t\tthat is currently active on the call stack;qed")) ;
                }
            }
        }
        /// Terminate and return the contract info.
        fn terminate(&mut self, account_id: &T::AccountId) -> ContractInfo<T> {
            self.load(account_id);
            let contract = {
                if let CachedContract::Cached(contract) = self {
                    contract
                } else {
                    :: core :: panicking :: panic_fmt (format_args ! ("It is impossible to remove a contract that is on the call stack;See implementations of terminate;Therefore fetching a contract will never fail while using an account id\n\t\t\t\tthat is currently active on the call stack;qed")) ;
                }
            };
            let deposit_account = contract.deposit_account().clone();
            {
                if let CachedContract::Cached(contract) =
                    mem::replace(self, Self::Terminated(deposit_account))
                {
                    contract
                } else {
                    :: core :: panicking :: panic_fmt (format_args ! ("It is impossible to remove a contract that is on the call stack;See implementations of terminate;Therefore fetching a contract will never fail while using an account id\n\t\t\t\tthat is currently active on the call stack;qed")) ;
                }
            }
        }
    }
    impl<'a, T, E> Stack<'a, T, E>
    where
        T: Config,
        E: Executable<T>,
    {
        /// Create and run a new call stack by calling into `dest`.
        ///
        /// # Note
        ///
        /// `debug_message` should only ever be set to `Some` when executing as an RPC because
        /// it adds allocations and could be abused to drive the runtime into an OOM panic.
        ///
        /// # Return Value
        ///
        /// Result<(ExecReturnValue, CodeSize), (ExecError, CodeSize)>
        pub fn run_call(
            origin: Origin<T>,
            dest: T::AccountId,
            gas_meter: &'a mut GasMeter<T>,
            storage_meter: &'a mut storage::meter::Meter<T>,
            schedule: &'a Schedule<T>,
            value: BalanceOf<T>,
            input_data: Vec<u8>,
            debug_message: Option<&'a mut DebugBufferVec<T>>,
            determinism: Determinism,
        ) -> Result<ExecReturnValue, ExecError> {
            let (mut stack, executable) = Self::new(
                FrameArgs::Call {
                    dest,
                    cached_info: None,
                    delegated_call: None,
                },
                origin,
                gas_meter,
                storage_meter,
                schedule,
                value,
                debug_message,
                determinism,
            )?;
            stack.run(executable, input_data)
        }
        /// Create and run a new call stack by instantiating a new contract.
        ///
        /// # Note
        ///
        /// `debug_message` should only ever be set to `Some` when executing as an RPC because
        /// it adds allocations and could be abused to drive the runtime into an OOM panic.
        ///
        /// # Return Value
        ///
        /// Result<(NewContractAccountId, ExecReturnValue), ExecError)>
        pub fn run_instantiate(
            origin: T::AccountId,
            executable: E,
            gas_meter: &'a mut GasMeter<T>,
            storage_meter: &'a mut storage::meter::Meter<T>,
            schedule: &'a Schedule<T>,
            value: BalanceOf<T>,
            input_data: Vec<u8>,
            salt: &[u8],
            debug_message: Option<&'a mut DebugBufferVec<T>>,
        ) -> Result<(T::AccountId, ExecReturnValue), ExecError> {
            let (mut stack, executable) = Self::new(
                FrameArgs::Instantiate {
                    sender: origin.clone(),
                    nonce: <Nonce<T>>::get().wrapping_add(1),
                    executable,
                    salt,
                    input_data: input_data.as_ref(),
                },
                Origin::from_account_id(origin),
                gas_meter,
                storage_meter,
                schedule,
                value,
                debug_message,
                Determinism::Enforced,
            )?;
            let account_id = stack.top_frame().account_id.clone();
            stack
                .run(executable, input_data)
                .map(|ret| (account_id, ret))
        }
        /// Create a new call stack.
        fn new(
            args: FrameArgs<T, E>,
            origin: Origin<T>,
            gas_meter: &'a mut GasMeter<T>,
            storage_meter: &'a mut storage::meter::Meter<T>,
            schedule: &'a Schedule<T>,
            value: BalanceOf<T>,
            debug_message: Option<&'a mut DebugBufferVec<T>>,
            determinism: Determinism,
        ) -> Result<(Self, E), ExecError> {
            let (first_frame, executable, nonce) = Self::new_frame(
                args,
                value,
                gas_meter,
                Weight::zero(),
                storage_meter,
                BalanceOf::<T>::zero(),
                schedule,
                determinism,
            )?;
            let stack = Self {
                origin,
                schedule,
                gas_meter,
                storage_meter,
                timestamp: T::Time::now(),
                block_number: <frame_system::Pallet<T>>::block_number(),
                nonce,
                first_frame,
                frames: Default::default(),
                debug_message,
                determinism,
                _phantom: Default::default(),
            };
            Ok((stack, executable))
        }
        /// Construct a new frame.
        ///
        /// This does not take `self` because when constructing the first frame `self` is
        /// not initialized, yet.
        fn new_frame<S: storage::meter::State + Default + Debug>(
            frame_args: FrameArgs<T, E>,
            value_transferred: BalanceOf<T>,
            gas_meter: &mut GasMeter<T>,
            gas_limit: Weight,
            storage_meter: &mut storage::meter::GenericMeter<T, S>,
            deposit_limit: BalanceOf<T>,
            schedule: &Schedule<T>,
            determinism: Determinism,
        ) -> Result<(Frame<T>, E, Option<u64>), ExecError> {
            let (account_id, contract_info, executable, delegate_caller, entry_point, nonce) =
                match frame_args {
                    FrameArgs::Call {
                        dest,
                        cached_info,
                        delegated_call,
                    } => {
                        let contract = if let Some(contract) = cached_info {
                            contract
                        } else {
                            <ContractInfoOf<T>>::get(&dest).ok_or(<Error<T>>::ContractNotFound)?
                        };
                        let (executable, delegate_caller) =
                            if let Some(DelegatedCall { executable, caller }) = delegated_call {
                                (executable, Some(caller))
                            } else {
                                (
                                    E::from_storage(contract.code_hash, schedule, gas_meter)?,
                                    None,
                                )
                            };
                        (
                            dest,
                            contract,
                            executable,
                            delegate_caller,
                            ExportedFunction::Call,
                            None,
                        )
                    }
                    FrameArgs::Instantiate {
                        sender,
                        nonce,
                        executable,
                        salt,
                        input_data,
                    } => {
                        let account_id = Contracts::<T>::contract_address(
                            &sender,
                            executable.code_hash(),
                            input_data,
                            salt,
                        );
                        let contract =
                            ContractInfo::new(&account_id, nonce, *executable.code_hash())?;
                        (
                            account_id,
                            contract,
                            executable,
                            None,
                            ExportedFunction::Constructor,
                            Some(nonce),
                        )
                    }
                };
            if !(executable.is_deterministic()
                || ((match determinism {
                    Determinism::Relaxed => true,
                    _ => false,
                }) && match entry_point {
                    ExportedFunction::Call => true,
                    _ => false,
                }))
            {
                return Err(Error::<T>::Indeterministic.into());
            }
            let frame = Frame {
                delegate_caller,
                value_transferred,
                contract_info: CachedContract::Cached(contract_info),
                account_id,
                entry_point,
                nested_gas: gas_meter.nested(gas_limit)?,
                nested_storage: storage_meter.nested(deposit_limit),
                allows_reentry: true,
            };
            Ok((frame, executable, nonce))
        }
        /// Create a subsequent nested frame.
        fn push_frame(
            &mut self,
            frame_args: FrameArgs<T, E>,
            value_transferred: BalanceOf<T>,
            gas_limit: Weight,
            deposit_limit: BalanceOf<T>,
        ) -> Result<E, ExecError> {
            if self.frames.len() == T::CallStack::size() {
                return Err(Error::<T>::MaxCallDepthReached.into());
            }
            let frame = self.top_frame();
            if let (CachedContract::Cached(contract), ExportedFunction::Call) =
                (&frame.contract_info, frame.entry_point)
            {
                <ContractInfoOf<T>>::insert(frame.account_id.clone(), contract.clone());
            }
            let frame = self.frames.last_mut().unwrap_or(&mut self.first_frame);
            let nested_gas = &mut frame.nested_gas;
            let nested_storage = &mut frame.nested_storage;
            let (frame, executable, _) = Self::new_frame(
                frame_args,
                value_transferred,
                nested_gas,
                gas_limit,
                nested_storage,
                deposit_limit,
                self.schedule,
                self.determinism,
            )?;
            self.frames.push(frame);
            Ok(executable)
        }
        /// Run the current (top) frame.
        ///
        /// This can be either a call or an instantiate.
        ///
        /// 运行当前（顶部）帧。这可以是调用或实例化。
        fn run(
            &mut self,
            executable: E,
            input_data: Vec<u8>,
        ) -> Result<ExecReturnValue, ExecError> {
            let frame = self.top_frame();
            let entry_point = frame.entry_point;
            let delegated_code_hash = if frame.delegate_caller.is_some() {
                Some(*executable.code_hash())
            } else {
                None
            };
            let do_transaction = || {
                if entry_point == ExportedFunction::Constructor {
                    let origin = &self.origin.account_id()?;
                    let frame = self.frames.last_mut().unwrap_or(&mut self.first_frame);
                    frame.nested_storage.charge_instantiate(
                        origin,
                        &frame.account_id,
                        frame.contract_info.get(&frame.account_id),
                    )?;
                }
                self.initial_transfer()?;
                let output = executable
                    .execute(self, &entry_point, input_data)
                    .map_err(|e| ExecError {
                        error: e.error,
                        origin: ErrorOrigin::Callee,
                    })?;
                if output.did_revert() {
                    return Ok(output);
                }
                if self.frames.is_empty() {
                    let frame = &mut self.first_frame;
                    frame.contract_info.load(&frame.account_id);
                    let contract = frame.contract_info.as_contract();
                    frame.nested_storage.enforce_limit(contract)?;
                }
                let frame = self.top_frame();
                let account_id = &frame.account_id.clone();
                match (entry_point, delegated_code_hash) {
                    (ExportedFunction::Constructor, _) => {
                        if match frame.contract_info {
                            CachedContract::Terminated(_) => true,
                            _ => false,
                        } {
                            return Err(Error::<T>::TerminatedInConstructor.into());
                        }
                        let frame = self.top_frame_mut();
                        let contract = frame.contract_info.as_contract();
                        frame.nested_storage.enforce_subcall_limit(contract)?;
                        let caller = self.caller().account_id()?.clone();
                        Contracts::<T>::deposit_event(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    T::Hashing::hash_of(&caller),
                                    T::Hashing::hash_of(account_id),
                                ]),
                            ),
                            Event::Instantiated {
                                deployer: caller,
                                contract: account_id.clone(),
                            },
                        );
                    }
                    (ExportedFunction::Call, Some(code_hash)) => {
                        Contracts::<T>::deposit_event(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    T::Hashing::hash_of(account_id),
                                    T::Hashing::hash_of(&code_hash),
                                ]),
                            ),
                            Event::DelegateCalled {
                                contract: account_id.clone(),
                                code_hash,
                            },
                        );
                    }
                    (ExportedFunction::Call, None) => {
                        let frame = self.top_frame_mut();
                        let contract = frame.contract_info.as_contract();
                        frame.nested_storage.enforce_subcall_limit(contract)?;
                        let caller = self.caller();
                        Contracts::<T>::deposit_event(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    T::Hashing::hash_of(&caller),
                                    T::Hashing::hash_of(&account_id),
                                ]),
                            ),
                            Event::Called {
                                caller: caller.clone(),
                                contract: account_id.clone(),
                            },
                        );
                    }
                }
                Ok(output)
            };
            let transaction_outcome =
                with_transaction(|| -> TransactionOutcome<Result<_, DispatchError>> {
                    let output = do_transaction();
                    match &output {
                        Ok(result) if !result.did_revert() => {
                            TransactionOutcome::Commit(Ok((true, output)))
                        }
                        _ => TransactionOutcome::Rollback(Ok((false, output))),
                    }
                });
            let (success, output) = match transaction_outcome {
                Ok((success, output)) => (success, output),
                Err(error) => (false, Err(error.into())),
            };
            self.pop_frame(success);
            output
        }
        /// Remove the current (top) frame from the stack.
        ///
        /// This is called after running the current frame. It commits cached values to storage
        /// and invalidates all stale references to it that might exist further down the call stack.
        fn pop_frame(&mut self, persist: bool) {
            if !persist && self.top_frame().entry_point == ExportedFunction::Constructor {
                self.nonce.as_mut().map(|c| *c = c.wrapping_sub(1));
            }
            let frame = self.frames.pop();
            if let Some(mut frame) = frame {
                let account_id = &frame.account_id;
                let prev = self.frames.last_mut().unwrap_or(&mut self.first_frame);
                prev.nested_gas.absorb_nested(frame.nested_gas);
                if !persist {
                    return;
                }
                frame.contract_info.load(account_id);
                let deposit_account = frame
                    .contract_info
                    .deposit_account()
                    .expect(
                        "Is only `None` when the info is invalidated.
				We just re-loaded from storage which either makes the state `Cached` or `Terminated`.
				qed",
                    )
                    .clone();
                let mut contract = frame.contract_info.into_contract();
                prev.nested_storage.absorb(
                    frame.nested_storage,
                    deposit_account,
                    contract.as_mut(),
                );
                if let Some(contract) = contract {
                    if prev.account_id == *account_id {
                        prev.contract_info = CachedContract::Cached(contract);
                        return;
                    }
                    <ContractInfoOf<T>>::insert(account_id, contract);
                    if let Some(c) = self
                        .frames_mut()
                        .skip(1)
                        .find(|f| f.account_id == *account_id)
                    {
                        c.contract_info = CachedContract::Invalidated;
                    }
                }
            } else {
                if let Some((msg, false)) = self.debug_message.as_ref().map(|m| (m, m.is_empty())) {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                format_args!(
                                    "Execution finished with debug buffer: {0}",
                                    core::str::from_utf8(msg).unwrap_or("<Invalid UTF8>")
                                ),
                                lvl,
                                &(
                                    LOG_TARGET,
                                    "pallet_contracts::exec",
                                    "frame/contracts/src/exec.rs",
                                    1046u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                }
                self.gas_meter
                    .absorb_nested(mem::take(&mut self.first_frame.nested_gas));
                if !persist {
                    return;
                }
                let deposit_account = self . first_frame . contract_info . deposit_account () . expect ("Is only `None` when the info is invalidated. The first frame can't be invalidated.
				qed") . clone () ;
                let mut contract = self.first_frame.contract_info.as_contract();
                self.storage_meter.absorb(
                    mem::take(&mut self.first_frame.nested_storage),
                    deposit_account,
                    contract.as_deref_mut(),
                );
                if let Some(contract) = contract {
                    <ContractInfoOf<T>>::insert(&self.first_frame.account_id, contract);
                }
                if let Some(nonce) = self.nonce {
                    <Nonce<T>>::set(nonce);
                }
            }
        }
        /// Transfer some funds from `from` to `to`.
        fn transfer(
            existence_requirement: ExistenceRequirement,
            from: &T::AccountId,
            to: &T::AccountId,
            value: BalanceOf<T>,
        ) -> DispatchResult {
            T::Currency::transfer(from, to, value, existence_requirement)
                .map_err(|_| Error::<T>::TransferFailed)?;
            Ok(())
        }
        fn initial_transfer(&self) -> DispatchResult {
            let frame = self.top_frame();
            if frame.delegate_caller.is_some() {
                return Ok(());
            }
            let value = frame.value_transferred;
            let caller = match self.caller() {
                Origin::Signed(caller) => caller,
                Origin::Root if value.is_zero() => return Ok(()),
                Origin::Root => return DispatchError::RootNotAllowed.into(),
            };
            Self::transfer(
                ExistenceRequirement::KeepAlive,
                &caller,
                &frame.account_id,
                value,
            )
        }
        /// Reference to the current (top) frame.
        fn top_frame(&self) -> &Frame<T> {
            self.frames.last().unwrap_or(&self.first_frame)
        }
        /// Mutable reference to the current (top) frame.
        fn top_frame_mut(&mut self) -> &mut Frame<T> {
            self.frames.last_mut().unwrap_or(&mut self.first_frame)
        }
        /// Iterator over all frames.
        ///
        /// The iterator starts with the top frame and ends with the root frame.
        fn frames(&self) -> impl Iterator<Item = &Frame<T>> {
            sp_std::iter::once(&self.first_frame)
                .chain(&self.frames)
                .rev()
        }
        /// Same as `frames` but with a mutable reference as iterator item.
        fn frames_mut(&mut self) -> impl Iterator<Item = &mut Frame<T>> {
            sp_std::iter::once(&mut self.first_frame)
                .chain(&mut self.frames)
                .rev()
        }
        /// Returns whether the current contract is on the stack multiple times.
        fn is_recursive(&self) -> bool {
            let account_id = &self.top_frame().account_id;
            self.frames().skip(1).any(|f| &f.account_id == account_id)
        }
        /// Returns whether the specified contract allows to be reentered right now.
        fn allows_reentry(&self, id: &AccountIdOf<T>) -> bool {
            !self
                .frames()
                .any(|f| &f.account_id == id && !f.allows_reentry)
        }
        /// Increments and returns the next nonce. Pulls it from storage if it isn't in cache.
        fn next_nonce(&mut self) -> u64 {
            let next = self.nonce().wrapping_add(1);
            self.nonce = Some(next);
            next
        }
    }
    impl<'a, T, E> Ext for Stack<'a, T, E>
    where
        T: Config,
        E: Executable<T>,
    {
        type T = T;
        fn call(
            &mut self,
            gas_limit: Weight,
            deposit_limit: BalanceOf<T>,
            to: T::AccountId,
            value: BalanceOf<T>,
            input_data: Vec<u8>,
            allows_reentry: bool,
        ) -> Result<ExecReturnValue, ExecError> {
            self.top_frame_mut().allows_reentry = allows_reentry;
            let try_call = || {
                if !self.allows_reentry(&to) {
                    return Err(<Error<T>>::ReentranceDenied.into());
                }
                let cached_info = self
                    .frames()
                    .find(|f| f.entry_point == ExportedFunction::Call && f.account_id == to)
                    .and_then(|f| match &f.contract_info {
                        CachedContract::Cached(contract) => Some(contract.clone()),
                        _ => None,
                    });
                let executable = self.push_frame(
                    FrameArgs::Call {
                        dest: to,
                        cached_info,
                        delegated_call: None,
                    },
                    value,
                    gas_limit,
                    deposit_limit,
                )?;
                self.run(executable, input_data)
            };
            let result = try_call();
            self.top_frame_mut().allows_reentry = true;
            result
        }
        fn delegate_call(
            &mut self,
            code_hash: CodeHash<Self::T>,
            input_data: Vec<u8>,
        ) -> Result<ExecReturnValue, ExecError> {
            let executable = E::from_storage(code_hash, self.schedule, self.gas_meter())?;
            let top_frame = self.top_frame_mut();
            let contract_info = top_frame.contract_info().clone();
            let account_id = top_frame.account_id.clone();
            let value = top_frame.value_transferred;
            let executable = self.push_frame(
                FrameArgs::Call {
                    dest: account_id,
                    cached_info: Some(contract_info),
                    delegated_call: Some(DelegatedCall {
                        executable,
                        caller: self.caller().clone(),
                    }),
                },
                value,
                Weight::zero(),
                BalanceOf::<T>::zero(),
            )?;
            self.run(executable, input_data)
        }
        fn instantiate(
            &mut self,
            gas_limit: Weight,
            deposit_limit: BalanceOf<Self::T>,
            code_hash: CodeHash<T>,
            value: BalanceOf<T>,
            input_data: Vec<u8>,
            salt: &[u8],
        ) -> Result<(AccountIdOf<T>, ExecReturnValue), ExecError> {
            let executable = E::from_storage(code_hash, self.schedule, self.gas_meter())?;
            let nonce = self.next_nonce();
            let executable = self.push_frame(
                FrameArgs::Instantiate {
                    sender: self.top_frame().account_id.clone(),
                    nonce,
                    executable,
                    salt,
                    input_data: input_data.as_ref(),
                },
                value,
                gas_limit,
                deposit_limit,
            )?;
            let account_id = self.top_frame().account_id.clone();
            self.run(executable, input_data)
                .map(|ret| (account_id, ret))
        }
        fn terminate(&mut self, beneficiary: &AccountIdOf<Self::T>) -> Result<(), DispatchError> {
            use frame_support::traits::fungible::Inspect;
            if self.is_recursive() {
                return Err(Error::<T>::TerminatedWhileReentrant.into());
            }
            let frame = self.top_frame_mut();
            let info = frame.terminate();
            frame.nested_storage.terminate(&info);
            System::<T>::dec_consumers(&frame.account_id);
            T::Currency::transfer(
                &frame.account_id,
                beneficiary,
                T::Currency::reducible_balance(&frame.account_id, Expendable, Polite),
                ExistenceRequirement::AllowDeath,
            )?;
            info.queue_trie_for_deletion();
            ContractInfoOf::<T>::remove(&frame.account_id);
            E::remove_user(info.code_hash);
            Contracts::<T>::deposit_event(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        T::Hashing::hash_of(&frame.account_id),
                        T::Hashing::hash_of(&beneficiary),
                    ]),
                ),
                Event::Terminated {
                    contract: frame.account_id.clone(),
                    beneficiary: beneficiary.clone(),
                },
            );
            Ok(())
        }
        fn transfer(&mut self, to: &T::AccountId, value: BalanceOf<T>) -> DispatchResult {
            Self::transfer(
                ExistenceRequirement::KeepAlive,
                &self.top_frame().account_id,
                to,
                value,
            )
        }
        fn get_storage(&mut self, key: &Key<T>) -> Option<Vec<u8>> {
            self.top_frame_mut().contract_info().read(key)
        }
        fn get_storage_size(&mut self, key: &Key<T>) -> Option<u32> {
            self.top_frame_mut().contract_info().size(key.into())
        }
        fn set_storage(
            &mut self,
            key: &Key<T>,
            value: Option<Vec<u8>>,
            take_old: bool,
        ) -> Result<WriteOutcome, DispatchError> {
            let frame = self.top_frame_mut();
            frame.contract_info.get(&frame.account_id).write(
                key.into(),
                value,
                Some(&mut frame.nested_storage),
                take_old,
            )
        }
        fn address(&self) -> &T::AccountId {
            &self.top_frame().account_id
        }
        fn caller(&self) -> Origin<T> {
            if let Some(caller) = &self.top_frame().delegate_caller {
                caller.clone()
            } else {
                self.frames()
                    .nth(1)
                    .map(|f| Origin::from_account_id(f.account_id.clone()))
                    .unwrap_or(self.origin.clone())
            }
        }
        fn is_contract(&self, address: &T::AccountId) -> bool {
            ContractInfoOf::<T>::contains_key(&address)
        }
        fn code_hash(&self, address: &T::AccountId) -> Option<CodeHash<Self::T>> {
            <ContractInfoOf<T>>::get(&address).map(|contract| contract.code_hash)
        }
        fn own_code_hash(&mut self) -> &CodeHash<Self::T> {
            &self.top_frame_mut().contract_info().code_hash
        }
        fn caller_is_origin(&self) -> bool {
            self.origin == self.caller()
        }
        fn caller_is_root(&self) -> bool {
            self.caller_is_origin() && self.origin == Origin::Root
        }
        fn balance(&self) -> BalanceOf<T> {
            T::Currency::free_balance(&self.top_frame().account_id)
        }
        fn value_transferred(&self) -> BalanceOf<T> {
            self.top_frame().value_transferred
        }
        fn random(&self, subject: &[u8]) -> (SeedOf<T>, BlockNumberOf<T>) {
            T::Randomness::random(subject)
        }
        fn now(&self) -> &MomentOf<T> {
            &self.timestamp
        }
        fn minimum_balance(&self) -> BalanceOf<T> {
            T::Currency::minimum_balance()
        }
        fn deposit_event(&mut self, topics: Vec<T::Hash>, data: Vec<u8>) {
            Contracts::<Self::T>::deposit_event(
                topics,
                Event::ContractEmitted {
                    contract: self.top_frame().account_id.clone(),
                    data,
                },
            );
        }
        fn block_number(&self) -> T::BlockNumber {
            self.block_number
        }
        fn max_value_size(&self) -> u32 {
            self.schedule.limits.payload_len
        }
        fn get_weight_price(&self, weight: Weight) -> BalanceOf<Self::T> {
            T::WeightPrice::convert(weight)
        }
        fn schedule(&self) -> &Schedule<Self::T> {
            self.schedule
        }
        fn gas_meter(&mut self) -> &mut GasMeter<Self::T> {
            &mut self.top_frame_mut().nested_gas
        }
        fn append_debug_buffer(&mut self, msg: &str) -> bool {
            if let Some(buffer) = &mut self.debug_message {
                buffer
                    .try_extend(&mut msg.bytes())
                    .map_err(|_| {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                format_args!(
                                    "Debug buffer (of {0} bytes) exhausted!",
                                    DebugBufferVec::<T>::bound()
                                ),
                                lvl,
                                &(
                                    LOG_TARGET,
                                    "pallet_contracts::exec",
                                    "frame/contracts/src/exec.rs",
                                    1397u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    })
                    .ok();
                true
            } else {
                false
            }
        }
        fn call_runtime(
            &self,
            call: <Self::T as Config>::RuntimeCall,
        ) -> DispatchResultWithPostInfo {
            let mut origin: T::RuntimeOrigin = RawOrigin::Signed(self.address().clone()).into();
            origin.add_filter(T::CallFilter::contains);
            call.dispatch(origin)
        }
        fn ecdsa_recover(
            &self,
            signature: &[u8; 65],
            message_hash: &[u8; 32],
        ) -> Result<[u8; 33], ()> {
            secp256k1_ecdsa_recover_compressed(signature, message_hash).map_err(|_| ())
        }
        fn sr25519_verify(&self, signature: &[u8; 64], message: &[u8], pub_key: &[u8; 32]) -> bool {
            sp_io::crypto::sr25519_verify(
                &SR25519Signature(*signature),
                message,
                &SR25519Public(*pub_key),
            )
        }
        fn ecdsa_to_eth_address(&self, pk: &[u8; 33]) -> Result<[u8; 20], ()> {
            ECDSAPublic(*pk).to_eth_address()
        }
        fn set_code_hash(&mut self, hash: CodeHash<Self::T>) -> Result<(), DispatchError> {
            let frame = self.frames.last_mut().unwrap_or(&mut self.first_frame);
            if !E::from_storage(hash, self.schedule, &mut frame.nested_gas)?.is_deterministic() {
                return Err(<Error<T>>::Indeterministic.into());
            }
            E::add_user(hash)?;
            let prev_hash = frame.contract_info().code_hash;
            E::remove_user(prev_hash);
            frame.contract_info().code_hash = hash;
            Contracts::<Self::T>::deposit_event(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        T::Hashing::hash_of(&frame.account_id),
                        hash,
                        prev_hash,
                    ]),
                ),
                Event::ContractCodeUpdated {
                    contract: frame.account_id.clone(),
                    new_code_hash: hash,
                    old_code_hash: prev_hash,
                },
            );
            Ok(())
        }
        fn reentrance_count(&self) -> u32 {
            let id: &AccountIdOf<Self::T> = &self.top_frame().account_id;
            self.account_reentrance_count(id).saturating_sub(1)
        }
        fn account_reentrance_count(&self, account_id: &AccountIdOf<Self::T>) -> u32 {
            self.frames()
                .filter(|f| f.delegate_caller.is_none() && &f.account_id == account_id)
                .count() as u32
        }
        fn nonce(&mut self) -> u64 {
            if let Some(current) = self.nonce {
                current
            } else {
                let current = <Nonce<T>>::get();
                self.nonce = Some(current);
                current
            }
        }
    }
    mod sealing {
        use super::*;
        pub trait Sealed {}
        impl<'a, T: Config, E> Sealed for Stack<'a, T, E> {}
    }
}
mod gas {
    use crate::{exec::ExecError, Config, Error};
    use frame_support::{
        dispatch::{
            DispatchError, DispatchErrorWithPostInfo, DispatchResultWithPostInfo, PostDispatchInfo,
        },
        weights::Weight,
        DefaultNoBound,
    };
    use sp_runtime::traits::Zero;
    use sp_std::marker::PhantomData;
    pub struct ChargedAmount(Weight);
    #[automatically_derived]
    impl ::core::fmt::Debug for ChargedAmount {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ChargedAmount", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ChargedAmount {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ChargedAmount {
        #[inline]
        fn eq(&self, other: &ChargedAmount) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ChargedAmount {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ChargedAmount {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Weight>;
        }
    }
    impl ChargedAmount {
        pub fn amount(&self) -> Weight {
            self.0
        }
    }
    #[cfg(not(test))]
    pub trait TestAuxiliaries {}
    #[cfg(not(test))]
    impl<T> TestAuxiliaries for T {}
    /// This trait represents a token that can be used for charging `GasMeter`.
    /// There is no other way of charging it.
    ///
    /// Implementing type is expected to be super lightweight hence `Copy` (`Clone` is added
    /// for consistency). If inlined there should be no observable difference compared
    /// to a hand-written code.
    pub trait Token<T: Config>: Copy + Clone + TestAuxiliaries {
        /// Return the amount of gas that should be taken by this token.
        ///
        /// This function should be really lightweight and must not fail. It is not
        /// expected that implementors will query the storage or do any kinds of heavy operations.
        ///
        /// That said, implementors of this function still can run into overflows
        /// while calculating the amount. In this case it is ok to use saturating operations
        /// since on overflow they will return `max_value` which should consume all gas.
        fn weight(&self) -> Weight;
    }
    pub struct GasMeter<T: Config> {
        gas_limit: Weight,
        /// Amount of gas left from initial gas limit. Can reach zero.
        gas_left: Weight,
        /// Due to `adjust_gas` and `nested` the `gas_left` can temporarily dip below its final value.
        gas_left_lowest: Weight,
        _phantom: PhantomData<T>,
    }
    const _: () = {
        impl<T: Config> core::default::Default for GasMeter<T> {
            fn default() -> Self {
                Self {
                    gas_limit: core::default::Default::default(),
                    gas_left: core::default::Default::default(),
                    gas_left_lowest: core::default::Default::default(),
                    _phantom: core::default::Default::default(),
                }
            }
        }
    };
    impl<T: Config> GasMeter<T> {
        pub fn new(gas_limit: Weight) -> Self {
            GasMeter {
                gas_limit,
                gas_left: gas_limit,
                gas_left_lowest: gas_limit,
                _phantom: PhantomData,
            }
        }
        /// Create a new gas meter by removing gas from the current meter.
        ///
        /// # Note
        ///
        /// Passing `0` as amount is interpreted as "all remaining gas".
        pub fn nested(&mut self, amount: Weight) -> Result<Self, DispatchError> {
            let amount = Weight::from_parts(
                if amount.ref_time().is_zero() {
                    self.gas_left().ref_time()
                } else {
                    amount.ref_time()
                },
                if amount.proof_size().is_zero() {
                    self.gas_left().proof_size()
                } else {
                    amount.proof_size()
                },
            );
            self.gas_left = self
                .gas_left
                .checked_sub(&amount)
                .ok_or_else(|| <Error<T>>::OutOfGas)?;
            Ok(GasMeter::new(amount))
        }
        /// Absorb the remaining gas of a nested meter after we are done using it.
        pub fn absorb_nested(&mut self, nested: Self) {
            if self.gas_left.ref_time().is_zero() {
                *self.gas_left_lowest.ref_time_mut() = nested
                    .gas_left_lowest()
                    .ref_time()
                    .min(self.gas_left_lowest.ref_time());
            } else {
                *self.gas_left_lowest.ref_time_mut() = self.gas_left_lowest().ref_time();
            }
            if self.gas_left.proof_size().is_zero() {
                *self.gas_left_lowest.proof_size_mut() = nested
                    .gas_left_lowest()
                    .proof_size()
                    .min(self.gas_left_lowest.proof_size());
            } else {
                *self.gas_left_lowest.proof_size_mut() = self.gas_left_lowest().proof_size();
            }
            self.gas_left += nested.gas_left;
        }
        /// Account for used gas.
        ///
        /// Amount is calculated by the given `token`.
        ///
        /// Returns `OutOfGas` if there is not enough gas or addition of the specified
        /// amount of gas has lead to overflow. On success returns `Proceed`.
        ///
        /// NOTE that amount isn't consumed if there is not enough gas. This is considered
        /// safe because we always charge gas before performing any resource-spending action.
        #[inline]
        pub fn charge<Tok: Token<T>>(
            &mut self,
            token: Tok,
        ) -> Result<ChargedAmount, DispatchError> {
            let amount = token.weight();
            self.gas_left = self
                .gas_left
                .checked_sub(&amount)
                .ok_or_else(|| Error::<T>::OutOfGas)?;
            Ok(ChargedAmount(amount))
        }
        /// Adjust a previously charged amount down to its actual amount.
        ///
        /// This is when a maximum a priori amount was charged and then should be partially
        /// refunded to match the actual amount.
        pub fn adjust_gas<Tok: Token<T>>(&mut self, charged_amount: ChargedAmount, token: Tok) {
            self.gas_left_lowest = self.gas_left_lowest();
            let adjustment = charged_amount.0.saturating_sub(token.weight());
            self.gas_left = self.gas_left.saturating_add(adjustment).min(self.gas_limit);
        }
        /// Returns the amount of gas that is required to run the same call.
        ///
        /// This can be different from `gas_spent` because due to `adjust_gas` the amount of
        /// spent gas can temporarily drop and be refunded later.
        pub fn gas_required(&self) -> Weight {
            self.gas_limit - self.gas_left_lowest()
        }
        /// Returns how much gas was spent
        pub fn gas_consumed(&self) -> Weight {
            self.gas_limit - self.gas_left
        }
        /// Returns how much gas left from the initial budget.
        pub fn gas_left(&self) -> Weight {
            self.gas_left
        }
        /// Turn this GasMeter into a DispatchResult that contains the actually used gas.
        pub fn into_dispatch_result<R, E>(
            self,
            result: Result<R, E>,
            base_weight: Weight,
        ) -> DispatchResultWithPostInfo
        where
            E: Into<ExecError>,
        {
            let post_info = PostDispatchInfo {
                actual_weight: Some(self.gas_consumed().saturating_add(base_weight)),
                pays_fee: Default::default(),
            };
            result
                .map(|_| post_info)
                .map_err(|e| DispatchErrorWithPostInfo {
                    post_info,
                    error: e.into().error,
                })
        }
        fn gas_left_lowest(&self) -> Weight {
            self.gas_left_lowest.min(self.gas_left)
        }
    }
}
mod migration {
    use crate::{BalanceOf, CodeHash, Config, Pallet, TrieId, Weight};
    use codec::{Decode, Encode};
    use frame_support::{
        codec,
        pallet_prelude::*,
        storage::migration,
        storage_alias,
        traits::{Get, OnRuntimeUpgrade},
        Identity, Twox64Concat,
    };
    use sp_runtime::traits::Saturating;
    use sp_std::{marker::PhantomData, prelude::*};
    /// Performs all necessary migrations based on `StorageVersion`.
    pub struct Migration<T: Config>(PhantomData<T>);
    impl<T: Config> OnRuntimeUpgrade for Migration<T> {
        fn on_runtime_upgrade() -> Weight {
            let version = <Pallet<T>>::on_chain_storage_version();
            let mut weight = Weight::zero();
            if version < 4 {
                v4::migrate::<T>(&mut weight);
            }
            if version < 5 {
                v5::migrate::<T>(&mut weight);
            }
            if version < 6 {
                v6::migrate::<T>(&mut weight);
            }
            if version < 7 {
                v7::migrate::<T>(&mut weight);
            }
            if version < 8 {
                v8::migrate::<T>(&mut weight);
            }
            if version < 9 {
                v9::migrate::<T>(&mut weight);
            }
            StorageVersion::new(9).put::<Pallet<T>>();
            weight.saturating_accrue(T::DbWeight::get().writes(1));
            weight
        }
    }
    /// V4: `Schedule` is changed to be a config item rather than an in-storage value.
    mod v4 {
        use super::*;
        pub fn migrate<T: Config>(weight: &mut Weight) {
            #[allow(deprecated)]
            migration::remove_storage_prefix(
                <Pallet<T>>::name().as_bytes(),
                b"CurrentSchedule",
                b"",
            );
            weight.saturating_accrue(T::DbWeight::get().writes(1));
        }
    }
    /// V5: State rent is removed which obsoletes some fields in `ContractInfo`.
    mod v5 {
        use super::*;
        type AliveContractInfo<T> = RawAliveContractInfo<
            CodeHash<T>,
            BalanceOf<T>,
            <T as frame_system::Config>::BlockNumber,
        >;
        type TombstoneContractInfo<T> = RawTombstoneContractInfo<
            <T as frame_system::Config>::Hash,
            <T as frame_system::Config>::Hashing,
        >;
        enum OldContractInfo<T: Config> {
            Alive(AliveContractInfo<T>),
            Tombstone(TombstoneContractInfo<T>),
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for OldContractInfo<T>
            where
                AliveContractInfo<T>: ::codec::Decode,
                AliveContractInfo<T>: ::codec::Decode,
                TombstoneContractInfo<T>: ::codec::Decode,
                TombstoneContractInfo<T>: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy.read_byte().map_err(|e| {
                        e.chain("Could not decode `OldContractInfo`, failed to read variant byte")
                    })? {
                        __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                            ::core::result::Result::Ok(OldContractInfo::<T>::Alive({
                                let __codec_res_edqy =
                                    <AliveContractInfo<T> as ::codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `OldContractInfo::Alive.0`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }))
                        }
                        __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                            ::core::result::Result::Ok(OldContractInfo::<T>::Tombstone({
                                let __codec_res_edqy =
                                    <TombstoneContractInfo<T> as ::codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `OldContractInfo::Tombstone.0`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }))
                        }
                        _ => ::core::result::Result::Err(<_ as ::core::convert::Into<_>>::into(
                            "Could not decode `OldContractInfo`, variant doesn't exist",
                        )),
                    }
                }
            }
        };
        struct RawAliveContractInfo<CodeHash, Balance, BlockNumber> {
            trie_id: TrieId,
            _storage_size: u32,
            _pair_count: u32,
            code_hash: CodeHash,
            _rent_allowance: Balance,
            _rent_paid: Balance,
            _deduct_block: BlockNumber,
            _last_write: Option<BlockNumber>,
            _reserved: Option<()>,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<CodeHash, Balance, BlockNumber> ::codec::Decode
                for RawAliveContractInfo<CodeHash, Balance, BlockNumber>
            where
                CodeHash: ::codec::Decode,
                CodeHash: ::codec::Decode,
                Balance: ::codec::Decode,
                Balance: ::codec::Decode,
                Balance: ::codec::Decode,
                Balance: ::codec::Decode,
                BlockNumber: ::codec::Decode,
                BlockNumber: ::codec::Decode,
                Option<BlockNumber>: ::codec::Decode,
                Option<BlockNumber>: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(RawAliveContractInfo::<
                        CodeHash,
                        Balance,
                        BlockNumber,
                    > {
                        trie_id: {
                            let __codec_res_edqy =
                                <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawAliveContractInfo::trie_id`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _storage_size: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_storage_size`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _pair_count: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_pair_count`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        code_hash: {
                            let __codec_res_edqy =
                                <CodeHash as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::code_hash`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _rent_allowance: {
                            let __codec_res_edqy =
                                <Balance as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_rent_allowance`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _rent_paid: {
                            let __codec_res_edqy =
                                <Balance as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_rent_paid`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _deduct_block: {
                            let __codec_res_edqy =
                                <BlockNumber as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_deduct_block`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _last_write: {
                            let __codec_res_edqy = <Option<BlockNumber> as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_last_write`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _reserved: {
                            let __codec_res_edqy =
                                <Option<()> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawAliveContractInfo::_reserved`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        struct RawTombstoneContractInfo<H, Hasher>(H, PhantomData<Hasher>);
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<H, Hasher> ::codec::Decode for RawTombstoneContractInfo<H, Hasher>
            where
                H: ::codec::Decode,
                H: ::codec::Decode,
                PhantomData<Hasher>: ::codec::Decode,
                PhantomData<Hasher>: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(RawTombstoneContractInfo::<H, Hasher>(
                        {
                            let __codec_res_edqy =
                                <H as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawTombstoneContractInfo.0`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy = <PhantomData<Hasher> as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawTombstoneContractInfo.1`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    ))
                }
            }
        };
        struct OldDeletedContract {
            _pair_count: u32,
            trie_id: TrieId,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for OldDeletedContract {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(OldDeletedContract {
                        _pair_count: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `OldDeletedContract::_pair_count`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        trie_id: {
                            let __codec_res_edqy =
                                <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OldDeletedContract::trie_id`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        pub type ContractInfo<T> = RawContractInfo<CodeHash<T>>;
        pub struct RawContractInfo<CodeHash> {
            pub trie_id: TrieId,
            pub code_hash: CodeHash,
            pub _reserved: Option<()>,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<CodeHash> ::codec::Encode for RawContractInfo<CodeHash>
            where
                CodeHash: ::codec::Encode,
                CodeHash: ::codec::Encode,
            {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    ::codec::Encode::encode_to(&self.trie_id, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.code_hash, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self._reserved, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl<CodeHash> ::codec::EncodeLike for RawContractInfo<CodeHash>
            where
                CodeHash: ::codec::Encode,
                CodeHash: ::codec::Encode,
            {
            }
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<CodeHash> ::codec::Decode for RawContractInfo<CodeHash>
            where
                CodeHash: ::codec::Decode,
                CodeHash: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(RawContractInfo::<CodeHash> {
                        trie_id: {
                            let __codec_res_edqy =
                                <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawContractInfo::trie_id`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        code_hash: {
                            let __codec_res_edqy =
                                <CodeHash as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawContractInfo::code_hash`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        _reserved: {
                            let __codec_res_edqy =
                                <Option<()> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawContractInfo::_reserved`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        struct DeletedContract {
            trie_id: TrieId,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for DeletedContract {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    ::codec::Encode::encode_to(&&self.trie_id, __codec_dest_edqy)
                }
                fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                    ::codec::Encode::encode(&&self.trie_id)
                }
                fn using_encoded<R, F: ::core::ops::FnOnce(&[::core::primitive::u8]) -> R>(
                    &self,
                    f: F,
                ) -> R {
                    ::codec::Encode::using_encoded(&&self.trie_id, f)
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for DeletedContract {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for DeletedContract {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(DeletedContract {
                        trie_id: {
                            let __codec_res_edqy =
                                <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `DeletedContract::trie_id`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        #[allow(non_camel_case_types)]
        struct ContractInfoOf_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for ContractInfoOf_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "ContractInfoOf";
        }
        type ContractInfoOf<T> = frame_support::storage::types::StorageMap<
            ContractInfoOf_Storage_Instance<T>,
            Twox64Concat,
            <T as frame_system::Config>::AccountId,
            ContractInfo<T>,
        >;
        #[allow(non_camel_case_types)]
        struct DeletionQueue_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for DeletionQueue_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "DeletionQueue";
        }
        type DeletionQueue<T> = frame_support::storage::types::StorageValue<
            DeletionQueue_Storage_Instance<T>,
            Vec<DeletedContract>,
        >;
        pub fn migrate<T: Config>(weight: &mut Weight) {
            <ContractInfoOf<T>>::translate(|_key, old: OldContractInfo<T>| {
                weight.saturating_accrue(T::DbWeight::get().reads_writes(1, 1));
                match old {
                    OldContractInfo::Alive(old) => Some(ContractInfo::<T> {
                        trie_id: old.trie_id,
                        code_hash: old.code_hash,
                        _reserved: old._reserved,
                    }),
                    OldContractInfo::Tombstone(_) => None,
                }
            });
            DeletionQueue::<T>::translate(|old: Option<Vec<OldDeletedContract>>| {
                weight.saturating_accrue(T::DbWeight::get().reads_writes(1, 1));
                old.map(|old| {
                    old.into_iter()
                        .map(|o| DeletedContract { trie_id: o.trie_id })
                        .collect()
                })
            })
            .ok();
        }
    }
    /// V6: Added storage deposits
    mod v6 {
        use super::*;
        struct OldPrefabWasmModule {
            #[codec(compact)]
            instruction_weights_version: u32,
            #[codec(compact)]
            initial: u32,
            #[codec(compact)]
            maximum: u32,
            #[codec(compact)]
            refcount: u64,
            _reserved: Option<()>,
            code: Vec<u8>,
            original_code_len: u32,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for OldPrefabWasmModule {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(
                                &self.instruction_weights_version
                            ),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(&self.initial),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(&self.maximum),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u64 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u64,
                            >>::RefType::from(&self.refcount),
                            __codec_dest_edqy,
                        );
                    }
                    ::codec::Encode::encode_to(&self._reserved, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.code, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.original_code_len, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for OldPrefabWasmModule {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for OldPrefabWasmModule {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(OldPrefabWasmModule {
                        instruction_weights_version: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `OldPrefabWasmModule::instruction_weights_version`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                        },
                        initial: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OldPrefabWasmModule::initial`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        maximum: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OldPrefabWasmModule::maximum`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        refcount: {
                            let __codec_res_edqy =
                                <<u64 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OldPrefabWasmModule::refcount`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        _reserved: {
                            let __codec_res_edqy =
                                <Option<()> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `OldPrefabWasmModule::_reserved`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        code: {
                            let __codec_res_edqy =
                                <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OldPrefabWasmModule::code`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        original_code_len: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `OldPrefabWasmModule::original_code_len`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        pub struct PrefabWasmModule {
            #[codec(compact)]
            pub instruction_weights_version: u32,
            #[codec(compact)]
            pub initial: u32,
            #[codec(compact)]
            pub maximum: u32,
            pub code: Vec<u8>,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for PrefabWasmModule {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(
                                &self.instruction_weights_version
                            ),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(&self.initial),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(&self.maximum),
                            __codec_dest_edqy,
                        );
                    }
                    ::codec::Encode::encode_to(&self.code, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for PrefabWasmModule {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for PrefabWasmModule {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(PrefabWasmModule {
                        instruction_weights_version: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `PrefabWasmModule::instruction_weights_version`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                        },
                        initial: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::initial`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        maximum: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::maximum`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        code: {
                            let __codec_res_edqy =
                                <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::code`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        use v5::ContractInfo as OldContractInfo;
        pub struct RawContractInfo<CodeHash, Balance> {
            pub trie_id: TrieId,
            pub code_hash: CodeHash,
            pub storage_deposit: Balance,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<CodeHash, Balance> ::codec::Encode for RawContractInfo<CodeHash, Balance>
            where
                CodeHash: ::codec::Encode,
                CodeHash: ::codec::Encode,
                Balance: ::codec::Encode,
                Balance: ::codec::Encode,
            {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    ::codec::Encode::encode_to(&self.trie_id, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.code_hash, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.storage_deposit, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl<CodeHash, Balance> ::codec::EncodeLike for RawContractInfo<CodeHash, Balance>
            where
                CodeHash: ::codec::Encode,
                CodeHash: ::codec::Encode,
                Balance: ::codec::Encode,
                Balance: ::codec::Encode,
            {
            }
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<CodeHash, Balance> ::codec::Decode for RawContractInfo<CodeHash, Balance>
            where
                CodeHash: ::codec::Decode,
                CodeHash: ::codec::Decode,
                Balance: ::codec::Decode,
                Balance: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(RawContractInfo::<CodeHash, Balance> {
                        trie_id: {
                            let __codec_res_edqy =
                                <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawContractInfo::trie_id`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        code_hash: {
                            let __codec_res_edqy =
                                <CodeHash as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `RawContractInfo::code_hash`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        storage_deposit: {
                            let __codec_res_edqy =
                                <Balance as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `RawContractInfo::storage_deposit`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        pub struct OwnerInfo<T: Config> {
            owner: T::AccountId,
            #[codec(compact)]
            deposit: BalanceOf<T>,
            #[codec(compact)]
            refcount: u64,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Encode for OwnerInfo<T>
            where
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::HasCompact,
            {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    ::codec::Encode::encode_to(&self.owner, __codec_dest_edqy);
                    {
                        :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (& self . deposit) , __codec_dest_edqy) ;
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u64 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u64,
                            >>::RefType::from(&self.refcount),
                            __codec_dest_edqy,
                        );
                    }
                }
            }
            #[automatically_derived]
            impl<T: Config> ::codec::EncodeLike for OwnerInfo<T>
            where
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::HasCompact,
            {
            }
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for OwnerInfo<T>
            where
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::HasCompact,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(OwnerInfo::<T> {
                        owner: {
                            let __codec_res_edqy =
                                <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OwnerInfo::owner`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        deposit: {
                            let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OwnerInfo::deposit`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        refcount: {
                            let __codec_res_edqy =
                                <<u64 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `OwnerInfo::refcount`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                    })
                }
            }
        };
        pub type ContractInfo<T> = RawContractInfo<CodeHash<T>, BalanceOf<T>>;
        #[allow(non_camel_case_types)]
        struct ContractInfoOf_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for ContractInfoOf_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "ContractInfoOf";
        }
        type ContractInfoOf<T> = frame_support::storage::types::StorageMap<
            ContractInfoOf_Storage_Instance<T>,
            Twox64Concat,
            <T as frame_system::Config>::AccountId,
            ContractInfo<T>,
        >;
        #[allow(non_camel_case_types)]
        struct CodeStorage_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for CodeStorage_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "CodeStorage";
        }
        type CodeStorage<T> = frame_support::storage::types::StorageMap<
            CodeStorage_Storage_Instance<T>,
            Identity,
            CodeHash<T>,
            PrefabWasmModule,
        >;
        #[allow(non_camel_case_types)]
        struct OwnerInfoOf_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for OwnerInfoOf_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "OwnerInfoOf";
        }
        type OwnerInfoOf<T> = frame_support::storage::types::StorageMap<
            OwnerInfoOf_Storage_Instance<T>,
            Identity,
            CodeHash<T>,
            OwnerInfo<T>,
        >;
        pub fn migrate<T: Config>(weight: &mut Weight) {
            <ContractInfoOf<T>>::translate(|_key, old: OldContractInfo<T>| {
                weight.saturating_accrue(T::DbWeight::get().reads_writes(1, 1));
                Some(ContractInfo::<T> {
                    trie_id: old.trie_id,
                    code_hash: old.code_hash,
                    storage_deposit: Default::default(),
                })
            });
            let nobody = T::AccountId::decode(&mut sp_runtime::traits::TrailingZeroInput::zeroes())
                .expect("Infinite input; no dead input space; qed");
            <CodeStorage<T>>::translate(|key, old: OldPrefabWasmModule| {
                weight.saturating_accrue(T::DbWeight::get().reads_writes(1, 2));
                <OwnerInfoOf<T>>::insert(
                    key,
                    OwnerInfo {
                        refcount: old.refcount,
                        owner: nobody.clone(),
                        deposit: Default::default(),
                    },
                );
                Some(PrefabWasmModule {
                    instruction_weights_version: old.instruction_weights_version,
                    initial: old.initial,
                    maximum: old.maximum,
                    code: old.code,
                })
            });
        }
    }
    /// Rename `AccountCounter` to `Nonce`.
    mod v7 {
        use super::*;
        pub fn migrate<T: Config>(weight: &mut Weight) {
            #[allow(non_camel_case_types)]
            struct AccountCounter_Storage_Instance<T: Config>(
                frame_support::sp_std::marker::PhantomData<(T)>,
            );
            impl<T: Config> frame_support::traits::StorageInstance for AccountCounter_Storage_Instance<T> {
                fn pallet_prefix() -> &'static str {
                    <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
                }
                const STORAGE_PREFIX: &'static str = "AccountCounter";
            }
            type AccountCounter<T> = frame_support::storage::types::StorageValue<
                AccountCounter_Storage_Instance<T>,
                u64,
                ValueQuery,
            >;
            #[allow(non_camel_case_types)]
            struct Nonce_Storage_Instance<T: Config>(
                frame_support::sp_std::marker::PhantomData<(T)>,
            );
            impl<T: Config> frame_support::traits::StorageInstance for Nonce_Storage_Instance<T> {
                fn pallet_prefix() -> &'static str {
                    <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
                }
                const STORAGE_PREFIX: &'static str = "Nonce";
            }
            type Nonce<T> = frame_support::storage::types::StorageValue<
                Nonce_Storage_Instance<T>,
                u64,
                ValueQuery,
            >;
            Nonce::<T>::set(AccountCounter::<T>::take());
            weight.saturating_accrue(T::DbWeight::get().reads_writes(1, 2))
        }
    }
    /// Update `ContractInfo` with new fields that track storage deposits.
    mod v8 {
        use super::*;
        use sp_io::default_child_storage as child;
        use v6::ContractInfo as OldContractInfo;
        pub struct ContractInfo<T: Config> {
            pub trie_id: TrieId,
            pub code_hash: CodeHash<T>,
            pub storage_bytes: u32,
            pub storage_items: u32,
            pub storage_byte_deposit: BalanceOf<T>,
            pub storage_item_deposit: BalanceOf<T>,
            pub storage_base_deposit: BalanceOf<T>,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Encode for ContractInfo<T>
            where
                CodeHash<T>: ::codec::Encode,
                CodeHash<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
            {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    ::codec::Encode::encode_to(&self.trie_id, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.code_hash, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.storage_bytes, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.storage_items, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.storage_byte_deposit, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.storage_item_deposit, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.storage_base_deposit, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl<T: Config> ::codec::EncodeLike for ContractInfo<T>
            where
                CodeHash<T>: ::codec::Encode,
                CodeHash<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
            {
            }
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for ContractInfo<T>
            where
                CodeHash<T>: ::codec::Decode,
                CodeHash<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(ContractInfo::<T> {
                        trie_id: {
                            let __codec_res_edqy =
                                <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `ContractInfo::trie_id`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        code_hash: {
                            let __codec_res_edqy =
                                <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `ContractInfo::code_hash`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        storage_bytes: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `ContractInfo::storage_bytes`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        storage_items: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `ContractInfo::storage_items`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        storage_byte_deposit: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `ContractInfo::storage_byte_deposit`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        storage_item_deposit: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `ContractInfo::storage_item_deposit`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        storage_base_deposit: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(e.chain(
                                        "Could not decode `ContractInfo::storage_base_deposit`",
                                    ))
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        #[allow(non_camel_case_types)]
        struct ContractInfoOf_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for ContractInfoOf_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "ContractInfoOf";
        }
        type ContractInfoOf<T, V> = frame_support::storage::types::StorageMap<
            ContractInfoOf_Storage_Instance<T>,
            Twox64Concat,
            <T as frame_system::Config>::AccountId,
            V,
        >;
        pub fn migrate<T: Config>(weight: &mut Weight) {
            <ContractInfoOf<T, ContractInfo<T>>>::translate_values(|old: OldContractInfo<T>| {
                let mut storage_bytes = 0u32;
                let mut storage_items = 0u32;
                let mut key = Vec::new();
                while let Some(next) = child::next_key(&old.trie_id, &key) {
                    key = next;
                    let mut val_out = [];
                    let len = child::read(&old.trie_id, &key, &mut val_out, 0)
                        .expect("The loop conditions checks for existence of the key; qed");
                    storage_bytes.saturating_accrue(len);
                    storage_items.saturating_accrue(1);
                }
                let storage_byte_deposit =
                    T::DepositPerByte::get().saturating_mul(storage_bytes.into());
                let storage_item_deposit =
                    T::DepositPerItem::get().saturating_mul(storage_items.into());
                let storage_base_deposit = old
                    .storage_deposit
                    .saturating_sub(storage_byte_deposit)
                    .saturating_sub(storage_item_deposit);
                weight.saturating_accrue(
                    T::DbWeight::get().reads_writes(u64::from(storage_items) + 1, 1),
                );
                Some(ContractInfo {
                    trie_id: old.trie_id,
                    code_hash: old.code_hash,
                    storage_bytes,
                    storage_items,
                    storage_byte_deposit,
                    storage_item_deposit,
                    storage_base_deposit,
                })
            });
        }
    }
    /// Update `CodeStorage` with the new `determinism` field.
    mod v9 {
        use super::*;
        use crate::Determinism;
        use v6::PrefabWasmModule as OldPrefabWasmModule;
        pub struct PrefabWasmModule {
            #[codec(compact)]
            pub instruction_weights_version: u32,
            #[codec(compact)]
            pub initial: u32,
            #[codec(compact)]
            pub maximum: u32,
            pub code: Vec<u8>,
            pub determinism: Determinism,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for PrefabWasmModule {
                fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                    &self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy,
                ) {
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(
                                &self.instruction_weights_version
                            ),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(&self.initial),
                            __codec_dest_edqy,
                        );
                    }
                    {
                        ::codec::Encode::encode_to(
                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                u32,
                            >>::RefType::from(&self.maximum),
                            __codec_dest_edqy,
                        );
                    }
                    ::codec::Encode::encode_to(&self.code, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.determinism, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for PrefabWasmModule {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for PrefabWasmModule {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(PrefabWasmModule {
                        instruction_weights_version: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `PrefabWasmModule::instruction_weights_version`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                        },
                        initial: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::initial`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        maximum: {
                            let __codec_res_edqy =
                                <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::maximum`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        code: {
                            let __codec_res_edqy =
                                <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::code`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        determinism: {
                            let __codec_res_edqy =
                                <Determinism as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `PrefabWasmModule::determinism`"),
                                    )
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    })
                }
            }
        };
        #[allow(non_camel_case_types)]
        struct CodeStorage_Storage_Instance<T: Config>(
            frame_support::sp_std::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance for CodeStorage_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "CodeStorage";
        }
        type CodeStorage<T> = frame_support::storage::types::StorageMap<
            CodeStorage_Storage_Instance<T>,
            Identity,
            CodeHash<T>,
            PrefabWasmModule,
        >;
        pub fn migrate<T: Config>(weight: &mut Weight) {
            <CodeStorage<T>>::translate_values(|old: OldPrefabWasmModule| {
                weight.saturating_accrue(T::DbWeight::get().reads_writes(1, 1));
                Some(PrefabWasmModule {
                    instruction_weights_version: old.instruction_weights_version,
                    initial: old.initial,
                    maximum: old.maximum,
                    code: old.code,
                    determinism: Determinism::Enforced,
                })
            });
        }
    }
}
mod schedule {
    //! This module contains the cost schedule and supporting code that constructs a
    //! sane default schedule from a `WeightInfo` implementation.
    use crate::{wasm::Determinism, weights::WeightInfo, Config};
    use codec::{Decode, Encode};
    use frame_support::{weights::Weight, DefaultNoBound};
    use pallet_contracts_proc_macro::{ScheduleDebug, WeightDebug};
    use scale_info::TypeInfo;
    #[cfg(feature = "std")]
    use serde::{Deserialize, Serialize};
    use sp_runtime::RuntimeDebug;
    use sp_std::marker::PhantomData;
    use wasm_instrument::{gas_metering, parity_wasm::elements};
    /// Definition of the cost schedule and other parameterizations for the wasm vm.
    ///
    /// Its [`Default`] implementation is the designated way to initialize this type. It uses
    /// the benchmarked information supplied by [`Config::WeightInfo`]. All of its fields are
    /// public and can therefore be modified. For example in order to change some of the limits
    /// and set a custom instruction weight version the following code could be used:
    /// ```rust
    /// use pallet_contracts::{Schedule, Limits, InstructionWeights, Config};
    ///
    /// fn create_schedule<T: Config>() -> Schedule<T> {
    ///     Schedule {
    ///         limits: Limits {
    /// 		        globals: 3,
    /// 		        parameters: 3,
    /// 		        memory_pages: 16,
    /// 		        table_size: 3,
    /// 		        br_table_size: 3,
    /// 		        .. Default::default()
    /// 	        },
    ///         instruction_weights: InstructionWeights {
    /// 	            version: 5,
    ///             .. Default::default()
    ///         },
    /// 	        .. Default::default()
    ///     }
    /// }
    /// ```
    ///
    /// # Note
    ///
    /// Please make sure to bump the [`InstructionWeights::version`] whenever substantial
    /// changes are made to its values.
    #[serde(bound(serialize = "", deserialize = ""))]
    #[scale_info(skip_type_params(T))]
    pub struct Schedule<T: Config> {
        /// Describes the upper limits on various metrics.
        pub limits: Limits,
        /// The weights for individual wasm instructions.
        pub instruction_weights: InstructionWeights<T>,
        /// The weights for each imported function a contract is allowed to call.
        pub host_fn_weights: HostFnWeights<T>,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for Schedule<T> {
        #[inline]
        fn clone(&self) -> Schedule<T> {
            Schedule {
                limits: ::core::clone::Clone::clone(&self.limits),
                instruction_weights: ::core::clone::Clone::clone(&self.instruction_weights),
                host_fn_weights: ::core::clone::Clone::clone(&self.host_fn_weights),
            }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for Schedule<T>
        where
            InstructionWeights<T>: ::codec::Encode,
            InstructionWeights<T>: ::codec::Encode,
            HostFnWeights<T>: ::codec::Encode,
            HostFnWeights<T>: ::codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.limits, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.instruction_weights, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.host_fn_weights, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for Schedule<T>
        where
            InstructionWeights<T>: ::codec::Encode,
            InstructionWeights<T>: ::codec::Encode,
            HostFnWeights<T>: ::codec::Encode,
            HostFnWeights<T>: ::codec::Encode,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for Schedule<T>
        where
            InstructionWeights<T>: ::codec::Decode,
            InstructionWeights<T>: ::codec::Decode,
            HostFnWeights<T>: ::codec::Decode,
            HostFnWeights<T>: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(Schedule::<T> {
                    limits: {
                        let __codec_res_edqy =
                            <Limits as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Schedule::limits`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    instruction_weights: {
                        let __codec_res_edqy =
                            <InstructionWeights<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Schedule::instruction_weights`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    host_fn_weights: {
                        let __codec_res_edqy =
                            <HostFnWeights<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Schedule::host_fn_weights`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralPartialEq for Schedule<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for Schedule<T> {
        #[inline]
        fn eq(&self, other: &Schedule<T>) -> bool {
            self.limits == other.limits
                && self.instruction_weights == other.instruction_weights
                && self.host_fn_weights == other.host_fn_weights
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralEq for Schedule<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for Schedule<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Limits>;
            let _: ::core::cmp::AssertParamIsEq<InstructionWeights<T>>;
            let _: ::core::cmp::AssertParamIsEq<HostFnWeights<T>>;
        }
    }
    impl<T: Config> core::fmt::Debug for Schedule<T> {
        fn fmt(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            use ::sp_runtime::{FixedPointNumber, FixedU128 as Fixed};
            let mut formatter = formatter.debug_struct("Schedule");
            formatter.field("limits", &self.limits);
            formatter.field("instruction_weights", &self.instruction_weights);
            formatter.field("host_fn_weights", &self.host_fn_weights);
            formatter.finish()
        }
    }
    const _: () = {
        impl<T: Config> core::default::Default for Schedule<T> {
            fn default() -> Self {
                Self {
                    limits: core::default::Default::default(),
                    instruction_weights: core::default::Default::default(),
                    host_fn_weights: core::default::Default::default(),
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for Schedule<T>
        where
            InstructionWeights<T>: ::scale_info::TypeInfo + 'static,
            HostFnWeights<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Schedule" , "pallet_contracts::schedule")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["Definition of the cost schedule and other parameterizations for the wasm vm." , "" , "Its [`Default`] implementation is the designated way to initialize this type. It uses" , "the benchmarked information supplied by [`Config::WeightInfo`]. All of its fields are" , "public and can therefore be modified. For example in order to change some of the limits" , "and set a custom instruction weight version the following code could be used:" , "```rust" , "use pallet_contracts::{Schedule, Limits, InstructionWeights, Config};" , "" , "fn create_schedule<T: Config>() -> Schedule<T> {" , "    Schedule {" , "        limits: Limits {" , "\t\t        globals: 3," , "\t\t        parameters: 3," , "\t\t        memory_pages: 16," , "\t\t        table_size: 3," , "\t\t        br_table_size: 3," , "\t\t        .. Default::default()" , "\t        }," , "        instruction_weights: InstructionWeights {" , "\t            version: 5," , "            .. Default::default()" , "        }," , "\t        .. Default::default()" , "    }" , "}" , "```" , "" , "# Note" , "" , "Please make sure to bump the [`InstructionWeights::version`] whenever substantial" , "changes are made to its values."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < Limits > () . name ("limits") . type_name ("Limits") . docs (& ["Describes the upper limits on various metrics."])) . field (| f | f . ty :: < InstructionWeights < T > > () . name ("instruction_weights") . type_name ("InstructionWeights<T>") . docs (& ["The weights for individual wasm instructions."])) . field (| f | f . ty :: < HostFnWeights < T > > () . name ("host_fn_weights") . type_name ("HostFnWeights<T>") . docs (& ["The weights for each imported function a contract is allowed to call."])))
            }
        };
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<T: Config> _serde::Serialize for Schedule<T> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Schedule",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "limits",
                    &self.limits,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "instruction_weights",
                    &self.instruction_weights,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "host_fn_weights",
                    &self.host_fn_weights,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, T: Config> _serde::Deserialize<'de> for Schedule<T> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "limits" => _serde::__private::Ok(__Field::__field0),
                            "instruction_weights" => _serde::__private::Ok(__Field::__field1),
                            "host_fn_weights" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"limits" => _serde::__private::Ok(__Field::__field0),
                            b"instruction_weights" => _serde::__private::Ok(__Field::__field1),
                            b"host_fn_weights" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de, T: Config> {
                    marker: _serde::__private::PhantomData<Schedule<T>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, T: Config> _serde::de::Visitor<'de> for __Visitor<'de, T> {
                    type Value = Schedule<T>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Schedule")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Limits>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Schedule with 3 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            InstructionWeights<T>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Schedule with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            HostFnWeights<T>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Schedule with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Schedule {
                            limits: __field0,
                            instruction_weights: __field1,
                            host_fn_weights: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Limits> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<InstructionWeights<T>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<HostFnWeights<T>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "limits",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Limits>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "instruction_weights",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            InstructionWeights<T>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "host_fn_weights",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<HostFnWeights<T>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("limits") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("instruction_weights") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("host_fn_weights") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Schedule {
                            limits: __field0,
                            instruction_weights: __field1,
                            host_fn_weights: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] =
                    &["limits", "instruction_weights", "host_fn_weights"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Schedule",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Schedule<T>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Describes the upper limits on various metrics.
    ///
    /// # Note
    ///
    /// The values in this struct should never be decreased. The reason is that decreasing those
    /// values will break existing contracts which are above the new limits when a
    /// re-instrumentation is triggered.
    pub struct Limits {
        /// The maximum number of topics supported by an event.
        pub event_topics: u32,
        /// Maximum number of globals a module is allowed to declare.
        ///
        /// Globals are not limited through the linear memory limit `memory_pages`.
        pub globals: u32,
        /// Maximum number of locals a function can have.
        ///
        /// As wasm engine initializes each of the local, we need to limit their number to confine
        /// execution costs.
        pub locals: u32,
        /// Maximum numbers of parameters a function can have.
        ///
        /// Those need to be limited to prevent a potentially exploitable interaction with
        /// the stack height instrumentation: The costs of executing the stack height
        /// instrumentation for an indirectly called function scales linearly with the amount
        /// of parameters of this function. Because the stack height instrumentation itself is
        /// is not weight metered its costs must be static (via this limit) and included in
        /// the costs of the instructions that cause them (call, call_indirect).
        pub parameters: u32,
        /// Maximum number of memory pages allowed for a contract.
        pub memory_pages: u32,
        /// Maximum number of elements allowed in a table.
        ///
        /// Currently, the only type of element that is allowed in a table is funcref.
        pub table_size: u32,
        /// Maximum number of elements that can appear as immediate value to the br_table instruction.
        pub br_table_size: u32,
        /// The maximum length of a subject in bytes used for PRNG generation.
        pub subject_len: u32,
        /// The maximum size of a storage value and event payload in bytes.
        pub payload_len: u32,
        /// The maximum node runtime memory. This is for integrity checks only and does not affect the
        /// real setting.
        pub runtime_memory: u32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Limits {
        #[inline]
        fn clone(&self) -> Limits {
            Limits {
                event_topics: ::core::clone::Clone::clone(&self.event_topics),
                globals: ::core::clone::Clone::clone(&self.globals),
                locals: ::core::clone::Clone::clone(&self.locals),
                parameters: ::core::clone::Clone::clone(&self.parameters),
                memory_pages: ::core::clone::Clone::clone(&self.memory_pages),
                table_size: ::core::clone::Clone::clone(&self.table_size),
                br_table_size: ::core::clone::Clone::clone(&self.br_table_size),
                subject_len: ::core::clone::Clone::clone(&self.subject_len),
                payload_len: ::core::clone::Clone::clone(&self.payload_len),
                runtime_memory: ::core::clone::Clone::clone(&self.runtime_memory),
            }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Encode for Limits {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.event_topics, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.globals, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.locals, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.parameters, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.memory_pages, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.table_size, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.br_table_size, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.subject_len, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.payload_len, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.runtime_memory, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for Limits {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Decode for Limits {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(Limits {
                    event_topics: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::event_topics`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    globals: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::globals`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    locals: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::locals`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    parameters: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::parameters`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    memory_pages: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::memory_pages`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    table_size: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::table_size`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    br_table_size: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::br_table_size`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    subject_len: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::subject_len`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    payload_len: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::payload_len`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    runtime_memory: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Limits::runtime_memory`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Limits {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Limits {
        #[inline]
        fn eq(&self, other: &Limits) -> bool {
            self.event_topics == other.event_topics
                && self.globals == other.globals
                && self.locals == other.locals
                && self.parameters == other.parameters
                && self.memory_pages == other.memory_pages
                && self.table_size == other.table_size
                && self.br_table_size == other.br_table_size
                && self.subject_len == other.subject_len
                && self.payload_len == other.payload_len
                && self.runtime_memory == other.runtime_memory
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Limits {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Limits {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    impl core::fmt::Debug for Limits {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_struct("Limits")
                .field("event_topics", &self.event_topics)
                .field("globals", &self.globals)
                .field("locals", &self.locals)
                .field("parameters", &self.parameters)
                .field("memory_pages", &self.memory_pages)
                .field("table_size", &self.table_size)
                .field("br_table_size", &self.br_table_size)
                .field("subject_len", &self.subject_len)
                .field("payload_len", &self.payload_len)
                .field("runtime_memory", &self.runtime_memory)
                .finish()
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for Limits {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Limits" , "pallet_contracts::schedule")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["Describes the upper limits on various metrics." , "" , "# Note" , "" , "The values in this struct should never be decreased. The reason is that decreasing those" , "values will break existing contracts which are above the new limits when a" , "re-instrumentation is triggered."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < u32 > () . name ("event_topics") . type_name ("u32") . docs (& ["The maximum number of topics supported by an event."])) . field (| f | f . ty :: < u32 > () . name ("globals") . type_name ("u32") . docs (& ["Maximum number of globals a module is allowed to declare." , "" , "Globals are not limited through the linear memory limit `memory_pages`."])) . field (| f | f . ty :: < u32 > () . name ("locals") . type_name ("u32") . docs (& ["Maximum number of locals a function can have." , "" , "As wasm engine initializes each of the local, we need to limit their number to confine" , "execution costs."])) . field (| f | f . ty :: < u32 > () . name ("parameters") . type_name ("u32") . docs (& ["Maximum numbers of parameters a function can have." , "" , "Those need to be limited to prevent a potentially exploitable interaction with" , "the stack height instrumentation: The costs of executing the stack height" , "instrumentation for an indirectly called function scales linearly with the amount" , "of parameters of this function. Because the stack height instrumentation itself is" , "is not weight metered its costs must be static (via this limit) and included in" , "the costs of the instructions that cause them (call, call_indirect)."])) . field (| f | f . ty :: < u32 > () . name ("memory_pages") . type_name ("u32") . docs (& ["Maximum number of memory pages allowed for a contract."])) . field (| f | f . ty :: < u32 > () . name ("table_size") . type_name ("u32") . docs (& ["Maximum number of elements allowed in a table." , "" , "Currently, the only type of element that is allowed in a table is funcref."])) . field (| f | f . ty :: < u32 > () . name ("br_table_size") . type_name ("u32") . docs (& ["Maximum number of elements that can appear as immediate value to the br_table instruction."])) . field (| f | f . ty :: < u32 > () . name ("subject_len") . type_name ("u32") . docs (& ["The maximum length of a subject in bytes used for PRNG generation."])) . field (| f | f . ty :: < u32 > () . name ("payload_len") . type_name ("u32") . docs (& ["The maximum size of a storage value and event payload in bytes."])) . field (| f | f . ty :: < u32 > () . name ("runtime_memory") . type_name ("u32") . docs (& ["The maximum node runtime memory. This is for integrity checks only and does not affect the" , "real setting."])))
            }
        };
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Limits {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Limits",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "event_topics",
                    &self.event_topics,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "globals",
                    &self.globals,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "locals",
                    &self.locals,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parameters",
                    &self.parameters,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memory_pages",
                    &self.memory_pages,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "table_size",
                    &self.table_size,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "br_table_size",
                    &self.br_table_size,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "subject_len",
                    &self.subject_len,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "payload_len",
                    &self.payload_len,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "runtime_memory",
                    &self.runtime_memory,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Limits {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "event_topics" => _serde::__private::Ok(__Field::__field0),
                            "globals" => _serde::__private::Ok(__Field::__field1),
                            "locals" => _serde::__private::Ok(__Field::__field2),
                            "parameters" => _serde::__private::Ok(__Field::__field3),
                            "memory_pages" => _serde::__private::Ok(__Field::__field4),
                            "table_size" => _serde::__private::Ok(__Field::__field5),
                            "br_table_size" => _serde::__private::Ok(__Field::__field6),
                            "subject_len" => _serde::__private::Ok(__Field::__field7),
                            "payload_len" => _serde::__private::Ok(__Field::__field8),
                            "runtime_memory" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"event_topics" => _serde::__private::Ok(__Field::__field0),
                            b"globals" => _serde::__private::Ok(__Field::__field1),
                            b"locals" => _serde::__private::Ok(__Field::__field2),
                            b"parameters" => _serde::__private::Ok(__Field::__field3),
                            b"memory_pages" => _serde::__private::Ok(__Field::__field4),
                            b"table_size" => _serde::__private::Ok(__Field::__field5),
                            b"br_table_size" => _serde::__private::Ok(__Field::__field6),
                            b"subject_len" => _serde::__private::Ok(__Field::__field7),
                            b"payload_len" => _serde::__private::Ok(__Field::__field8),
                            b"runtime_memory" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Limits>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Limits;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Limits")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field4 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field5 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field6 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field7 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field8 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        let __field9 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct Limits with 10 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Limits {
                            event_topics: __field0,
                            globals: __field1,
                            locals: __field2,
                            parameters: __field3,
                            memory_pages: __field4,
                            table_size: __field5,
                            br_table_size: __field6,
                            subject_len: __field7,
                            payload_len: __field8,
                            runtime_memory: __field9,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<u32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "event_topics",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "globals",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "locals",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parameters",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "memory_pages",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "table_size",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "br_table_size",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "subject_len",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "payload_len",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "runtime_memory",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("event_topics") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("globals") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("locals") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("parameters") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("memory_pages") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("table_size") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("br_table_size") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("subject_len") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("payload_len") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("runtime_memory") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Limits {
                            event_topics: __field0,
                            globals: __field1,
                            locals: __field2,
                            parameters: __field3,
                            memory_pages: __field4,
                            table_size: __field5,
                            br_table_size: __field6,
                            subject_len: __field7,
                            payload_len: __field8,
                            runtime_memory: __field9,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "event_topics",
                    "globals",
                    "locals",
                    "parameters",
                    "memory_pages",
                    "table_size",
                    "br_table_size",
                    "subject_len",
                    "payload_len",
                    "runtime_memory",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Limits",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Limits>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Limits {
        /// The maximum memory size in bytes that a contract can occupy.
        pub fn max_memory_size(&self) -> u32 {
            self.memory_pages * 64 * 1024
        }
    }
    /// Describes the weight for all categories of supported wasm instructions.
    ///
    /// There there is one field for each wasm instruction that describes the weight to
    /// execute one instruction of that name. There are a few exceptions:
    ///
    /// 1. If there is a i64 and a i32 variant of an instruction we use the weight
    ///    of the former for both.
    /// 2. The following instructions are free of charge because they merely structure the
    ///    wasm module and cannot be spammed without making the module invalid (and rejected):
    ///    End, Unreachable, Return, Else
    /// 3. The following instructions cannot be benchmarked because they are removed by any
    ///    real world execution engine as a preprocessing step and therefore don't yield a
    ///    meaningful benchmark result. However, in contrast to the instructions mentioned
    ///    in 2. they can be spammed. We price them with the same weight as the "default"
    ///    instruction (i64.const): Block, Loop, Nop
    /// 4. We price both i64.const and drop as InstructionWeights.i64const / 2. The reason
    ///    for that is that we cannot benchmark either of them on its own but we need their
    ///    individual values to derive (by subtraction) the weight of all other instructions
    ///    that use them as supporting instructions. Supporting means mainly pushing arguments
    ///    and dropping return values in order to maintain a valid module.
    #[scale_info(skip_type_params(T))]
    pub struct InstructionWeights<T: Config> {
        /// Version of the instruction weights.
        ///
        /// # Note
        ///
        /// Should be incremented whenever any instruction weight is changed. The
        /// reason is that changes to instruction weights require a re-instrumentation
        /// in order to apply the changes to an already deployed code. The re-instrumentation
        /// is triggered by comparing the version of the current schedule with the version the code was
        /// instrumented with. Changes usually happen when pallet_contracts is re-benchmarked.
        ///
        /// Changes to other parts of the schedule should not increment the version in
        /// order to avoid unnecessary re-instrumentations.
        pub version: u32,
        /// Weight to be used for instructions which don't have benchmarks assigned.
        ///
        /// This weight is used whenever a code is uploaded with [`Determinism::Relaxed`]
        /// and an instruction (usually a float instruction) is encountered. This weight is **not**
        /// used if a contract is uploaded with [`Determinism::Enforced`]. If this field is set to
        /// `0` (the default) only deterministic codes are allowed to be uploaded.
        pub fallback: u32,
        pub i64const: u32,
        pub i64load: u32,
        pub i64store: u32,
        pub select: u32,
        pub r#if: u32,
        pub br: u32,
        pub br_if: u32,
        pub br_table: u32,
        pub br_table_per_entry: u32,
        pub call: u32,
        pub call_indirect: u32,
        pub call_per_local: u32,
        pub local_get: u32,
        pub local_set: u32,
        pub local_tee: u32,
        pub global_get: u32,
        pub global_set: u32,
        pub memory_current: u32,
        pub memory_grow: u32,
        pub i64clz: u32,
        pub i64ctz: u32,
        pub i64popcnt: u32,
        pub i64eqz: u32,
        pub i64extendsi32: u32,
        pub i64extendui32: u32,
        pub i32wrapi64: u32,
        pub i64eq: u32,
        pub i64ne: u32,
        pub i64lts: u32,
        pub i64ltu: u32,
        pub i64gts: u32,
        pub i64gtu: u32,
        pub i64les: u32,
        pub i64leu: u32,
        pub i64ges: u32,
        pub i64geu: u32,
        pub i64add: u32,
        pub i64sub: u32,
        pub i64mul: u32,
        pub i64divs: u32,
        pub i64divu: u32,
        pub i64rems: u32,
        pub i64remu: u32,
        pub i64and: u32,
        pub i64or: u32,
        pub i64xor: u32,
        pub i64shl: u32,
        pub i64shrs: u32,
        pub i64shru: u32,
        pub i64rotl: u32,
        pub i64rotr: u32,
        /// The type parameter is used in the default implementation.
        #[codec(skip)]
        pub _phantom: PhantomData<T>,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for InstructionWeights<T> {
        #[inline]
        fn clone(&self) -> InstructionWeights<T> {
            InstructionWeights {
                version: ::core::clone::Clone::clone(&self.version),
                fallback: ::core::clone::Clone::clone(&self.fallback),
                i64const: ::core::clone::Clone::clone(&self.i64const),
                i64load: ::core::clone::Clone::clone(&self.i64load),
                i64store: ::core::clone::Clone::clone(&self.i64store),
                select: ::core::clone::Clone::clone(&self.select),
                r#if: ::core::clone::Clone::clone(&self.r#if),
                br: ::core::clone::Clone::clone(&self.br),
                br_if: ::core::clone::Clone::clone(&self.br_if),
                br_table: ::core::clone::Clone::clone(&self.br_table),
                br_table_per_entry: ::core::clone::Clone::clone(&self.br_table_per_entry),
                call: ::core::clone::Clone::clone(&self.call),
                call_indirect: ::core::clone::Clone::clone(&self.call_indirect),
                call_per_local: ::core::clone::Clone::clone(&self.call_per_local),
                local_get: ::core::clone::Clone::clone(&self.local_get),
                local_set: ::core::clone::Clone::clone(&self.local_set),
                local_tee: ::core::clone::Clone::clone(&self.local_tee),
                global_get: ::core::clone::Clone::clone(&self.global_get),
                global_set: ::core::clone::Clone::clone(&self.global_set),
                memory_current: ::core::clone::Clone::clone(&self.memory_current),
                memory_grow: ::core::clone::Clone::clone(&self.memory_grow),
                i64clz: ::core::clone::Clone::clone(&self.i64clz),
                i64ctz: ::core::clone::Clone::clone(&self.i64ctz),
                i64popcnt: ::core::clone::Clone::clone(&self.i64popcnt),
                i64eqz: ::core::clone::Clone::clone(&self.i64eqz),
                i64extendsi32: ::core::clone::Clone::clone(&self.i64extendsi32),
                i64extendui32: ::core::clone::Clone::clone(&self.i64extendui32),
                i32wrapi64: ::core::clone::Clone::clone(&self.i32wrapi64),
                i64eq: ::core::clone::Clone::clone(&self.i64eq),
                i64ne: ::core::clone::Clone::clone(&self.i64ne),
                i64lts: ::core::clone::Clone::clone(&self.i64lts),
                i64ltu: ::core::clone::Clone::clone(&self.i64ltu),
                i64gts: ::core::clone::Clone::clone(&self.i64gts),
                i64gtu: ::core::clone::Clone::clone(&self.i64gtu),
                i64les: ::core::clone::Clone::clone(&self.i64les),
                i64leu: ::core::clone::Clone::clone(&self.i64leu),
                i64ges: ::core::clone::Clone::clone(&self.i64ges),
                i64geu: ::core::clone::Clone::clone(&self.i64geu),
                i64add: ::core::clone::Clone::clone(&self.i64add),
                i64sub: ::core::clone::Clone::clone(&self.i64sub),
                i64mul: ::core::clone::Clone::clone(&self.i64mul),
                i64divs: ::core::clone::Clone::clone(&self.i64divs),
                i64divu: ::core::clone::Clone::clone(&self.i64divu),
                i64rems: ::core::clone::Clone::clone(&self.i64rems),
                i64remu: ::core::clone::Clone::clone(&self.i64remu),
                i64and: ::core::clone::Clone::clone(&self.i64and),
                i64or: ::core::clone::Clone::clone(&self.i64or),
                i64xor: ::core::clone::Clone::clone(&self.i64xor),
                i64shl: ::core::clone::Clone::clone(&self.i64shl),
                i64shrs: ::core::clone::Clone::clone(&self.i64shrs),
                i64shru: ::core::clone::Clone::clone(&self.i64shru),
                i64rotl: ::core::clone::Clone::clone(&self.i64rotl),
                i64rotr: ::core::clone::Clone::clone(&self.i64rotr),
                _phantom: ::core::clone::Clone::clone(&self._phantom),
            }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for InstructionWeights<T> {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.version, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.fallback, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64const, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64load, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64store, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.select, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.r#if, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.br, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.br_if, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.br_table, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.br_table_per_entry, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.call, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.call_indirect, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.call_per_local, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.local_get, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.local_set, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.local_tee, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.global_get, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.global_set, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.memory_current, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.memory_grow, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64clz, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64ctz, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64popcnt, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64eqz, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64extendsi32, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64extendui32, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i32wrapi64, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64eq, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64ne, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64lts, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64ltu, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64gts, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64gtu, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64les, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64leu, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64ges, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64geu, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64add, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64sub, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64mul, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64divs, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64divu, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64rems, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64remu, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64and, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64or, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64xor, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64shl, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64shrs, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64shru, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64rotl, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.i64rotr, __codec_dest_edqy);
                let _ = &self._phantom;
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for InstructionWeights<T> {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for InstructionWeights<T>
        where
            PhantomData<T>: Default,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(InstructionWeights::<T> {
                    version: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::version`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    fallback: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::fallback`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64const: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64const`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64load: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64load`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64store: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64store`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    select: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::select`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    r#if: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::r#if`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    br: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::br`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    br_if: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::br_if`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    br_table: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::br_table`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    br_table_per_entry: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `InstructionWeights::br_table_per_entry`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    call: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::call`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    call_indirect: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::call_indirect`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    call_per_local: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `InstructionWeights::call_per_local`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    local_get: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::local_get`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    local_set: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::local_set`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    local_tee: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::local_tee`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    global_get: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::global_get`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    global_set: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::global_set`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    memory_current: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `InstructionWeights::memory_current`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    memory_grow: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::memory_grow`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64clz: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64clz`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64ctz: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64ctz`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64popcnt: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64popcnt`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64eqz: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64eqz`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64extendsi32: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64extendsi32`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64extendui32: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64extendui32`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i32wrapi64: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i32wrapi64`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64eq: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64eq`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64ne: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64ne`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64lts: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64lts`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64ltu: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64ltu`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64gts: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64gts`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64gtu: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64gtu`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64les: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64les`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64leu: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64leu`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64ges: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64ges`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64geu: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64geu`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64add: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64add`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64sub: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64sub`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64mul: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64mul`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64divs: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64divs`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64divu: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64divu`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64rems: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64rems`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64remu: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64remu`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64and: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64and`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64or: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64or`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64xor: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64xor`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64shl: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64shl`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64shrs: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64shrs`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64shru: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64shru`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64rotl: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64rotl`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    i64rotr: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `InstructionWeights::i64rotr`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    _phantom: ::core::default::Default::default(),
                })
            }
        }
    };
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralPartialEq for InstructionWeights<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for InstructionWeights<T> {
        #[inline]
        fn eq(&self, other: &InstructionWeights<T>) -> bool {
            self.version == other.version
                && self.fallback == other.fallback
                && self.i64const == other.i64const
                && self.i64load == other.i64load
                && self.i64store == other.i64store
                && self.select == other.select
                && self.r#if == other.r#if
                && self.br == other.br
                && self.br_if == other.br_if
                && self.br_table == other.br_table
                && self.br_table_per_entry == other.br_table_per_entry
                && self.call == other.call
                && self.call_indirect == other.call_indirect
                && self.call_per_local == other.call_per_local
                && self.local_get == other.local_get
                && self.local_set == other.local_set
                && self.local_tee == other.local_tee
                && self.global_get == other.global_get
                && self.global_set == other.global_set
                && self.memory_current == other.memory_current
                && self.memory_grow == other.memory_grow
                && self.i64clz == other.i64clz
                && self.i64ctz == other.i64ctz
                && self.i64popcnt == other.i64popcnt
                && self.i64eqz == other.i64eqz
                && self.i64extendsi32 == other.i64extendsi32
                && self.i64extendui32 == other.i64extendui32
                && self.i32wrapi64 == other.i32wrapi64
                && self.i64eq == other.i64eq
                && self.i64ne == other.i64ne
                && self.i64lts == other.i64lts
                && self.i64ltu == other.i64ltu
                && self.i64gts == other.i64gts
                && self.i64gtu == other.i64gtu
                && self.i64les == other.i64les
                && self.i64leu == other.i64leu
                && self.i64ges == other.i64ges
                && self.i64geu == other.i64geu
                && self.i64add == other.i64add
                && self.i64sub == other.i64sub
                && self.i64mul == other.i64mul
                && self.i64divs == other.i64divs
                && self.i64divu == other.i64divu
                && self.i64rems == other.i64rems
                && self.i64remu == other.i64remu
                && self.i64and == other.i64and
                && self.i64or == other.i64or
                && self.i64xor == other.i64xor
                && self.i64shl == other.i64shl
                && self.i64shrs == other.i64shrs
                && self.i64shru == other.i64shru
                && self.i64rotl == other.i64rotl
                && self.i64rotr == other.i64rotr
                && self._phantom == other._phantom
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralEq for InstructionWeights<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for InstructionWeights<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
            let _: ::core::cmp::AssertParamIsEq<PhantomData<T>>;
        }
    }
    impl<T: Config> core::fmt::Debug for InstructionWeights<T> {
        fn fmt(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            use ::sp_runtime::{FixedPointNumber, FixedU128 as Fixed};
            let mut formatter = formatter.debug_struct("InstructionWeights");
            formatter.field("version", &self.version);
            formatter.field("fallback", &self.fallback);
            formatter.field("i64const", &self.i64const);
            formatter.field("i64load", &self.i64load);
            formatter.field("i64store", &self.i64store);
            formatter.field("select", &self.select);
            formatter.field("r#if", &self.r#if);
            formatter.field("br", &self.br);
            formatter.field("br_if", &self.br_if);
            formatter.field("br_table", &self.br_table);
            formatter.field("br_table_per_entry", &self.br_table_per_entry);
            formatter.field("call", &self.call);
            formatter.field("call_indirect", &self.call_indirect);
            formatter.field("call_per_local", &self.call_per_local);
            formatter.field("local_get", &self.local_get);
            formatter.field("local_set", &self.local_set);
            formatter.field("local_tee", &self.local_tee);
            formatter.field("global_get", &self.global_get);
            formatter.field("global_set", &self.global_set);
            formatter.field("memory_current", &self.memory_current);
            formatter.field("memory_grow", &self.memory_grow);
            formatter.field("i64clz", &self.i64clz);
            formatter.field("i64ctz", &self.i64ctz);
            formatter.field("i64popcnt", &self.i64popcnt);
            formatter.field("i64eqz", &self.i64eqz);
            formatter.field("i64extendsi32", &self.i64extendsi32);
            formatter.field("i64extendui32", &self.i64extendui32);
            formatter.field("i32wrapi64", &self.i32wrapi64);
            formatter.field("i64eq", &self.i64eq);
            formatter.field("i64ne", &self.i64ne);
            formatter.field("i64lts", &self.i64lts);
            formatter.field("i64ltu", &self.i64ltu);
            formatter.field("i64gts", &self.i64gts);
            formatter.field("i64gtu", &self.i64gtu);
            formatter.field("i64les", &self.i64les);
            formatter.field("i64leu", &self.i64leu);
            formatter.field("i64ges", &self.i64ges);
            formatter.field("i64geu", &self.i64geu);
            formatter.field("i64add", &self.i64add);
            formatter.field("i64sub", &self.i64sub);
            formatter.field("i64mul", &self.i64mul);
            formatter.field("i64divs", &self.i64divs);
            formatter.field("i64divu", &self.i64divu);
            formatter.field("i64rems", &self.i64rems);
            formatter.field("i64remu", &self.i64remu);
            formatter.field("i64and", &self.i64and);
            formatter.field("i64or", &self.i64or);
            formatter.field("i64xor", &self.i64xor);
            formatter.field("i64shl", &self.i64shl);
            formatter.field("i64shrs", &self.i64shrs);
            formatter.field("i64shru", &self.i64shru);
            formatter.field("i64rotl", &self.i64rotl);
            formatter.field("i64rotr", &self.i64rotr);
            formatter.finish()
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for InstructionWeights<T>
        where
            PhantomData<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("InstructionWeights" , "pallet_contracts::schedule")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["Describes the weight for all categories of supported wasm instructions." , "" , "There there is one field for each wasm instruction that describes the weight to" , "execute one instruction of that name. There are a few exceptions:" , "" , "1. If there is a i64 and a i32 variant of an instruction we use the weight" , "   of the former for both." , "2. The following instructions are free of charge because they merely structure the" , "   wasm module and cannot be spammed without making the module invalid (and rejected):" , "   End, Unreachable, Return, Else" , "3. The following instructions cannot be benchmarked because they are removed by any" , "   real world execution engine as a preprocessing step and therefore don't yield a" , "   meaningful benchmark result. However, in contrast to the instructions mentioned" , "   in 2. they can be spammed. We price them with the same weight as the \"default\"" , "   instruction (i64.const): Block, Loop, Nop" , "4. We price both i64.const and drop as InstructionWeights.i64const / 2. The reason" , "   for that is that we cannot benchmark either of them on its own but we need their" , "   individual values to derive (by subtraction) the weight of all other instructions" , "   that use them as supporting instructions. Supporting means mainly pushing arguments" , "   and dropping return values in order to maintain a valid module."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < u32 > () . name ("version") . type_name ("u32") . docs (& ["Version of the instruction weights." , "" , "# Note" , "" , "Should be incremented whenever any instruction weight is changed. The" , "reason is that changes to instruction weights require a re-instrumentation" , "in order to apply the changes to an already deployed code. The re-instrumentation" , "is triggered by comparing the version of the current schedule with the version the code was" , "instrumented with. Changes usually happen when pallet_contracts is re-benchmarked." , "" , "Changes to other parts of the schedule should not increment the version in" , "order to avoid unnecessary re-instrumentations."])) . field (| f | f . ty :: < u32 > () . name ("fallback") . type_name ("u32") . docs (& ["Weight to be used for instructions which don't have benchmarks assigned." , "" , "This weight is used whenever a code is uploaded with [`Determinism::Relaxed`]" , "and an instruction (usually a float instruction) is encountered. This weight is **not**" , "used if a contract is uploaded with [`Determinism::Enforced`]. If this field is set to" , "`0` (the default) only deterministic codes are allowed to be uploaded."])) . field (| f | f . ty :: < u32 > () . name ("i64const") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64load") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64store") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("select") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("r#if") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("br") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("br_if") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("br_table") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("br_table_per_entry") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("call") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("call_indirect") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("call_per_local") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("local_get") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("local_set") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("local_tee") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("global_get") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("global_set") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("memory_current") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("memory_grow") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64clz") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64ctz") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64popcnt") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64eqz") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64extendsi32") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64extendui32") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i32wrapi64") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64eq") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64ne") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64lts") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64ltu") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64gts") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64gtu") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64les") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64leu") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64ges") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64geu") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64add") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64sub") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64mul") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64divs") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64divu") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64rems") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64remu") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64and") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64or") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64xor") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64shl") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64shrs") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64shru") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64rotl") . type_name ("u32")) . field (| f | f . ty :: < u32 > () . name ("i64rotr") . type_name ("u32")))
            }
        };
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<T: Config> _serde::Serialize for InstructionWeights<T> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "InstructionWeights",
                    false as usize
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fallback",
                    &self.fallback,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64const",
                    &self.i64const,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64load",
                    &self.i64load,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64store",
                    &self.i64store,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "select",
                    &self.select,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "if",
                    &self.r#if,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "br",
                    &self.br,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "br_if",
                    &self.br_if,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "br_table",
                    &self.br_table,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "br_table_per_entry",
                    &self.br_table_per_entry,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "call",
                    &self.call,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "call_indirect",
                    &self.call_indirect,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "call_per_local",
                    &self.call_per_local,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "local_get",
                    &self.local_get,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "local_set",
                    &self.local_set,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "local_tee",
                    &self.local_tee,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "global_get",
                    &self.global_get,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "global_set",
                    &self.global_set,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memory_current",
                    &self.memory_current,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memory_grow",
                    &self.memory_grow,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64clz",
                    &self.i64clz,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64ctz",
                    &self.i64ctz,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64popcnt",
                    &self.i64popcnt,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64eqz",
                    &self.i64eqz,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64extendsi32",
                    &self.i64extendsi32,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64extendui32",
                    &self.i64extendui32,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i32wrapi64",
                    &self.i32wrapi64,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64eq",
                    &self.i64eq,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64ne",
                    &self.i64ne,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64lts",
                    &self.i64lts,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64ltu",
                    &self.i64ltu,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64gts",
                    &self.i64gts,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64gtu",
                    &self.i64gtu,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64les",
                    &self.i64les,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64leu",
                    &self.i64leu,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64ges",
                    &self.i64ges,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64geu",
                    &self.i64geu,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64add",
                    &self.i64add,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64sub",
                    &self.i64sub,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64mul",
                    &self.i64mul,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64divs",
                    &self.i64divs,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64divu",
                    &self.i64divu,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64rems",
                    &self.i64rems,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64remu",
                    &self.i64remu,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64and",
                    &self.i64and,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64or",
                    &self.i64or,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64xor",
                    &self.i64xor,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64shl",
                    &self.i64shl,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64shrs",
                    &self.i64shrs,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64shru",
                    &self.i64shru,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64rotl",
                    &self.i64rotl,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "i64rotr",
                    &self.i64rotr,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "_phantom",
                    &self._phantom,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, T: Config> _serde::Deserialize<'de> for InstructionWeights<T> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                    __field26,
                    __field27,
                    __field28,
                    __field29,
                    __field30,
                    __field31,
                    __field32,
                    __field33,
                    __field34,
                    __field35,
                    __field36,
                    __field37,
                    __field38,
                    __field39,
                    __field40,
                    __field41,
                    __field42,
                    __field43,
                    __field44,
                    __field45,
                    __field46,
                    __field47,
                    __field48,
                    __field49,
                    __field50,
                    __field51,
                    __field52,
                    __field53,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            21u64 => _serde::__private::Ok(__Field::__field21),
                            22u64 => _serde::__private::Ok(__Field::__field22),
                            23u64 => _serde::__private::Ok(__Field::__field23),
                            24u64 => _serde::__private::Ok(__Field::__field24),
                            25u64 => _serde::__private::Ok(__Field::__field25),
                            26u64 => _serde::__private::Ok(__Field::__field26),
                            27u64 => _serde::__private::Ok(__Field::__field27),
                            28u64 => _serde::__private::Ok(__Field::__field28),
                            29u64 => _serde::__private::Ok(__Field::__field29),
                            30u64 => _serde::__private::Ok(__Field::__field30),
                            31u64 => _serde::__private::Ok(__Field::__field31),
                            32u64 => _serde::__private::Ok(__Field::__field32),
                            33u64 => _serde::__private::Ok(__Field::__field33),
                            34u64 => _serde::__private::Ok(__Field::__field34),
                            35u64 => _serde::__private::Ok(__Field::__field35),
                            36u64 => _serde::__private::Ok(__Field::__field36),
                            37u64 => _serde::__private::Ok(__Field::__field37),
                            38u64 => _serde::__private::Ok(__Field::__field38),
                            39u64 => _serde::__private::Ok(__Field::__field39),
                            40u64 => _serde::__private::Ok(__Field::__field40),
                            41u64 => _serde::__private::Ok(__Field::__field41),
                            42u64 => _serde::__private::Ok(__Field::__field42),
                            43u64 => _serde::__private::Ok(__Field::__field43),
                            44u64 => _serde::__private::Ok(__Field::__field44),
                            45u64 => _serde::__private::Ok(__Field::__field45),
                            46u64 => _serde::__private::Ok(__Field::__field46),
                            47u64 => _serde::__private::Ok(__Field::__field47),
                            48u64 => _serde::__private::Ok(__Field::__field48),
                            49u64 => _serde::__private::Ok(__Field::__field49),
                            50u64 => _serde::__private::Ok(__Field::__field50),
                            51u64 => _serde::__private::Ok(__Field::__field51),
                            52u64 => _serde::__private::Ok(__Field::__field52),
                            53u64 => _serde::__private::Ok(__Field::__field53),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "version" => _serde::__private::Ok(__Field::__field0),
                            "fallback" => _serde::__private::Ok(__Field::__field1),
                            "i64const" => _serde::__private::Ok(__Field::__field2),
                            "i64load" => _serde::__private::Ok(__Field::__field3),
                            "i64store" => _serde::__private::Ok(__Field::__field4),
                            "select" => _serde::__private::Ok(__Field::__field5),
                            "if" => _serde::__private::Ok(__Field::__field6),
                            "br" => _serde::__private::Ok(__Field::__field7),
                            "br_if" => _serde::__private::Ok(__Field::__field8),
                            "br_table" => _serde::__private::Ok(__Field::__field9),
                            "br_table_per_entry" => _serde::__private::Ok(__Field::__field10),
                            "call" => _serde::__private::Ok(__Field::__field11),
                            "call_indirect" => _serde::__private::Ok(__Field::__field12),
                            "call_per_local" => _serde::__private::Ok(__Field::__field13),
                            "local_get" => _serde::__private::Ok(__Field::__field14),
                            "local_set" => _serde::__private::Ok(__Field::__field15),
                            "local_tee" => _serde::__private::Ok(__Field::__field16),
                            "global_get" => _serde::__private::Ok(__Field::__field17),
                            "global_set" => _serde::__private::Ok(__Field::__field18),
                            "memory_current" => _serde::__private::Ok(__Field::__field19),
                            "memory_grow" => _serde::__private::Ok(__Field::__field20),
                            "i64clz" => _serde::__private::Ok(__Field::__field21),
                            "i64ctz" => _serde::__private::Ok(__Field::__field22),
                            "i64popcnt" => _serde::__private::Ok(__Field::__field23),
                            "i64eqz" => _serde::__private::Ok(__Field::__field24),
                            "i64extendsi32" => _serde::__private::Ok(__Field::__field25),
                            "i64extendui32" => _serde::__private::Ok(__Field::__field26),
                            "i32wrapi64" => _serde::__private::Ok(__Field::__field27),
                            "i64eq" => _serde::__private::Ok(__Field::__field28),
                            "i64ne" => _serde::__private::Ok(__Field::__field29),
                            "i64lts" => _serde::__private::Ok(__Field::__field30),
                            "i64ltu" => _serde::__private::Ok(__Field::__field31),
                            "i64gts" => _serde::__private::Ok(__Field::__field32),
                            "i64gtu" => _serde::__private::Ok(__Field::__field33),
                            "i64les" => _serde::__private::Ok(__Field::__field34),
                            "i64leu" => _serde::__private::Ok(__Field::__field35),
                            "i64ges" => _serde::__private::Ok(__Field::__field36),
                            "i64geu" => _serde::__private::Ok(__Field::__field37),
                            "i64add" => _serde::__private::Ok(__Field::__field38),
                            "i64sub" => _serde::__private::Ok(__Field::__field39),
                            "i64mul" => _serde::__private::Ok(__Field::__field40),
                            "i64divs" => _serde::__private::Ok(__Field::__field41),
                            "i64divu" => _serde::__private::Ok(__Field::__field42),
                            "i64rems" => _serde::__private::Ok(__Field::__field43),
                            "i64remu" => _serde::__private::Ok(__Field::__field44),
                            "i64and" => _serde::__private::Ok(__Field::__field45),
                            "i64or" => _serde::__private::Ok(__Field::__field46),
                            "i64xor" => _serde::__private::Ok(__Field::__field47),
                            "i64shl" => _serde::__private::Ok(__Field::__field48),
                            "i64shrs" => _serde::__private::Ok(__Field::__field49),
                            "i64shru" => _serde::__private::Ok(__Field::__field50),
                            "i64rotl" => _serde::__private::Ok(__Field::__field51),
                            "i64rotr" => _serde::__private::Ok(__Field::__field52),
                            "_phantom" => _serde::__private::Ok(__Field::__field53),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"version" => _serde::__private::Ok(__Field::__field0),
                            b"fallback" => _serde::__private::Ok(__Field::__field1),
                            b"i64const" => _serde::__private::Ok(__Field::__field2),
                            b"i64load" => _serde::__private::Ok(__Field::__field3),
                            b"i64store" => _serde::__private::Ok(__Field::__field4),
                            b"select" => _serde::__private::Ok(__Field::__field5),
                            b"if" => _serde::__private::Ok(__Field::__field6),
                            b"br" => _serde::__private::Ok(__Field::__field7),
                            b"br_if" => _serde::__private::Ok(__Field::__field8),
                            b"br_table" => _serde::__private::Ok(__Field::__field9),
                            b"br_table_per_entry" => _serde::__private::Ok(__Field::__field10),
                            b"call" => _serde::__private::Ok(__Field::__field11),
                            b"call_indirect" => _serde::__private::Ok(__Field::__field12),
                            b"call_per_local" => _serde::__private::Ok(__Field::__field13),
                            b"local_get" => _serde::__private::Ok(__Field::__field14),
                            b"local_set" => _serde::__private::Ok(__Field::__field15),
                            b"local_tee" => _serde::__private::Ok(__Field::__field16),
                            b"global_get" => _serde::__private::Ok(__Field::__field17),
                            b"global_set" => _serde::__private::Ok(__Field::__field18),
                            b"memory_current" => _serde::__private::Ok(__Field::__field19),
                            b"memory_grow" => _serde::__private::Ok(__Field::__field20),
                            b"i64clz" => _serde::__private::Ok(__Field::__field21),
                            b"i64ctz" => _serde::__private::Ok(__Field::__field22),
                            b"i64popcnt" => _serde::__private::Ok(__Field::__field23),
                            b"i64eqz" => _serde::__private::Ok(__Field::__field24),
                            b"i64extendsi32" => _serde::__private::Ok(__Field::__field25),
                            b"i64extendui32" => _serde::__private::Ok(__Field::__field26),
                            b"i32wrapi64" => _serde::__private::Ok(__Field::__field27),
                            b"i64eq" => _serde::__private::Ok(__Field::__field28),
                            b"i64ne" => _serde::__private::Ok(__Field::__field29),
                            b"i64lts" => _serde::__private::Ok(__Field::__field30),
                            b"i64ltu" => _serde::__private::Ok(__Field::__field31),
                            b"i64gts" => _serde::__private::Ok(__Field::__field32),
                            b"i64gtu" => _serde::__private::Ok(__Field::__field33),
                            b"i64les" => _serde::__private::Ok(__Field::__field34),
                            b"i64leu" => _serde::__private::Ok(__Field::__field35),
                            b"i64ges" => _serde::__private::Ok(__Field::__field36),
                            b"i64geu" => _serde::__private::Ok(__Field::__field37),
                            b"i64add" => _serde::__private::Ok(__Field::__field38),
                            b"i64sub" => _serde::__private::Ok(__Field::__field39),
                            b"i64mul" => _serde::__private::Ok(__Field::__field40),
                            b"i64divs" => _serde::__private::Ok(__Field::__field41),
                            b"i64divu" => _serde::__private::Ok(__Field::__field42),
                            b"i64rems" => _serde::__private::Ok(__Field::__field43),
                            b"i64remu" => _serde::__private::Ok(__Field::__field44),
                            b"i64and" => _serde::__private::Ok(__Field::__field45),
                            b"i64or" => _serde::__private::Ok(__Field::__field46),
                            b"i64xor" => _serde::__private::Ok(__Field::__field47),
                            b"i64shl" => _serde::__private::Ok(__Field::__field48),
                            b"i64shrs" => _serde::__private::Ok(__Field::__field49),
                            b"i64shru" => _serde::__private::Ok(__Field::__field50),
                            b"i64rotl" => _serde::__private::Ok(__Field::__field51),
                            b"i64rotr" => _serde::__private::Ok(__Field::__field52),
                            b"_phantom" => _serde::__private::Ok(__Field::__field53),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de, T: Config> {
                    marker: _serde::__private::PhantomData<InstructionWeights<T>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, T: Config> _serde::de::Visitor<'de> for __Visitor<'de, T> {
                    type Value = InstructionWeights<T>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct InstructionWeights",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field4 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field5 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field6 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field7 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field8 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field9 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field10 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field11 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field12 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field13 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            13usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field14 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            14usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field15 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            15usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field16 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            16usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field17 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            17usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field18 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            18usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field19 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            19usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field20 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            20usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field21 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            21usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field22 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            22usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field23 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            23usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field24 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            24usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field25 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            25usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field26 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            26usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field27 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            27usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field28 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            28usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field29 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            29usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field30 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            30usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field31 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            31usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field32 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            32usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field33 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            33usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field34 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            34usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field35 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            35usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field36 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            36usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field37 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            37usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field38 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            38usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field39 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            39usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field40 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            40usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field41 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            41usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field42 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            42usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field43 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            43usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field44 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            44usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field45 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            45usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field46 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            46usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field47 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            47usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field48 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            48usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field49 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            49usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field50 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            50usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field51 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            51usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field52 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            52usize,
                                            &"struct InstructionWeights with 54 elements",
                                        ),
                                    );
                                }
                            };
                        let __field53 = match match _serde::de::SeqAccess::next_element::<
                            PhantomData<T>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    53usize,
                                    &"struct InstructionWeights with 54 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(InstructionWeights {
                            version: __field0,
                            fallback: __field1,
                            i64const: __field2,
                            i64load: __field3,
                            i64store: __field4,
                            select: __field5,
                            r#if: __field6,
                            br: __field7,
                            br_if: __field8,
                            br_table: __field9,
                            br_table_per_entry: __field10,
                            call: __field11,
                            call_indirect: __field12,
                            call_per_local: __field13,
                            local_get: __field14,
                            local_set: __field15,
                            local_tee: __field16,
                            global_get: __field17,
                            global_set: __field18,
                            memory_current: __field19,
                            memory_grow: __field20,
                            i64clz: __field21,
                            i64ctz: __field22,
                            i64popcnt: __field23,
                            i64eqz: __field24,
                            i64extendsi32: __field25,
                            i64extendui32: __field26,
                            i32wrapi64: __field27,
                            i64eq: __field28,
                            i64ne: __field29,
                            i64lts: __field30,
                            i64ltu: __field31,
                            i64gts: __field32,
                            i64gtu: __field33,
                            i64les: __field34,
                            i64leu: __field35,
                            i64ges: __field36,
                            i64geu: __field37,
                            i64add: __field38,
                            i64sub: __field39,
                            i64mul: __field40,
                            i64divs: __field41,
                            i64divu: __field42,
                            i64rems: __field43,
                            i64remu: __field44,
                            i64and: __field45,
                            i64or: __field46,
                            i64xor: __field47,
                            i64shl: __field48,
                            i64shrs: __field49,
                            i64shru: __field50,
                            i64rotl: __field51,
                            i64rotr: __field52,
                            _phantom: __field53,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field17: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field18: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field19: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field20: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field21: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field22: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field23: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field24: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field25: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field26: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field27: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field28: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field29: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field30: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field31: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field32: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field33: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field34: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field35: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field36: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field37: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field38: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field39: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field40: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field41: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field42: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field43: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field44: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field45: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field46: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field47: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field48: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field49: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field50: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field51: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field52: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field53: _serde::__private::Option<PhantomData<T>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fallback",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64const",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64load",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64store",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "select",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "if",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "br",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "br_if",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "br_table",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "br_table_per_entry",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "call",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "call_indirect",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "call_per_local",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "local_get",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "local_set",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "local_tee",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "global_get",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "global_set",
                                            ),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "memory_current",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field20 => {
                                    if _serde::__private::Option::is_some(&__field20) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "memory_grow",
                                            ),
                                        );
                                    }
                                    __field20 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field21 => {
                                    if _serde::__private::Option::is_some(&__field21) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64clz",
                                            ),
                                        );
                                    }
                                    __field21 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field22 => {
                                    if _serde::__private::Option::is_some(&__field22) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64ctz",
                                            ),
                                        );
                                    }
                                    __field22 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field23 => {
                                    if _serde::__private::Option::is_some(&__field23) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64popcnt",
                                            ),
                                        );
                                    }
                                    __field23 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field24 => {
                                    if _serde::__private::Option::is_some(&__field24) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64eqz",
                                            ),
                                        );
                                    }
                                    __field24 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field25 => {
                                    if _serde::__private::Option::is_some(&__field25) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64extendsi32",
                                            ),
                                        );
                                    }
                                    __field25 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field26 => {
                                    if _serde::__private::Option::is_some(&__field26) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64extendui32",
                                            ),
                                        );
                                    }
                                    __field26 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field27 => {
                                    if _serde::__private::Option::is_some(&__field27) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i32wrapi64",
                                            ),
                                        );
                                    }
                                    __field27 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field28 => {
                                    if _serde::__private::Option::is_some(&__field28) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64eq",
                                            ),
                                        );
                                    }
                                    __field28 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field29 => {
                                    if _serde::__private::Option::is_some(&__field29) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64ne",
                                            ),
                                        );
                                    }
                                    __field29 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field30 => {
                                    if _serde::__private::Option::is_some(&__field30) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64lts",
                                            ),
                                        );
                                    }
                                    __field30 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field31 => {
                                    if _serde::__private::Option::is_some(&__field31) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64ltu",
                                            ),
                                        );
                                    }
                                    __field31 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field32 => {
                                    if _serde::__private::Option::is_some(&__field32) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64gts",
                                            ),
                                        );
                                    }
                                    __field32 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field33 => {
                                    if _serde::__private::Option::is_some(&__field33) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64gtu",
                                            ),
                                        );
                                    }
                                    __field33 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field34 => {
                                    if _serde::__private::Option::is_some(&__field34) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64les",
                                            ),
                                        );
                                    }
                                    __field34 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field35 => {
                                    if _serde::__private::Option::is_some(&__field35) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64leu",
                                            ),
                                        );
                                    }
                                    __field35 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field36 => {
                                    if _serde::__private::Option::is_some(&__field36) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64ges",
                                            ),
                                        );
                                    }
                                    __field36 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field37 => {
                                    if _serde::__private::Option::is_some(&__field37) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64geu",
                                            ),
                                        );
                                    }
                                    __field37 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field38 => {
                                    if _serde::__private::Option::is_some(&__field38) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64add",
                                            ),
                                        );
                                    }
                                    __field38 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field39 => {
                                    if _serde::__private::Option::is_some(&__field39) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64sub",
                                            ),
                                        );
                                    }
                                    __field39 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field40 => {
                                    if _serde::__private::Option::is_some(&__field40) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64mul",
                                            ),
                                        );
                                    }
                                    __field40 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field41 => {
                                    if _serde::__private::Option::is_some(&__field41) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64divs",
                                            ),
                                        );
                                    }
                                    __field41 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field42 => {
                                    if _serde::__private::Option::is_some(&__field42) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64divu",
                                            ),
                                        );
                                    }
                                    __field42 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field43 => {
                                    if _serde::__private::Option::is_some(&__field43) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64rems",
                                            ),
                                        );
                                    }
                                    __field43 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field44 => {
                                    if _serde::__private::Option::is_some(&__field44) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64remu",
                                            ),
                                        );
                                    }
                                    __field44 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field45 => {
                                    if _serde::__private::Option::is_some(&__field45) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64and",
                                            ),
                                        );
                                    }
                                    __field45 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field46 => {
                                    if _serde::__private::Option::is_some(&__field46) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64or",
                                            ),
                                        );
                                    }
                                    __field46 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field47 => {
                                    if _serde::__private::Option::is_some(&__field47) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64xor",
                                            ),
                                        );
                                    }
                                    __field47 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field48 => {
                                    if _serde::__private::Option::is_some(&__field48) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64shl",
                                            ),
                                        );
                                    }
                                    __field48 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field49 => {
                                    if _serde::__private::Option::is_some(&__field49) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64shrs",
                                            ),
                                        );
                                    }
                                    __field49 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field50 => {
                                    if _serde::__private::Option::is_some(&__field50) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64shru",
                                            ),
                                        );
                                    }
                                    __field50 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field51 => {
                                    if _serde::__private::Option::is_some(&__field51) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64rotl",
                                            ),
                                        );
                                    }
                                    __field51 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field52 => {
                                    if _serde::__private::Option::is_some(&__field52) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "i64rotr",
                                            ),
                                        );
                                    }
                                    __field52 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field53 => {
                                    if _serde::__private::Option::is_some(&__field53) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "_phantom",
                                            ),
                                        );
                                    }
                                    __field53 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<PhantomData<T>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("version") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("fallback") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64const") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64load") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64store") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("select") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("if") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("br") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("br_if") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("br_table") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("br_table_per_entry") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("call") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("call_indirect") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("call_per_local") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("local_get") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("local_set") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("local_tee") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("global_get") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("global_set") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("memory_current") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field20 = match __field20 {
                            _serde::__private::Some(__field20) => __field20,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("memory_grow") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field21 = match __field21 {
                            _serde::__private::Some(__field21) => __field21,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64clz") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field22 = match __field22 {
                            _serde::__private::Some(__field22) => __field22,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64ctz") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field23 = match __field23 {
                            _serde::__private::Some(__field23) => __field23,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64popcnt") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field24 = match __field24 {
                            _serde::__private::Some(__field24) => __field24,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64eqz") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field25 = match __field25 {
                            _serde::__private::Some(__field25) => __field25,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64extendsi32") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field26 = match __field26 {
                            _serde::__private::Some(__field26) => __field26,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64extendui32") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field27 = match __field27 {
                            _serde::__private::Some(__field27) => __field27,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i32wrapi64") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field28 = match __field28 {
                            _serde::__private::Some(__field28) => __field28,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64eq") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field29 = match __field29 {
                            _serde::__private::Some(__field29) => __field29,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64ne") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field30 = match __field30 {
                            _serde::__private::Some(__field30) => __field30,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64lts") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field31 = match __field31 {
                            _serde::__private::Some(__field31) => __field31,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64ltu") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field32 = match __field32 {
                            _serde::__private::Some(__field32) => __field32,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64gts") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field33 = match __field33 {
                            _serde::__private::Some(__field33) => __field33,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64gtu") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field34 = match __field34 {
                            _serde::__private::Some(__field34) => __field34,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64les") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field35 = match __field35 {
                            _serde::__private::Some(__field35) => __field35,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64leu") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field36 = match __field36 {
                            _serde::__private::Some(__field36) => __field36,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64ges") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field37 = match __field37 {
                            _serde::__private::Some(__field37) => __field37,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64geu") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field38 = match __field38 {
                            _serde::__private::Some(__field38) => __field38,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64add") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field39 = match __field39 {
                            _serde::__private::Some(__field39) => __field39,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64sub") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field40 = match __field40 {
                            _serde::__private::Some(__field40) => __field40,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64mul") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field41 = match __field41 {
                            _serde::__private::Some(__field41) => __field41,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64divs") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field42 = match __field42 {
                            _serde::__private::Some(__field42) => __field42,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64divu") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field43 = match __field43 {
                            _serde::__private::Some(__field43) => __field43,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64rems") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field44 = match __field44 {
                            _serde::__private::Some(__field44) => __field44,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64remu") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field45 = match __field45 {
                            _serde::__private::Some(__field45) => __field45,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64and") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field46 = match __field46 {
                            _serde::__private::Some(__field46) => __field46,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64or") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field47 = match __field47 {
                            _serde::__private::Some(__field47) => __field47,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64xor") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field48 = match __field48 {
                            _serde::__private::Some(__field48) => __field48,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64shl") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field49 = match __field49 {
                            _serde::__private::Some(__field49) => __field49,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64shrs") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field50 = match __field50 {
                            _serde::__private::Some(__field50) => __field50,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64shru") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field51 = match __field51 {
                            _serde::__private::Some(__field51) => __field51,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64rotl") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field52 = match __field52 {
                            _serde::__private::Some(__field52) => __field52,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("i64rotr") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field53 = match __field53 {
                            _serde::__private::Some(__field53) => __field53,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("_phantom") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(InstructionWeights {
                            version: __field0,
                            fallback: __field1,
                            i64const: __field2,
                            i64load: __field3,
                            i64store: __field4,
                            select: __field5,
                            r#if: __field6,
                            br: __field7,
                            br_if: __field8,
                            br_table: __field9,
                            br_table_per_entry: __field10,
                            call: __field11,
                            call_indirect: __field12,
                            call_per_local: __field13,
                            local_get: __field14,
                            local_set: __field15,
                            local_tee: __field16,
                            global_get: __field17,
                            global_set: __field18,
                            memory_current: __field19,
                            memory_grow: __field20,
                            i64clz: __field21,
                            i64ctz: __field22,
                            i64popcnt: __field23,
                            i64eqz: __field24,
                            i64extendsi32: __field25,
                            i64extendui32: __field26,
                            i32wrapi64: __field27,
                            i64eq: __field28,
                            i64ne: __field29,
                            i64lts: __field30,
                            i64ltu: __field31,
                            i64gts: __field32,
                            i64gtu: __field33,
                            i64les: __field34,
                            i64leu: __field35,
                            i64ges: __field36,
                            i64geu: __field37,
                            i64add: __field38,
                            i64sub: __field39,
                            i64mul: __field40,
                            i64divs: __field41,
                            i64divu: __field42,
                            i64rems: __field43,
                            i64remu: __field44,
                            i64and: __field45,
                            i64or: __field46,
                            i64xor: __field47,
                            i64shl: __field48,
                            i64shrs: __field49,
                            i64shru: __field50,
                            i64rotl: __field51,
                            i64rotr: __field52,
                            _phantom: __field53,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "version",
                    "fallback",
                    "i64const",
                    "i64load",
                    "i64store",
                    "select",
                    "if",
                    "br",
                    "br_if",
                    "br_table",
                    "br_table_per_entry",
                    "call",
                    "call_indirect",
                    "call_per_local",
                    "local_get",
                    "local_set",
                    "local_tee",
                    "global_get",
                    "global_set",
                    "memory_current",
                    "memory_grow",
                    "i64clz",
                    "i64ctz",
                    "i64popcnt",
                    "i64eqz",
                    "i64extendsi32",
                    "i64extendui32",
                    "i32wrapi64",
                    "i64eq",
                    "i64ne",
                    "i64lts",
                    "i64ltu",
                    "i64gts",
                    "i64gtu",
                    "i64les",
                    "i64leu",
                    "i64ges",
                    "i64geu",
                    "i64add",
                    "i64sub",
                    "i64mul",
                    "i64divs",
                    "i64divu",
                    "i64rems",
                    "i64remu",
                    "i64and",
                    "i64or",
                    "i64xor",
                    "i64shl",
                    "i64shrs",
                    "i64shru",
                    "i64rotl",
                    "i64rotr",
                    "_phantom",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "InstructionWeights",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InstructionWeights<T>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Describes the weight for each imported function that a contract is allowed to call.
    #[scale_info(skip_type_params(T))]
    pub struct HostFnWeights<T: Config> {
        /// Weight of calling `seal_caller`.
        pub caller: Weight,
        /// Weight of calling `seal_is_contract`.
        pub is_contract: Weight,
        /// Weight of calling `seal_code_hash`.
        pub code_hash: Weight,
        /// Weight of calling `seal_own_code_hash`.
        pub own_code_hash: Weight,
        /// Weight of calling `seal_caller_is_origin`.
        pub caller_is_origin: Weight,
        /// Weight of calling `seal_caller_is_root`.
        pub caller_is_root: Weight,
        /// Weight of calling `seal_address`.
        pub address: Weight,
        /// Weight of calling `seal_gas_left`.
        pub gas_left: Weight,
        /// Weight of calling `seal_balance`.
        pub balance: Weight,
        /// Weight of calling `seal_value_transferred`.
        pub value_transferred: Weight,
        /// Weight of calling `seal_minimum_balance`.
        pub minimum_balance: Weight,
        /// Weight of calling `seal_block_number`.
        pub block_number: Weight,
        /// Weight of calling `seal_now`.
        pub now: Weight,
        /// Weight of calling `seal_weight_to_fee`.
        pub weight_to_fee: Weight,
        /// Weight of calling `gas`.
        pub gas: Weight,
        /// Weight of calling `seal_input`.
        pub input: Weight,
        /// Weight per input byte copied to contract memory by `seal_input`.
        pub input_per_byte: Weight,
        /// Weight of calling `seal_return`.
        pub r#return: Weight,
        /// Weight per byte returned through `seal_return`.
        pub return_per_byte: Weight,
        /// Weight of calling `seal_terminate`.
        pub terminate: Weight,
        /// Weight of calling `seal_random`.
        pub random: Weight,
        /// Weight of calling `seal_reposit_event`.
        pub deposit_event: Weight,
        /// Weight per topic supplied to `seal_deposit_event`.
        pub deposit_event_per_topic: Weight,
        /// Weight per byte of an event deposited through `seal_deposit_event`.
        pub deposit_event_per_byte: Weight,
        /// Weight of calling `seal_debug_message`.
        pub debug_message: Weight,
        /// Weight of calling `seal_debug_message` per byte of the message.
        pub debug_message_per_byte: Weight,
        /// Weight of calling `seal_set_storage`.
        pub set_storage: Weight,
        /// Weight per written byten of an item stored with `seal_set_storage`.
        pub set_storage_per_new_byte: Weight,
        /// Weight per overwritten byte of an item stored with `seal_set_storage`.
        pub set_storage_per_old_byte: Weight,
        /// Weight of calling `seal_set_code_hash`.
        pub set_code_hash: Weight,
        /// Weight of calling `seal_clear_storage`.
        pub clear_storage: Weight,
        /// Weight of calling `seal_clear_storage` per byte of the stored item.
        pub clear_storage_per_byte: Weight,
        /// Weight of calling `seal_contains_storage`.
        pub contains_storage: Weight,
        /// Weight of calling `seal_contains_storage` per byte of the stored item.
        pub contains_storage_per_byte: Weight,
        /// Weight of calling `seal_get_storage`.
        pub get_storage: Weight,
        /// Weight per byte of an item received via `seal_get_storage`.
        pub get_storage_per_byte: Weight,
        /// Weight of calling `seal_take_storage`.
        pub take_storage: Weight,
        /// Weight per byte of an item received via `seal_take_storage`.
        pub take_storage_per_byte: Weight,
        /// Weight of calling `seal_transfer`.
        pub transfer: Weight,
        /// Weight of calling `seal_call`.
        pub call: Weight,
        /// Weight of calling `seal_delegate_call`.
        pub delegate_call: Weight,
        /// Weight surcharge that is claimed if `seal_call` does a balance transfer.
        pub call_transfer_surcharge: Weight,
        /// Weight per byte that is cloned by supplying the `CLONE_INPUT` flag.
        pub call_per_cloned_byte: Weight,
        /// Weight of calling `seal_instantiate`.
        pub instantiate: Weight,
        /// Weight surcharge that is claimed if `seal_instantiate` does a balance transfer.
        pub instantiate_transfer_surcharge: Weight,
        /// Weight per input byte supplied to `seal_instantiate`.
        pub instantiate_per_input_byte: Weight,
        /// Weight per salt byte supplied to `seal_instantiate`.
        pub instantiate_per_salt_byte: Weight,
        /// Weight of calling `seal_hash_sha_256`.
        pub hash_sha2_256: Weight,
        /// Weight per byte hashed by `seal_hash_sha_256`.
        pub hash_sha2_256_per_byte: Weight,
        /// Weight of calling `seal_hash_keccak_256`.
        pub hash_keccak_256: Weight,
        /// Weight per byte hashed by `seal_hash_keccak_256`.
        pub hash_keccak_256_per_byte: Weight,
        /// Weight of calling `seal_hash_blake2_256`.
        pub hash_blake2_256: Weight,
        /// Weight per byte hashed by `seal_hash_blake2_256`.
        pub hash_blake2_256_per_byte: Weight,
        /// Weight of calling `seal_hash_blake2_128`.
        pub hash_blake2_128: Weight,
        /// Weight per byte hashed by `seal_hash_blake2_128`.
        pub hash_blake2_128_per_byte: Weight,
        /// Weight of calling `seal_ecdsa_recover`.
        pub ecdsa_recover: Weight,
        /// Weight of calling `seal_ecdsa_to_eth_address`.
        pub ecdsa_to_eth_address: Weight,
        /// Weight of calling `sr25519_verify`.
        pub sr25519_verify: Weight,
        /// Weight per byte of calling `sr25519_verify`.
        pub sr25519_verify_per_byte: Weight,
        /// Weight of calling `reentrance_count`.
        pub reentrance_count: Weight,
        /// Weight of calling `account_reentrance_count`.
        pub account_reentrance_count: Weight,
        /// Weight of calling `instantiation_nonce`.
        pub instantiation_nonce: Weight,
        /// The type parameter is used in the default implementation.
        #[codec(skip)]
        pub _phantom: PhantomData<T>,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for HostFnWeights<T> {
        #[inline]
        fn clone(&self) -> HostFnWeights<T> {
            HostFnWeights {
                caller: ::core::clone::Clone::clone(&self.caller),
                is_contract: ::core::clone::Clone::clone(&self.is_contract),
                code_hash: ::core::clone::Clone::clone(&self.code_hash),
                own_code_hash: ::core::clone::Clone::clone(&self.own_code_hash),
                caller_is_origin: ::core::clone::Clone::clone(&self.caller_is_origin),
                caller_is_root: ::core::clone::Clone::clone(&self.caller_is_root),
                address: ::core::clone::Clone::clone(&self.address),
                gas_left: ::core::clone::Clone::clone(&self.gas_left),
                balance: ::core::clone::Clone::clone(&self.balance),
                value_transferred: ::core::clone::Clone::clone(&self.value_transferred),
                minimum_balance: ::core::clone::Clone::clone(&self.minimum_balance),
                block_number: ::core::clone::Clone::clone(&self.block_number),
                now: ::core::clone::Clone::clone(&self.now),
                weight_to_fee: ::core::clone::Clone::clone(&self.weight_to_fee),
                gas: ::core::clone::Clone::clone(&self.gas),
                input: ::core::clone::Clone::clone(&self.input),
                input_per_byte: ::core::clone::Clone::clone(&self.input_per_byte),
                r#return: ::core::clone::Clone::clone(&self.r#return),
                return_per_byte: ::core::clone::Clone::clone(&self.return_per_byte),
                terminate: ::core::clone::Clone::clone(&self.terminate),
                random: ::core::clone::Clone::clone(&self.random),
                deposit_event: ::core::clone::Clone::clone(&self.deposit_event),
                deposit_event_per_topic: ::core::clone::Clone::clone(&self.deposit_event_per_topic),
                deposit_event_per_byte: ::core::clone::Clone::clone(&self.deposit_event_per_byte),
                debug_message: ::core::clone::Clone::clone(&self.debug_message),
                debug_message_per_byte: ::core::clone::Clone::clone(&self.debug_message_per_byte),
                set_storage: ::core::clone::Clone::clone(&self.set_storage),
                set_storage_per_new_byte: ::core::clone::Clone::clone(
                    &self.set_storage_per_new_byte,
                ),
                set_storage_per_old_byte: ::core::clone::Clone::clone(
                    &self.set_storage_per_old_byte,
                ),
                set_code_hash: ::core::clone::Clone::clone(&self.set_code_hash),
                clear_storage: ::core::clone::Clone::clone(&self.clear_storage),
                clear_storage_per_byte: ::core::clone::Clone::clone(&self.clear_storage_per_byte),
                contains_storage: ::core::clone::Clone::clone(&self.contains_storage),
                contains_storage_per_byte: ::core::clone::Clone::clone(
                    &self.contains_storage_per_byte,
                ),
                get_storage: ::core::clone::Clone::clone(&self.get_storage),
                get_storage_per_byte: ::core::clone::Clone::clone(&self.get_storage_per_byte),
                take_storage: ::core::clone::Clone::clone(&self.take_storage),
                take_storage_per_byte: ::core::clone::Clone::clone(&self.take_storage_per_byte),
                transfer: ::core::clone::Clone::clone(&self.transfer),
                call: ::core::clone::Clone::clone(&self.call),
                delegate_call: ::core::clone::Clone::clone(&self.delegate_call),
                call_transfer_surcharge: ::core::clone::Clone::clone(&self.call_transfer_surcharge),
                call_per_cloned_byte: ::core::clone::Clone::clone(&self.call_per_cloned_byte),
                instantiate: ::core::clone::Clone::clone(&self.instantiate),
                instantiate_transfer_surcharge: ::core::clone::Clone::clone(
                    &self.instantiate_transfer_surcharge,
                ),
                instantiate_per_input_byte: ::core::clone::Clone::clone(
                    &self.instantiate_per_input_byte,
                ),
                instantiate_per_salt_byte: ::core::clone::Clone::clone(
                    &self.instantiate_per_salt_byte,
                ),
                hash_sha2_256: ::core::clone::Clone::clone(&self.hash_sha2_256),
                hash_sha2_256_per_byte: ::core::clone::Clone::clone(&self.hash_sha2_256_per_byte),
                hash_keccak_256: ::core::clone::Clone::clone(&self.hash_keccak_256),
                hash_keccak_256_per_byte: ::core::clone::Clone::clone(
                    &self.hash_keccak_256_per_byte,
                ),
                hash_blake2_256: ::core::clone::Clone::clone(&self.hash_blake2_256),
                hash_blake2_256_per_byte: ::core::clone::Clone::clone(
                    &self.hash_blake2_256_per_byte,
                ),
                hash_blake2_128: ::core::clone::Clone::clone(&self.hash_blake2_128),
                hash_blake2_128_per_byte: ::core::clone::Clone::clone(
                    &self.hash_blake2_128_per_byte,
                ),
                ecdsa_recover: ::core::clone::Clone::clone(&self.ecdsa_recover),
                ecdsa_to_eth_address: ::core::clone::Clone::clone(&self.ecdsa_to_eth_address),
                sr25519_verify: ::core::clone::Clone::clone(&self.sr25519_verify),
                sr25519_verify_per_byte: ::core::clone::Clone::clone(&self.sr25519_verify_per_byte),
                reentrance_count: ::core::clone::Clone::clone(&self.reentrance_count),
                account_reentrance_count: ::core::clone::Clone::clone(
                    &self.account_reentrance_count,
                ),
                instantiation_nonce: ::core::clone::Clone::clone(&self.instantiation_nonce),
                _phantom: ::core::clone::Clone::clone(&self._phantom),
            }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for HostFnWeights<T> {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.caller, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.is_contract, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.code_hash, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.own_code_hash, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.caller_is_origin, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.caller_is_root, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.address, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.gas_left, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.balance, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.value_transferred, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.minimum_balance, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.block_number, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.now, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.weight_to_fee, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.gas, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.input, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.input_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.r#return, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.return_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.terminate, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.random, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.deposit_event, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.deposit_event_per_topic, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.deposit_event_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.debug_message, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.debug_message_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.set_storage, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.set_storage_per_new_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.set_storage_per_old_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.set_code_hash, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.clear_storage, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.clear_storage_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.contains_storage, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.contains_storage_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.get_storage, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.get_storage_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.take_storage, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.take_storage_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.transfer, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.call, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.delegate_call, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.call_transfer_surcharge, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.call_per_cloned_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.instantiate, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.instantiate_transfer_surcharge, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.instantiate_per_input_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.instantiate_per_salt_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_sha2_256, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_sha2_256_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_keccak_256, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_keccak_256_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_blake2_256, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_blake2_256_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_blake2_128, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.hash_blake2_128_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.ecdsa_recover, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.ecdsa_to_eth_address, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.sr25519_verify, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.sr25519_verify_per_byte, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.reentrance_count, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.account_reentrance_count, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.instantiation_nonce, __codec_dest_edqy);
                let _ = &self._phantom;
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for HostFnWeights<T> {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for HostFnWeights<T>
        where
            PhantomData<T>: Default,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(HostFnWeights::<T> {
                    caller: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::caller`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    is_contract: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::is_contract`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    code_hash: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::code_hash`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    own_code_hash: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::own_code_hash`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    caller_is_origin: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::caller_is_origin`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    caller_is_root: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::caller_is_root`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    address: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::address`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    gas_left: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::gas_left`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    balance: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::balance`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    value_transferred: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::value_transferred`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    minimum_balance: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::minimum_balance`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    block_number: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::block_number`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    now: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::now`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    weight_to_fee: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::weight_to_fee`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    gas: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::gas`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    input: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::input`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    input_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::input_per_byte`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    r#return: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::r#return`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    return_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::return_per_byte`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    terminate: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::terminate`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    random: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::random`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    deposit_event: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::deposit_event`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    deposit_event_per_topic: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::deposit_event_per_topic`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    deposit_event_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::deposit_event_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    debug_message: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::debug_message`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    debug_message_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::debug_message_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    set_storage: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::set_storage`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    set_storage_per_new_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::set_storage_per_new_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    set_storage_per_old_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::set_storage_per_old_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    set_code_hash: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::set_code_hash`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    clear_storage: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::clear_storage`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    clear_storage_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::clear_storage_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    contains_storage: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::contains_storage`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    contains_storage_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::contains_storage_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    get_storage: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::get_storage`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    get_storage_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::get_storage_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    take_storage: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::take_storage`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    take_storage_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::take_storage_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    transfer: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::transfer`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    call: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::call`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    delegate_call: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::delegate_call`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    call_transfer_surcharge: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::call_transfer_surcharge`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    call_per_cloned_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::call_per_cloned_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    instantiate: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::instantiate`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    instantiate_transfer_surcharge: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `HostFnWeights::instantiate_transfer_surcharge`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                    },
                    instantiate_per_input_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::instantiate_per_input_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    instantiate_per_salt_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::instantiate_per_salt_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_sha2_256: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::hash_sha2_256`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_sha2_256_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::hash_sha2_256_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_keccak_256: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::hash_keccak_256`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_keccak_256_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::hash_keccak_256_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_blake2_256: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::hash_blake2_256`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_blake2_256_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::hash_blake2_256_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_blake2_128: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::hash_blake2_128`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    hash_blake2_128_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::hash_blake2_128_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    ecdsa_recover: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::ecdsa_recover`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    ecdsa_to_eth_address: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::ecdsa_to_eth_address`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    sr25519_verify: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::sr25519_verify`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    sr25519_verify_per_byte: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::sr25519_verify_per_byte`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    reentrance_count: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `HostFnWeights::reentrance_count`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    account_reentrance_count: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::account_reentrance_count`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    instantiation_nonce: {
                        let __codec_res_edqy =
                            <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `HostFnWeights::instantiation_nonce`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    _phantom: ::core::default::Default::default(),
                })
            }
        }
    };
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralPartialEq for HostFnWeights<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for HostFnWeights<T> {
        #[inline]
        fn eq(&self, other: &HostFnWeights<T>) -> bool {
            self.caller == other.caller
                && self.is_contract == other.is_contract
                && self.code_hash == other.code_hash
                && self.own_code_hash == other.own_code_hash
                && self.caller_is_origin == other.caller_is_origin
                && self.caller_is_root == other.caller_is_root
                && self.address == other.address
                && self.gas_left == other.gas_left
                && self.balance == other.balance
                && self.value_transferred == other.value_transferred
                && self.minimum_balance == other.minimum_balance
                && self.block_number == other.block_number
                && self.now == other.now
                && self.weight_to_fee == other.weight_to_fee
                && self.gas == other.gas
                && self.input == other.input
                && self.input_per_byte == other.input_per_byte
                && self.r#return == other.r#return
                && self.return_per_byte == other.return_per_byte
                && self.terminate == other.terminate
                && self.random == other.random
                && self.deposit_event == other.deposit_event
                && self.deposit_event_per_topic == other.deposit_event_per_topic
                && self.deposit_event_per_byte == other.deposit_event_per_byte
                && self.debug_message == other.debug_message
                && self.debug_message_per_byte == other.debug_message_per_byte
                && self.set_storage == other.set_storage
                && self.set_storage_per_new_byte == other.set_storage_per_new_byte
                && self.set_storage_per_old_byte == other.set_storage_per_old_byte
                && self.set_code_hash == other.set_code_hash
                && self.clear_storage == other.clear_storage
                && self.clear_storage_per_byte == other.clear_storage_per_byte
                && self.contains_storage == other.contains_storage
                && self.contains_storage_per_byte == other.contains_storage_per_byte
                && self.get_storage == other.get_storage
                && self.get_storage_per_byte == other.get_storage_per_byte
                && self.take_storage == other.take_storage
                && self.take_storage_per_byte == other.take_storage_per_byte
                && self.transfer == other.transfer
                && self.call == other.call
                && self.delegate_call == other.delegate_call
                && self.call_transfer_surcharge == other.call_transfer_surcharge
                && self.call_per_cloned_byte == other.call_per_cloned_byte
                && self.instantiate == other.instantiate
                && self.instantiate_transfer_surcharge == other.instantiate_transfer_surcharge
                && self.instantiate_per_input_byte == other.instantiate_per_input_byte
                && self.instantiate_per_salt_byte == other.instantiate_per_salt_byte
                && self.hash_sha2_256 == other.hash_sha2_256
                && self.hash_sha2_256_per_byte == other.hash_sha2_256_per_byte
                && self.hash_keccak_256 == other.hash_keccak_256
                && self.hash_keccak_256_per_byte == other.hash_keccak_256_per_byte
                && self.hash_blake2_256 == other.hash_blake2_256
                && self.hash_blake2_256_per_byte == other.hash_blake2_256_per_byte
                && self.hash_blake2_128 == other.hash_blake2_128
                && self.hash_blake2_128_per_byte == other.hash_blake2_128_per_byte
                && self.ecdsa_recover == other.ecdsa_recover
                && self.ecdsa_to_eth_address == other.ecdsa_to_eth_address
                && self.sr25519_verify == other.sr25519_verify
                && self.sr25519_verify_per_byte == other.sr25519_verify_per_byte
                && self.reentrance_count == other.reentrance_count
                && self.account_reentrance_count == other.account_reentrance_count
                && self.instantiation_nonce == other.instantiation_nonce
                && self._phantom == other._phantom
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralEq for HostFnWeights<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for HostFnWeights<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Weight>;
            let _: ::core::cmp::AssertParamIsEq<PhantomData<T>>;
        }
    }
    impl<T: Config> core::fmt::Debug for HostFnWeights<T> {
        fn fmt(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            use ::sp_runtime::{FixedPointNumber, FixedU128 as Fixed};
            let mut formatter = formatter.debug_struct("HostFnWeights");
            formatter.field(
                "caller",
                &if self.caller.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.caller.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.caller.proof_size()
                        ));
                        res
                    }
                } else if self.caller.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.caller.ref_time(), 1_000_000)
                                .to_float(),
                            self.caller.proof_size()
                        ));
                        res
                    }
                } else if self.caller.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.caller.ref_time(), 1_000)
                                .to_float(),
                            self.caller.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.caller.ref_time(),
                            self.caller.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "is_contract",
                &if self.is_contract.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.is_contract.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.is_contract.proof_size()
                        ));
                        res
                    }
                } else if self.is_contract.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.is_contract.ref_time(), 1_000_000)
                                .to_float(),
                            self.is_contract.proof_size()
                        ));
                        res
                    }
                } else if self.is_contract.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.is_contract.ref_time(), 1_000)
                                .to_float(),
                            self.is_contract.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.is_contract.ref_time(),
                            self.is_contract.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "code_hash",
                &if self.code_hash.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.code_hash.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.code_hash.proof_size()
                        ));
                        res
                    }
                } else if self.code_hash.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.code_hash.ref_time(), 1_000_000)
                                .to_float(),
                            self.code_hash.proof_size()
                        ));
                        res
                    }
                } else if self.code_hash.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.code_hash.ref_time(), 1_000)
                                .to_float(),
                            self.code_hash.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.code_hash.ref_time(),
                            self.code_hash.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "own_code_hash",
                &if self.own_code_hash.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.own_code_hash.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.own_code_hash.proof_size()
                        ));
                        res
                    }
                } else if self.own_code_hash.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.own_code_hash.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.own_code_hash.proof_size()
                        ));
                        res
                    }
                } else if self.own_code_hash.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.own_code_hash.ref_time(), 1_000)
                                .to_float(),
                            self.own_code_hash.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.own_code_hash.ref_time(),
                            self.own_code_hash.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "caller_is_origin",
                &if self.caller_is_origin.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.caller_is_origin.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.caller_is_origin.proof_size()
                        ));
                        res
                    }
                } else if self.caller_is_origin.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.caller_is_origin.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.caller_is_origin.proof_size()
                        ));
                        res
                    }
                } else if self.caller_is_origin.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.caller_is_origin.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.caller_is_origin.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.caller_is_origin.ref_time(),
                            self.caller_is_origin.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "caller_is_root",
                &if self.caller_is_root.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.caller_is_root.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.caller_is_root.proof_size()
                        ));
                        res
                    }
                } else if self.caller_is_root.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.caller_is_root.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.caller_is_root.proof_size()
                        ));
                        res
                    }
                } else if self.caller_is_root.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.caller_is_root.ref_time(), 1_000)
                                .to_float(),
                            self.caller_is_root.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.caller_is_root.ref_time(),
                            self.caller_is_root.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "address",
                &if self.address.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.address.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.address.proof_size()
                        ));
                        res
                    }
                } else if self.address.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.address.ref_time(), 1_000_000)
                                .to_float(),
                            self.address.proof_size()
                        ));
                        res
                    }
                } else if self.address.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.address.ref_time(), 1_000)
                                .to_float(),
                            self.address.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.address.ref_time(),
                            self.address.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "gas_left",
                &if self.gas_left.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.gas_left.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.gas_left.proof_size()
                        ));
                        res
                    }
                } else if self.gas_left.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.gas_left.ref_time(), 1_000_000)
                                .to_float(),
                            self.gas_left.proof_size()
                        ));
                        res
                    }
                } else if self.gas_left.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.gas_left.ref_time(), 1_000)
                                .to_float(),
                            self.gas_left.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.gas_left.ref_time(),
                            self.gas_left.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "balance",
                &if self.balance.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.balance.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.balance.proof_size()
                        ));
                        res
                    }
                } else if self.balance.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.balance.ref_time(), 1_000_000)
                                .to_float(),
                            self.balance.proof_size()
                        ));
                        res
                    }
                } else if self.balance.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.balance.ref_time(), 1_000)
                                .to_float(),
                            self.balance.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.balance.ref_time(),
                            self.balance.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "value_transferred",
                &if self.value_transferred.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.value_transferred.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.value_transferred.proof_size()
                        ));
                        res
                    }
                } else if self.value_transferred.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.value_transferred.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.value_transferred.proof_size()
                        ));
                        res
                    }
                } else if self.value_transferred.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.value_transferred.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.value_transferred.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.value_transferred.ref_time(),
                            self.value_transferred.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "minimum_balance",
                &if self.minimum_balance.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.minimum_balance.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.minimum_balance.proof_size()
                        ));
                        res
                    }
                } else if self.minimum_balance.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.minimum_balance.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.minimum_balance.proof_size()
                        ));
                        res
                    }
                } else if self.minimum_balance.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.minimum_balance.ref_time(), 1_000)
                                .to_float(),
                            self.minimum_balance.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.minimum_balance.ref_time(),
                            self.minimum_balance.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "block_number",
                &if self.block_number.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.block_number.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.block_number.proof_size()
                        ));
                        res
                    }
                } else if self.block_number.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.block_number.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.block_number.proof_size()
                        ));
                        res
                    }
                } else if self.block_number.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.block_number.ref_time(), 1_000)
                                .to_float(),
                            self.block_number.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.block_number.ref_time(),
                            self.block_number.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "now",
                &if self.now.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.now.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.now.proof_size()
                        ));
                        res
                    }
                } else if self.now.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.now.ref_time(), 1_000_000)
                                .to_float(),
                            self.now.proof_size()
                        ));
                        res
                    }
                } else if self.now.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.now.ref_time(), 1_000).to_float(),
                            self.now.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.now.ref_time(),
                            self.now.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "weight_to_fee",
                &if self.weight_to_fee.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.weight_to_fee.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.weight_to_fee.proof_size()
                        ));
                        res
                    }
                } else if self.weight_to_fee.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.weight_to_fee.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.weight_to_fee.proof_size()
                        ));
                        res
                    }
                } else if self.weight_to_fee.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.weight_to_fee.ref_time(), 1_000)
                                .to_float(),
                            self.weight_to_fee.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.weight_to_fee.ref_time(),
                            self.weight_to_fee.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "gas",
                &if self.gas.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.gas.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.gas.proof_size()
                        ));
                        res
                    }
                } else if self.gas.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.gas.ref_time(), 1_000_000)
                                .to_float(),
                            self.gas.proof_size()
                        ));
                        res
                    }
                } else if self.gas.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.gas.ref_time(), 1_000).to_float(),
                            self.gas.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.gas.ref_time(),
                            self.gas.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "input",
                &if self.input.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.input.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.input.proof_size()
                        ));
                        res
                    }
                } else if self.input.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.input.ref_time(), 1_000_000)
                                .to_float(),
                            self.input.proof_size()
                        ));
                        res
                    }
                } else if self.input.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.input.ref_time(), 1_000)
                                .to_float(),
                            self.input.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.input.ref_time(),
                            self.input.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "input_per_byte",
                &if self.input_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.input_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.input_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.input_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.input_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.input_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.input_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.input_per_byte.ref_time(), 1_000)
                                .to_float(),
                            self.input_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.input_per_byte.ref_time(),
                            self.input_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "r#return",
                &if self.r#return.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.r#return.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.r#return.proof_size()
                        ));
                        res
                    }
                } else if self.r#return.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.r#return.ref_time(), 1_000_000)
                                .to_float(),
                            self.r#return.proof_size()
                        ));
                        res
                    }
                } else if self.r#return.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.r#return.ref_time(), 1_000)
                                .to_float(),
                            self.r#return.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.r#return.ref_time(),
                            self.r#return.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "return_per_byte",
                &if self.return_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.return_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.return_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.return_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.return_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.return_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.return_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.return_per_byte.ref_time(), 1_000)
                                .to_float(),
                            self.return_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.return_per_byte.ref_time(),
                            self.return_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "terminate",
                &if self.terminate.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.terminate.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.terminate.proof_size()
                        ));
                        res
                    }
                } else if self.terminate.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.terminate.ref_time(), 1_000_000)
                                .to_float(),
                            self.terminate.proof_size()
                        ));
                        res
                    }
                } else if self.terminate.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.terminate.ref_time(), 1_000)
                                .to_float(),
                            self.terminate.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.terminate.ref_time(),
                            self.terminate.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "random",
                &if self.random.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.random.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.random.proof_size()
                        ));
                        res
                    }
                } else if self.random.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.random.ref_time(), 1_000_000)
                                .to_float(),
                            self.random.proof_size()
                        ));
                        res
                    }
                } else if self.random.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.random.ref_time(), 1_000)
                                .to_float(),
                            self.random.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.random.ref_time(),
                            self.random.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "deposit_event",
                &if self.deposit_event.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.deposit_event.proof_size()
                        ));
                        res
                    }
                } else if self.deposit_event.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.deposit_event.proof_size()
                        ));
                        res
                    }
                } else if self.deposit_event.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.deposit_event.ref_time(), 1_000)
                                .to_float(),
                            self.deposit_event.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.deposit_event.ref_time(),
                            self.deposit_event.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "deposit_event_per_topic",
                &if self.deposit_event_per_topic.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event_per_topic.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.deposit_event_per_topic.proof_size()
                        ));
                        res
                    }
                } else if self.deposit_event_per_topic.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event_per_topic.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.deposit_event_per_topic.proof_size()
                        ));
                        res
                    }
                } else if self.deposit_event_per_topic.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event_per_topic.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.deposit_event_per_topic.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.deposit_event_per_topic.ref_time(),
                            self.deposit_event_per_topic.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "deposit_event_per_byte",
                &if self.deposit_event_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.deposit_event_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.deposit_event_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.deposit_event_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.deposit_event_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.deposit_event_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.deposit_event_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.deposit_event_per_byte.ref_time(),
                            self.deposit_event_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "debug_message",
                &if self.debug_message.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.debug_message.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.debug_message.proof_size()
                        ));
                        res
                    }
                } else if self.debug_message.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.debug_message.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.debug_message.proof_size()
                        ));
                        res
                    }
                } else if self.debug_message.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.debug_message.ref_time(), 1_000)
                                .to_float(),
                            self.debug_message.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.debug_message.ref_time(),
                            self.debug_message.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "debug_message_per_byte",
                &if self.debug_message_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.debug_message_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.debug_message_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.debug_message_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.debug_message_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.debug_message_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.debug_message_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.debug_message_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.debug_message_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.debug_message_per_byte.ref_time(),
                            self.debug_message_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "set_storage",
                &if self.set_storage.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.set_storage.proof_size()
                        ));
                        res
                    }
                } else if self.set_storage.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.set_storage.ref_time(), 1_000_000)
                                .to_float(),
                            self.set_storage.proof_size()
                        ));
                        res
                    }
                } else if self.set_storage.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.set_storage.ref_time(), 1_000)
                                .to_float(),
                            self.set_storage.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.set_storage.ref_time(),
                            self.set_storage.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "set_storage_per_new_byte",
                &if self.set_storage_per_new_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage_per_new_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.set_storage_per_new_byte.proof_size()
                        ));
                        res
                    }
                } else if self.set_storage_per_new_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage_per_new_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.set_storage_per_new_byte.proof_size()
                        ));
                        res
                    }
                } else if self.set_storage_per_new_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage_per_new_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.set_storage_per_new_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.set_storage_per_new_byte.ref_time(),
                            self.set_storage_per_new_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "set_storage_per_old_byte",
                &if self.set_storage_per_old_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage_per_old_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.set_storage_per_old_byte.proof_size()
                        ));
                        res
                    }
                } else if self.set_storage_per_old_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage_per_old_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.set_storage_per_old_byte.proof_size()
                        ));
                        res
                    }
                } else if self.set_storage_per_old_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_storage_per_old_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.set_storage_per_old_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.set_storage_per_old_byte.ref_time(),
                            self.set_storage_per_old_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "set_code_hash",
                &if self.set_code_hash.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_code_hash.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.set_code_hash.proof_size()
                        ));
                        res
                    }
                } else if self.set_code_hash.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.set_code_hash.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.set_code_hash.proof_size()
                        ));
                        res
                    }
                } else if self.set_code_hash.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.set_code_hash.ref_time(), 1_000)
                                .to_float(),
                            self.set_code_hash.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.set_code_hash.ref_time(),
                            self.set_code_hash.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "clear_storage",
                &if self.clear_storage.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.clear_storage.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.clear_storage.proof_size()
                        ));
                        res
                    }
                } else if self.clear_storage.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.clear_storage.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.clear_storage.proof_size()
                        ));
                        res
                    }
                } else if self.clear_storage.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.clear_storage.ref_time(), 1_000)
                                .to_float(),
                            self.clear_storage.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.clear_storage.ref_time(),
                            self.clear_storage.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "clear_storage_per_byte",
                &if self.clear_storage_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.clear_storage_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.clear_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.clear_storage_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.clear_storage_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.clear_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.clear_storage_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.clear_storage_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.clear_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.clear_storage_per_byte.ref_time(),
                            self.clear_storage_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "contains_storage",
                &if self.contains_storage.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.contains_storage.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.contains_storage.proof_size()
                        ));
                        res
                    }
                } else if self.contains_storage.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.contains_storage.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.contains_storage.proof_size()
                        ));
                        res
                    }
                } else if self.contains_storage.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.contains_storage.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.contains_storage.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.contains_storage.ref_time(),
                            self.contains_storage.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "contains_storage_per_byte",
                &if self.contains_storage_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.contains_storage_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.contains_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.contains_storage_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.contains_storage_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.contains_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.contains_storage_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.contains_storage_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.contains_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.contains_storage_per_byte.ref_time(),
                            self.contains_storage_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "get_storage",
                &if self.get_storage.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.get_storage.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.get_storage.proof_size()
                        ));
                        res
                    }
                } else if self.get_storage.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.get_storage.ref_time(), 1_000_000)
                                .to_float(),
                            self.get_storage.proof_size()
                        ));
                        res
                    }
                } else if self.get_storage.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.get_storage.ref_time(), 1_000)
                                .to_float(),
                            self.get_storage.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.get_storage.ref_time(),
                            self.get_storage.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "get_storage_per_byte",
                &if self.get_storage_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.get_storage_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.get_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.get_storage_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.get_storage_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.get_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.get_storage_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.get_storage_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.get_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.get_storage_per_byte.ref_time(),
                            self.get_storage_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "take_storage",
                &if self.take_storage.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.take_storage.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.take_storage.proof_size()
                        ));
                        res
                    }
                } else if self.take_storage.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.take_storage.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.take_storage.proof_size()
                        ));
                        res
                    }
                } else if self.take_storage.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.take_storage.ref_time(), 1_000)
                                .to_float(),
                            self.take_storage.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.take_storage.ref_time(),
                            self.take_storage.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "take_storage_per_byte",
                &if self.take_storage_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.take_storage_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.take_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.take_storage_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.take_storage_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.take_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.take_storage_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.take_storage_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.take_storage_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.take_storage_per_byte.ref_time(),
                            self.take_storage_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "transfer",
                &if self.transfer.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.transfer.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.transfer.proof_size()
                        ));
                        res
                    }
                } else if self.transfer.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.transfer.ref_time(), 1_000_000)
                                .to_float(),
                            self.transfer.proof_size()
                        ));
                        res
                    }
                } else if self.transfer.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.transfer.ref_time(), 1_000)
                                .to_float(),
                            self.transfer.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.transfer.ref_time(),
                            self.transfer.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "call",
                &if self.call.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(self.call.ref_time(), 1_000_000_000)
                                .to_float(),
                            self.call.proof_size()
                        ));
                        res
                    }
                } else if self.call.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.call.ref_time(), 1_000_000)
                                .to_float(),
                            self.call.proof_size()
                        ));
                        res
                    }
                } else if self.call.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.call.ref_time(), 1_000).to_float(),
                            self.call.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.call.ref_time(),
                            self.call.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "delegate_call",
                &if self.delegate_call.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.delegate_call.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.delegate_call.proof_size()
                        ));
                        res
                    }
                } else if self.delegate_call.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.delegate_call.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.delegate_call.proof_size()
                        ));
                        res
                    }
                } else if self.delegate_call.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.delegate_call.ref_time(), 1_000)
                                .to_float(),
                            self.delegate_call.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.delegate_call.ref_time(),
                            self.delegate_call.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "call_transfer_surcharge",
                &if self.call_transfer_surcharge.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.call_transfer_surcharge.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.call_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                } else if self.call_transfer_surcharge.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.call_transfer_surcharge.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.call_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                } else if self.call_transfer_surcharge.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.call_transfer_surcharge.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.call_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.call_transfer_surcharge.ref_time(),
                            self.call_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "call_per_cloned_byte",
                &if self.call_per_cloned_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.call_per_cloned_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.call_per_cloned_byte.proof_size()
                        ));
                        res
                    }
                } else if self.call_per_cloned_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.call_per_cloned_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.call_per_cloned_byte.proof_size()
                        ));
                        res
                    }
                } else if self.call_per_cloned_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.call_per_cloned_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.call_per_cloned_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.call_per_cloned_byte.ref_time(),
                            self.call_per_cloned_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "instantiate",
                &if self.instantiate.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.instantiate.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(self.instantiate.ref_time(), 1_000_000)
                                .to_float(),
                            self.instantiate.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.instantiate.ref_time(), 1_000)
                                .to_float(),
                            self.instantiate.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.instantiate.ref_time(),
                            self.instantiate.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "instantiate_transfer_surcharge",
                &if self.instantiate_transfer_surcharge.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_transfer_surcharge.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.instantiate_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate_transfer_surcharge.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_transfer_surcharge.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.instantiate_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate_transfer_surcharge.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_transfer_surcharge.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.instantiate_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.instantiate_transfer_surcharge.ref_time(),
                            self.instantiate_transfer_surcharge.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "instantiate_per_input_byte",
                &if self.instantiate_per_input_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_per_input_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.instantiate_per_input_byte.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate_per_input_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_per_input_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.instantiate_per_input_byte.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate_per_input_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_per_input_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.instantiate_per_input_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.instantiate_per_input_byte.ref_time(),
                            self.instantiate_per_input_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "instantiate_per_salt_byte",
                &if self.instantiate_per_salt_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_per_salt_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.instantiate_per_salt_byte.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate_per_salt_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_per_salt_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.instantiate_per_salt_byte.proof_size()
                        ));
                        res
                    }
                } else if self.instantiate_per_salt_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiate_per_salt_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.instantiate_per_salt_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.instantiate_per_salt_byte.ref_time(),
                            self.instantiate_per_salt_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_sha2_256",
                &if self.hash_sha2_256.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_sha2_256.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_sha2_256.proof_size()
                        ));
                        res
                    }
                } else if self.hash_sha2_256.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_sha2_256.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_sha2_256.proof_size()
                        ));
                        res
                    }
                } else if self.hash_sha2_256.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.hash_sha2_256.ref_time(), 1_000)
                                .to_float(),
                            self.hash_sha2_256.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_sha2_256.ref_time(),
                            self.hash_sha2_256.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_sha2_256_per_byte",
                &if self.hash_sha2_256_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_sha2_256_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_sha2_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_sha2_256_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_sha2_256_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_sha2_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_sha2_256_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_sha2_256_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.hash_sha2_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_sha2_256_per_byte.ref_time(),
                            self.hash_sha2_256_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_keccak_256",
                &if self.hash_keccak_256.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_keccak_256.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_keccak_256.proof_size()
                        ));
                        res
                    }
                } else if self.hash_keccak_256.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_keccak_256.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_keccak_256.proof_size()
                        ));
                        res
                    }
                } else if self.hash_keccak_256.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.hash_keccak_256.ref_time(), 1_000)
                                .to_float(),
                            self.hash_keccak_256.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_keccak_256.ref_time(),
                            self.hash_keccak_256.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_keccak_256_per_byte",
                &if self.hash_keccak_256_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_keccak_256_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_keccak_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_keccak_256_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_keccak_256_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_keccak_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_keccak_256_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_keccak_256_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.hash_keccak_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_keccak_256_per_byte.ref_time(),
                            self.hash_keccak_256_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_blake2_256",
                &if self.hash_blake2_256.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_256.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_blake2_256.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_256.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_256.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_blake2_256.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_256.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.hash_blake2_256.ref_time(), 1_000)
                                .to_float(),
                            self.hash_blake2_256.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_blake2_256.ref_time(),
                            self.hash_blake2_256.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_blake2_256_per_byte",
                &if self.hash_blake2_256_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_256_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_blake2_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_256_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_256_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_blake2_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_256_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_256_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.hash_blake2_256_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_blake2_256_per_byte.ref_time(),
                            self.hash_blake2_256_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_blake2_128",
                &if self.hash_blake2_128.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_128.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_blake2_128.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_128.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_128.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_blake2_128.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_128.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.hash_blake2_128.ref_time(), 1_000)
                                .to_float(),
                            self.hash_blake2_128.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_blake2_128.ref_time(),
                            self.hash_blake2_128.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "hash_blake2_128_per_byte",
                &if self.hash_blake2_128_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_128_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.hash_blake2_128_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_128_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_128_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.hash_blake2_128_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.hash_blake2_128_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.hash_blake2_128_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.hash_blake2_128_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.hash_blake2_128_per_byte.ref_time(),
                            self.hash_blake2_128_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "ecdsa_recover",
                &if self.ecdsa_recover.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.ecdsa_recover.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.ecdsa_recover.proof_size()
                        ));
                        res
                    }
                } else if self.ecdsa_recover.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.ecdsa_recover.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.ecdsa_recover.proof_size()
                        ));
                        res
                    }
                } else if self.ecdsa_recover.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.ecdsa_recover.ref_time(), 1_000)
                                .to_float(),
                            self.ecdsa_recover.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.ecdsa_recover.ref_time(),
                            self.ecdsa_recover.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "ecdsa_to_eth_address",
                &if self.ecdsa_to_eth_address.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.ecdsa_to_eth_address.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.ecdsa_to_eth_address.proof_size()
                        ));
                        res
                    }
                } else if self.ecdsa_to_eth_address.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.ecdsa_to_eth_address.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.ecdsa_to_eth_address.proof_size()
                        ));
                        res
                    }
                } else if self.ecdsa_to_eth_address.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.ecdsa_to_eth_address.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.ecdsa_to_eth_address.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.ecdsa_to_eth_address.ref_time(),
                            self.ecdsa_to_eth_address.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "sr25519_verify",
                &if self.sr25519_verify.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.sr25519_verify.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.sr25519_verify.proof_size()
                        ));
                        res
                    }
                } else if self.sr25519_verify.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.sr25519_verify.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.sr25519_verify.proof_size()
                        ));
                        res
                    }
                } else if self.sr25519_verify.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(self.sr25519_verify.ref_time(), 1_000)
                                .to_float(),
                            self.sr25519_verify.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.sr25519_verify.ref_time(),
                            self.sr25519_verify.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "sr25519_verify_per_byte",
                &if self.sr25519_verify_per_byte.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.sr25519_verify_per_byte.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.sr25519_verify_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.sr25519_verify_per_byte.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.sr25519_verify_per_byte.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.sr25519_verify_per_byte.proof_size()
                        ));
                        res
                    }
                } else if self.sr25519_verify_per_byte.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.sr25519_verify_per_byte.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.sr25519_verify_per_byte.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.sr25519_verify_per_byte.ref_time(),
                            self.sr25519_verify_per_byte.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "reentrance_count",
                &if self.reentrance_count.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.reentrance_count.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.reentrance_count.proof_size()
                        ));
                        res
                    }
                } else if self.reentrance_count.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.reentrance_count.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.reentrance_count.proof_size()
                        ));
                        res
                    }
                } else if self.reentrance_count.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.reentrance_count.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.reentrance_count.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.reentrance_count.ref_time(),
                            self.reentrance_count.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "account_reentrance_count",
                &if self.account_reentrance_count.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.account_reentrance_count.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.account_reentrance_count.proof_size()
                        ));
                        res
                    }
                } else if self.account_reentrance_count.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.account_reentrance_count.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.account_reentrance_count.proof_size()
                        ));
                        res
                    }
                } else if self.account_reentrance_count.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.account_reentrance_count.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.account_reentrance_count.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.account_reentrance_count.ref_time(),
                            self.account_reentrance_count.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.field(
                "instantiation_nonce",
                &if self.instantiation_nonce.ref_time() > 1_000_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ms, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiation_nonce.ref_time(),
                                1_000_000_000
                            )
                            .to_float(),
                            self.instantiation_nonce.proof_size()
                        ));
                        res
                    }
                } else if self.instantiation_nonce.ref_time() > 1_000_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} µs, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiation_nonce.ref_time(),
                                1_000_000
                            )
                            .to_float(),
                            self.instantiation_nonce.proof_size()
                        ));
                        res
                    }
                } else if self.instantiation_nonce.ref_time() > 1_000 {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0:.1?} ns, {1} bytes",
                            Fixed::saturating_from_rational(
                                self.instantiation_nonce.ref_time(),
                                1_000
                            )
                            .to_float(),
                            self.instantiation_nonce.proof_size()
                        ));
                        res
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(format_args!(
                            "{0} ps, {1} bytes",
                            self.instantiation_nonce.ref_time(),
                            self.instantiation_nonce.proof_size()
                        ));
                        res
                    }
                },
            );
            formatter.finish()
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for HostFnWeights<T>
        where
            PhantomData<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("HostFnWeights" , "pallet_contracts::schedule")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["Describes the weight for each imported function that a contract is allowed to call."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < Weight > () . name ("caller") . type_name ("Weight") . docs (& ["Weight of calling `seal_caller`."])) . field (| f | f . ty :: < Weight > () . name ("is_contract") . type_name ("Weight") . docs (& ["Weight of calling `seal_is_contract`."])) . field (| f | f . ty :: < Weight > () . name ("code_hash") . type_name ("Weight") . docs (& ["Weight of calling `seal_code_hash`."])) . field (| f | f . ty :: < Weight > () . name ("own_code_hash") . type_name ("Weight") . docs (& ["Weight of calling `seal_own_code_hash`."])) . field (| f | f . ty :: < Weight > () . name ("caller_is_origin") . type_name ("Weight") . docs (& ["Weight of calling `seal_caller_is_origin`."])) . field (| f | f . ty :: < Weight > () . name ("caller_is_root") . type_name ("Weight") . docs (& ["Weight of calling `seal_caller_is_root`."])) . field (| f | f . ty :: < Weight > () . name ("address") . type_name ("Weight") . docs (& ["Weight of calling `seal_address`."])) . field (| f | f . ty :: < Weight > () . name ("gas_left") . type_name ("Weight") . docs (& ["Weight of calling `seal_gas_left`."])) . field (| f | f . ty :: < Weight > () . name ("balance") . type_name ("Weight") . docs (& ["Weight of calling `seal_balance`."])) . field (| f | f . ty :: < Weight > () . name ("value_transferred") . type_name ("Weight") . docs (& ["Weight of calling `seal_value_transferred`."])) . field (| f | f . ty :: < Weight > () . name ("minimum_balance") . type_name ("Weight") . docs (& ["Weight of calling `seal_minimum_balance`."])) . field (| f | f . ty :: < Weight > () . name ("block_number") . type_name ("Weight") . docs (& ["Weight of calling `seal_block_number`."])) . field (| f | f . ty :: < Weight > () . name ("now") . type_name ("Weight") . docs (& ["Weight of calling `seal_now`."])) . field (| f | f . ty :: < Weight > () . name ("weight_to_fee") . type_name ("Weight") . docs (& ["Weight of calling `seal_weight_to_fee`."])) . field (| f | f . ty :: < Weight > () . name ("gas") . type_name ("Weight") . docs (& ["Weight of calling `gas`."])) . field (| f | f . ty :: < Weight > () . name ("input") . type_name ("Weight") . docs (& ["Weight of calling `seal_input`."])) . field (| f | f . ty :: < Weight > () . name ("input_per_byte") . type_name ("Weight") . docs (& ["Weight per input byte copied to contract memory by `seal_input`."])) . field (| f | f . ty :: < Weight > () . name ("r#return") . type_name ("Weight") . docs (& ["Weight of calling `seal_return`."])) . field (| f | f . ty :: < Weight > () . name ("return_per_byte") . type_name ("Weight") . docs (& ["Weight per byte returned through `seal_return`."])) . field (| f | f . ty :: < Weight > () . name ("terminate") . type_name ("Weight") . docs (& ["Weight of calling `seal_terminate`."])) . field (| f | f . ty :: < Weight > () . name ("random") . type_name ("Weight") . docs (& ["Weight of calling `seal_random`."])) . field (| f | f . ty :: < Weight > () . name ("deposit_event") . type_name ("Weight") . docs (& ["Weight of calling `seal_reposit_event`."])) . field (| f | f . ty :: < Weight > () . name ("deposit_event_per_topic") . type_name ("Weight") . docs (& ["Weight per topic supplied to `seal_deposit_event`."])) . field (| f | f . ty :: < Weight > () . name ("deposit_event_per_byte") . type_name ("Weight") . docs (& ["Weight per byte of an event deposited through `seal_deposit_event`."])) . field (| f | f . ty :: < Weight > () . name ("debug_message") . type_name ("Weight") . docs (& ["Weight of calling `seal_debug_message`."])) . field (| f | f . ty :: < Weight > () . name ("debug_message_per_byte") . type_name ("Weight") . docs (& ["Weight of calling `seal_debug_message` per byte of the message."])) . field (| f | f . ty :: < Weight > () . name ("set_storage") . type_name ("Weight") . docs (& ["Weight of calling `seal_set_storage`."])) . field (| f | f . ty :: < Weight > () . name ("set_storage_per_new_byte") . type_name ("Weight") . docs (& ["Weight per written byten of an item stored with `seal_set_storage`."])) . field (| f | f . ty :: < Weight > () . name ("set_storage_per_old_byte") . type_name ("Weight") . docs (& ["Weight per overwritten byte of an item stored with `seal_set_storage`."])) . field (| f | f . ty :: < Weight > () . name ("set_code_hash") . type_name ("Weight") . docs (& ["Weight of calling `seal_set_code_hash`."])) . field (| f | f . ty :: < Weight > () . name ("clear_storage") . type_name ("Weight") . docs (& ["Weight of calling `seal_clear_storage`."])) . field (| f | f . ty :: < Weight > () . name ("clear_storage_per_byte") . type_name ("Weight") . docs (& ["Weight of calling `seal_clear_storage` per byte of the stored item."])) . field (| f | f . ty :: < Weight > () . name ("contains_storage") . type_name ("Weight") . docs (& ["Weight of calling `seal_contains_storage`."])) . field (| f | f . ty :: < Weight > () . name ("contains_storage_per_byte") . type_name ("Weight") . docs (& ["Weight of calling `seal_contains_storage` per byte of the stored item."])) . field (| f | f . ty :: < Weight > () . name ("get_storage") . type_name ("Weight") . docs (& ["Weight of calling `seal_get_storage`."])) . field (| f | f . ty :: < Weight > () . name ("get_storage_per_byte") . type_name ("Weight") . docs (& ["Weight per byte of an item received via `seal_get_storage`."])) . field (| f | f . ty :: < Weight > () . name ("take_storage") . type_name ("Weight") . docs (& ["Weight of calling `seal_take_storage`."])) . field (| f | f . ty :: < Weight > () . name ("take_storage_per_byte") . type_name ("Weight") . docs (& ["Weight per byte of an item received via `seal_take_storage`."])) . field (| f | f . ty :: < Weight > () . name ("transfer") . type_name ("Weight") . docs (& ["Weight of calling `seal_transfer`."])) . field (| f | f . ty :: < Weight > () . name ("call") . type_name ("Weight") . docs (& ["Weight of calling `seal_call`."])) . field (| f | f . ty :: < Weight > () . name ("delegate_call") . type_name ("Weight") . docs (& ["Weight of calling `seal_delegate_call`."])) . field (| f | f . ty :: < Weight > () . name ("call_transfer_surcharge") . type_name ("Weight") . docs (& ["Weight surcharge that is claimed if `seal_call` does a balance transfer."])) . field (| f | f . ty :: < Weight > () . name ("call_per_cloned_byte") . type_name ("Weight") . docs (& ["Weight per byte that is cloned by supplying the `CLONE_INPUT` flag."])) . field (| f | f . ty :: < Weight > () . name ("instantiate") . type_name ("Weight") . docs (& ["Weight of calling `seal_instantiate`."])) . field (| f | f . ty :: < Weight > () . name ("instantiate_transfer_surcharge") . type_name ("Weight") . docs (& ["Weight surcharge that is claimed if `seal_instantiate` does a balance transfer."])) . field (| f | f . ty :: < Weight > () . name ("instantiate_per_input_byte") . type_name ("Weight") . docs (& ["Weight per input byte supplied to `seal_instantiate`."])) . field (| f | f . ty :: < Weight > () . name ("instantiate_per_salt_byte") . type_name ("Weight") . docs (& ["Weight per salt byte supplied to `seal_instantiate`."])) . field (| f | f . ty :: < Weight > () . name ("hash_sha2_256") . type_name ("Weight") . docs (& ["Weight of calling `seal_hash_sha_256`."])) . field (| f | f . ty :: < Weight > () . name ("hash_sha2_256_per_byte") . type_name ("Weight") . docs (& ["Weight per byte hashed by `seal_hash_sha_256`."])) . field (| f | f . ty :: < Weight > () . name ("hash_keccak_256") . type_name ("Weight") . docs (& ["Weight of calling `seal_hash_keccak_256`."])) . field (| f | f . ty :: < Weight > () . name ("hash_keccak_256_per_byte") . type_name ("Weight") . docs (& ["Weight per byte hashed by `seal_hash_keccak_256`."])) . field (| f | f . ty :: < Weight > () . name ("hash_blake2_256") . type_name ("Weight") . docs (& ["Weight of calling `seal_hash_blake2_256`."])) . field (| f | f . ty :: < Weight > () . name ("hash_blake2_256_per_byte") . type_name ("Weight") . docs (& ["Weight per byte hashed by `seal_hash_blake2_256`."])) . field (| f | f . ty :: < Weight > () . name ("hash_blake2_128") . type_name ("Weight") . docs (& ["Weight of calling `seal_hash_blake2_128`."])) . field (| f | f . ty :: < Weight > () . name ("hash_blake2_128_per_byte") . type_name ("Weight") . docs (& ["Weight per byte hashed by `seal_hash_blake2_128`."])) . field (| f | f . ty :: < Weight > () . name ("ecdsa_recover") . type_name ("Weight") . docs (& ["Weight of calling `seal_ecdsa_recover`."])) . field (| f | f . ty :: < Weight > () . name ("ecdsa_to_eth_address") . type_name ("Weight") . docs (& ["Weight of calling `seal_ecdsa_to_eth_address`."])) . field (| f | f . ty :: < Weight > () . name ("sr25519_verify") . type_name ("Weight") . docs (& ["Weight of calling `sr25519_verify`."])) . field (| f | f . ty :: < Weight > () . name ("sr25519_verify_per_byte") . type_name ("Weight") . docs (& ["Weight per byte of calling `sr25519_verify`."])) . field (| f | f . ty :: < Weight > () . name ("reentrance_count") . type_name ("Weight") . docs (& ["Weight of calling `reentrance_count`."])) . field (| f | f . ty :: < Weight > () . name ("account_reentrance_count") . type_name ("Weight") . docs (& ["Weight of calling `account_reentrance_count`."])) . field (| f | f . ty :: < Weight > () . name ("instantiation_nonce") . type_name ("Weight") . docs (& ["Weight of calling `instantiation_nonce`."])))
            }
        };
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<T: Config> _serde::Serialize for HostFnWeights<T> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "HostFnWeights",
                    false as usize
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1
                        + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "caller",
                    &self.caller,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_contract",
                    &self.is_contract,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "code_hash",
                    &self.code_hash,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "own_code_hash",
                    &self.own_code_hash,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "caller_is_origin",
                    &self.caller_is_origin,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "caller_is_root",
                    &self.caller_is_root,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "address",
                    &self.address,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "gas_left",
                    &self.gas_left,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balance",
                    &self.balance,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value_transferred",
                    &self.value_transferred,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "minimum_balance",
                    &self.minimum_balance,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block_number",
                    &self.block_number,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "now",
                    &self.now,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "weight_to_fee",
                    &self.weight_to_fee,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "gas",
                    &self.gas,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "input",
                    &self.input,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "input_per_byte",
                    &self.input_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "return",
                    &self.r#return,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "return_per_byte",
                    &self.return_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "terminate",
                    &self.terminate,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "random",
                    &self.random,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deposit_event",
                    &self.deposit_event,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deposit_event_per_topic",
                    &self.deposit_event_per_topic,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deposit_event_per_byte",
                    &self.deposit_event_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "debug_message",
                    &self.debug_message,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "debug_message_per_byte",
                    &self.debug_message_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "set_storage",
                    &self.set_storage,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "set_storage_per_new_byte",
                    &self.set_storage_per_new_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "set_storage_per_old_byte",
                    &self.set_storage_per_old_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "set_code_hash",
                    &self.set_code_hash,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "clear_storage",
                    &self.clear_storage,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "clear_storage_per_byte",
                    &self.clear_storage_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contains_storage",
                    &self.contains_storage,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contains_storage_per_byte",
                    &self.contains_storage_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "get_storage",
                    &self.get_storage,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "get_storage_per_byte",
                    &self.get_storage_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "take_storage",
                    &self.take_storage,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "take_storage_per_byte",
                    &self.take_storage_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transfer",
                    &self.transfer,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "call",
                    &self.call,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "delegate_call",
                    &self.delegate_call,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "call_transfer_surcharge",
                    &self.call_transfer_surcharge,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "call_per_cloned_byte",
                    &self.call_per_cloned_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "instantiate",
                    &self.instantiate,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "instantiate_transfer_surcharge",
                    &self.instantiate_transfer_surcharge,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "instantiate_per_input_byte",
                    &self.instantiate_per_input_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "instantiate_per_salt_byte",
                    &self.instantiate_per_salt_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_sha2_256",
                    &self.hash_sha2_256,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_sha2_256_per_byte",
                    &self.hash_sha2_256_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_keccak_256",
                    &self.hash_keccak_256,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_keccak_256_per_byte",
                    &self.hash_keccak_256_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_blake2_256",
                    &self.hash_blake2_256,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_blake2_256_per_byte",
                    &self.hash_blake2_256_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_blake2_128",
                    &self.hash_blake2_128,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash_blake2_128_per_byte",
                    &self.hash_blake2_128_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ecdsa_recover",
                    &self.ecdsa_recover,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ecdsa_to_eth_address",
                    &self.ecdsa_to_eth_address,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sr25519_verify",
                    &self.sr25519_verify,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sr25519_verify_per_byte",
                    &self.sr25519_verify_per_byte,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reentrance_count",
                    &self.reentrance_count,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "account_reentrance_count",
                    &self.account_reentrance_count,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "instantiation_nonce",
                    &self.instantiation_nonce,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "_phantom",
                    &self._phantom,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, T: Config> _serde::Deserialize<'de> for HostFnWeights<T> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                    __field26,
                    __field27,
                    __field28,
                    __field29,
                    __field30,
                    __field31,
                    __field32,
                    __field33,
                    __field34,
                    __field35,
                    __field36,
                    __field37,
                    __field38,
                    __field39,
                    __field40,
                    __field41,
                    __field42,
                    __field43,
                    __field44,
                    __field45,
                    __field46,
                    __field47,
                    __field48,
                    __field49,
                    __field50,
                    __field51,
                    __field52,
                    __field53,
                    __field54,
                    __field55,
                    __field56,
                    __field57,
                    __field58,
                    __field59,
                    __field60,
                    __field61,
                    __field62,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            21u64 => _serde::__private::Ok(__Field::__field21),
                            22u64 => _serde::__private::Ok(__Field::__field22),
                            23u64 => _serde::__private::Ok(__Field::__field23),
                            24u64 => _serde::__private::Ok(__Field::__field24),
                            25u64 => _serde::__private::Ok(__Field::__field25),
                            26u64 => _serde::__private::Ok(__Field::__field26),
                            27u64 => _serde::__private::Ok(__Field::__field27),
                            28u64 => _serde::__private::Ok(__Field::__field28),
                            29u64 => _serde::__private::Ok(__Field::__field29),
                            30u64 => _serde::__private::Ok(__Field::__field30),
                            31u64 => _serde::__private::Ok(__Field::__field31),
                            32u64 => _serde::__private::Ok(__Field::__field32),
                            33u64 => _serde::__private::Ok(__Field::__field33),
                            34u64 => _serde::__private::Ok(__Field::__field34),
                            35u64 => _serde::__private::Ok(__Field::__field35),
                            36u64 => _serde::__private::Ok(__Field::__field36),
                            37u64 => _serde::__private::Ok(__Field::__field37),
                            38u64 => _serde::__private::Ok(__Field::__field38),
                            39u64 => _serde::__private::Ok(__Field::__field39),
                            40u64 => _serde::__private::Ok(__Field::__field40),
                            41u64 => _serde::__private::Ok(__Field::__field41),
                            42u64 => _serde::__private::Ok(__Field::__field42),
                            43u64 => _serde::__private::Ok(__Field::__field43),
                            44u64 => _serde::__private::Ok(__Field::__field44),
                            45u64 => _serde::__private::Ok(__Field::__field45),
                            46u64 => _serde::__private::Ok(__Field::__field46),
                            47u64 => _serde::__private::Ok(__Field::__field47),
                            48u64 => _serde::__private::Ok(__Field::__field48),
                            49u64 => _serde::__private::Ok(__Field::__field49),
                            50u64 => _serde::__private::Ok(__Field::__field50),
                            51u64 => _serde::__private::Ok(__Field::__field51),
                            52u64 => _serde::__private::Ok(__Field::__field52),
                            53u64 => _serde::__private::Ok(__Field::__field53),
                            54u64 => _serde::__private::Ok(__Field::__field54),
                            55u64 => _serde::__private::Ok(__Field::__field55),
                            56u64 => _serde::__private::Ok(__Field::__field56),
                            57u64 => _serde::__private::Ok(__Field::__field57),
                            58u64 => _serde::__private::Ok(__Field::__field58),
                            59u64 => _serde::__private::Ok(__Field::__field59),
                            60u64 => _serde::__private::Ok(__Field::__field60),
                            61u64 => _serde::__private::Ok(__Field::__field61),
                            62u64 => _serde::__private::Ok(__Field::__field62),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "caller" => _serde::__private::Ok(__Field::__field0),
                            "is_contract" => _serde::__private::Ok(__Field::__field1),
                            "code_hash" => _serde::__private::Ok(__Field::__field2),
                            "own_code_hash" => _serde::__private::Ok(__Field::__field3),
                            "caller_is_origin" => _serde::__private::Ok(__Field::__field4),
                            "caller_is_root" => _serde::__private::Ok(__Field::__field5),
                            "address" => _serde::__private::Ok(__Field::__field6),
                            "gas_left" => _serde::__private::Ok(__Field::__field7),
                            "balance" => _serde::__private::Ok(__Field::__field8),
                            "value_transferred" => _serde::__private::Ok(__Field::__field9),
                            "minimum_balance" => _serde::__private::Ok(__Field::__field10),
                            "block_number" => _serde::__private::Ok(__Field::__field11),
                            "now" => _serde::__private::Ok(__Field::__field12),
                            "weight_to_fee" => _serde::__private::Ok(__Field::__field13),
                            "gas" => _serde::__private::Ok(__Field::__field14),
                            "input" => _serde::__private::Ok(__Field::__field15),
                            "input_per_byte" => _serde::__private::Ok(__Field::__field16),
                            "return" => _serde::__private::Ok(__Field::__field17),
                            "return_per_byte" => _serde::__private::Ok(__Field::__field18),
                            "terminate" => _serde::__private::Ok(__Field::__field19),
                            "random" => _serde::__private::Ok(__Field::__field20),
                            "deposit_event" => _serde::__private::Ok(__Field::__field21),
                            "deposit_event_per_topic" => _serde::__private::Ok(__Field::__field22),
                            "deposit_event_per_byte" => _serde::__private::Ok(__Field::__field23),
                            "debug_message" => _serde::__private::Ok(__Field::__field24),
                            "debug_message_per_byte" => _serde::__private::Ok(__Field::__field25),
                            "set_storage" => _serde::__private::Ok(__Field::__field26),
                            "set_storage_per_new_byte" => _serde::__private::Ok(__Field::__field27),
                            "set_storage_per_old_byte" => _serde::__private::Ok(__Field::__field28),
                            "set_code_hash" => _serde::__private::Ok(__Field::__field29),
                            "clear_storage" => _serde::__private::Ok(__Field::__field30),
                            "clear_storage_per_byte" => _serde::__private::Ok(__Field::__field31),
                            "contains_storage" => _serde::__private::Ok(__Field::__field32),
                            "contains_storage_per_byte" => {
                                _serde::__private::Ok(__Field::__field33)
                            }
                            "get_storage" => _serde::__private::Ok(__Field::__field34),
                            "get_storage_per_byte" => _serde::__private::Ok(__Field::__field35),
                            "take_storage" => _serde::__private::Ok(__Field::__field36),
                            "take_storage_per_byte" => _serde::__private::Ok(__Field::__field37),
                            "transfer" => _serde::__private::Ok(__Field::__field38),
                            "call" => _serde::__private::Ok(__Field::__field39),
                            "delegate_call" => _serde::__private::Ok(__Field::__field40),
                            "call_transfer_surcharge" => _serde::__private::Ok(__Field::__field41),
                            "call_per_cloned_byte" => _serde::__private::Ok(__Field::__field42),
                            "instantiate" => _serde::__private::Ok(__Field::__field43),
                            "instantiate_transfer_surcharge" => {
                                _serde::__private::Ok(__Field::__field44)
                            }
                            "instantiate_per_input_byte" => {
                                _serde::__private::Ok(__Field::__field45)
                            }
                            "instantiate_per_salt_byte" => {
                                _serde::__private::Ok(__Field::__field46)
                            }
                            "hash_sha2_256" => _serde::__private::Ok(__Field::__field47),
                            "hash_sha2_256_per_byte" => _serde::__private::Ok(__Field::__field48),
                            "hash_keccak_256" => _serde::__private::Ok(__Field::__field49),
                            "hash_keccak_256_per_byte" => _serde::__private::Ok(__Field::__field50),
                            "hash_blake2_256" => _serde::__private::Ok(__Field::__field51),
                            "hash_blake2_256_per_byte" => _serde::__private::Ok(__Field::__field52),
                            "hash_blake2_128" => _serde::__private::Ok(__Field::__field53),
                            "hash_blake2_128_per_byte" => _serde::__private::Ok(__Field::__field54),
                            "ecdsa_recover" => _serde::__private::Ok(__Field::__field55),
                            "ecdsa_to_eth_address" => _serde::__private::Ok(__Field::__field56),
                            "sr25519_verify" => _serde::__private::Ok(__Field::__field57),
                            "sr25519_verify_per_byte" => _serde::__private::Ok(__Field::__field58),
                            "reentrance_count" => _serde::__private::Ok(__Field::__field59),
                            "account_reentrance_count" => _serde::__private::Ok(__Field::__field60),
                            "instantiation_nonce" => _serde::__private::Ok(__Field::__field61),
                            "_phantom" => _serde::__private::Ok(__Field::__field62),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"caller" => _serde::__private::Ok(__Field::__field0),
                            b"is_contract" => _serde::__private::Ok(__Field::__field1),
                            b"code_hash" => _serde::__private::Ok(__Field::__field2),
                            b"own_code_hash" => _serde::__private::Ok(__Field::__field3),
                            b"caller_is_origin" => _serde::__private::Ok(__Field::__field4),
                            b"caller_is_root" => _serde::__private::Ok(__Field::__field5),
                            b"address" => _serde::__private::Ok(__Field::__field6),
                            b"gas_left" => _serde::__private::Ok(__Field::__field7),
                            b"balance" => _serde::__private::Ok(__Field::__field8),
                            b"value_transferred" => _serde::__private::Ok(__Field::__field9),
                            b"minimum_balance" => _serde::__private::Ok(__Field::__field10),
                            b"block_number" => _serde::__private::Ok(__Field::__field11),
                            b"now" => _serde::__private::Ok(__Field::__field12),
                            b"weight_to_fee" => _serde::__private::Ok(__Field::__field13),
                            b"gas" => _serde::__private::Ok(__Field::__field14),
                            b"input" => _serde::__private::Ok(__Field::__field15),
                            b"input_per_byte" => _serde::__private::Ok(__Field::__field16),
                            b"return" => _serde::__private::Ok(__Field::__field17),
                            b"return_per_byte" => _serde::__private::Ok(__Field::__field18),
                            b"terminate" => _serde::__private::Ok(__Field::__field19),
                            b"random" => _serde::__private::Ok(__Field::__field20),
                            b"deposit_event" => _serde::__private::Ok(__Field::__field21),
                            b"deposit_event_per_topic" => _serde::__private::Ok(__Field::__field22),
                            b"deposit_event_per_byte" => _serde::__private::Ok(__Field::__field23),
                            b"debug_message" => _serde::__private::Ok(__Field::__field24),
                            b"debug_message_per_byte" => _serde::__private::Ok(__Field::__field25),
                            b"set_storage" => _serde::__private::Ok(__Field::__field26),
                            b"set_storage_per_new_byte" => {
                                _serde::__private::Ok(__Field::__field27)
                            }
                            b"set_storage_per_old_byte" => {
                                _serde::__private::Ok(__Field::__field28)
                            }
                            b"set_code_hash" => _serde::__private::Ok(__Field::__field29),
                            b"clear_storage" => _serde::__private::Ok(__Field::__field30),
                            b"clear_storage_per_byte" => _serde::__private::Ok(__Field::__field31),
                            b"contains_storage" => _serde::__private::Ok(__Field::__field32),
                            b"contains_storage_per_byte" => {
                                _serde::__private::Ok(__Field::__field33)
                            }
                            b"get_storage" => _serde::__private::Ok(__Field::__field34),
                            b"get_storage_per_byte" => _serde::__private::Ok(__Field::__field35),
                            b"take_storage" => _serde::__private::Ok(__Field::__field36),
                            b"take_storage_per_byte" => _serde::__private::Ok(__Field::__field37),
                            b"transfer" => _serde::__private::Ok(__Field::__field38),
                            b"call" => _serde::__private::Ok(__Field::__field39),
                            b"delegate_call" => _serde::__private::Ok(__Field::__field40),
                            b"call_transfer_surcharge" => _serde::__private::Ok(__Field::__field41),
                            b"call_per_cloned_byte" => _serde::__private::Ok(__Field::__field42),
                            b"instantiate" => _serde::__private::Ok(__Field::__field43),
                            b"instantiate_transfer_surcharge" => {
                                _serde::__private::Ok(__Field::__field44)
                            }
                            b"instantiate_per_input_byte" => {
                                _serde::__private::Ok(__Field::__field45)
                            }
                            b"instantiate_per_salt_byte" => {
                                _serde::__private::Ok(__Field::__field46)
                            }
                            b"hash_sha2_256" => _serde::__private::Ok(__Field::__field47),
                            b"hash_sha2_256_per_byte" => _serde::__private::Ok(__Field::__field48),
                            b"hash_keccak_256" => _serde::__private::Ok(__Field::__field49),
                            b"hash_keccak_256_per_byte" => {
                                _serde::__private::Ok(__Field::__field50)
                            }
                            b"hash_blake2_256" => _serde::__private::Ok(__Field::__field51),
                            b"hash_blake2_256_per_byte" => {
                                _serde::__private::Ok(__Field::__field52)
                            }
                            b"hash_blake2_128" => _serde::__private::Ok(__Field::__field53),
                            b"hash_blake2_128_per_byte" => {
                                _serde::__private::Ok(__Field::__field54)
                            }
                            b"ecdsa_recover" => _serde::__private::Ok(__Field::__field55),
                            b"ecdsa_to_eth_address" => _serde::__private::Ok(__Field::__field56),
                            b"sr25519_verify" => _serde::__private::Ok(__Field::__field57),
                            b"sr25519_verify_per_byte" => _serde::__private::Ok(__Field::__field58),
                            b"reentrance_count" => _serde::__private::Ok(__Field::__field59),
                            b"account_reentrance_count" => {
                                _serde::__private::Ok(__Field::__field60)
                            }
                            b"instantiation_nonce" => _serde::__private::Ok(__Field::__field61),
                            b"_phantom" => _serde::__private::Ok(__Field::__field62),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de, T: Config> {
                    marker: _serde::__private::PhantomData<HostFnWeights<T>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, T: Config> _serde::de::Visitor<'de> for __Visitor<'de, T> {
                    type Value = HostFnWeights<T>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct HostFnWeights")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field4 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field5 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field6 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field7 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field8 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field9 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field10 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field11 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field12 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field13 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            13usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field14 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            14usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field15 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            15usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field16 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            16usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field17 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            17usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field18 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            18usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field19 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            19usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field20 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            20usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field21 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            21usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field22 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            22usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field23 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            23usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field24 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            24usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field25 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            25usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field26 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            26usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field27 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            27usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field28 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            28usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field29 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            29usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field30 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            30usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field31 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            31usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field32 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            32usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field33 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            33usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field34 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            34usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field35 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            35usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field36 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            36usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field37 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            37usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field38 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            38usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field39 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            39usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field40 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            40usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field41 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            41usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field42 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            42usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field43 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            43usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field44 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            44usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field45 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            45usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field46 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            46usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field47 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            47usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field48 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            48usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field49 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            49usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field50 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            50usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field51 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            51usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field52 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            52usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field53 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            53usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field54 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            54usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field55 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            55usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field56 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            56usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field57 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            57usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field58 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            58usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field59 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            59usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field60 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            60usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field61 =
                            match match _serde::de::SeqAccess::next_element::<Weight>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            61usize,
                                            &"struct HostFnWeights with 63 elements",
                                        ),
                                    );
                                }
                            };
                        let __field62 = match match _serde::de::SeqAccess::next_element::<
                            PhantomData<T>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    62usize,
                                    &"struct HostFnWeights with 63 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(HostFnWeights {
                            caller: __field0,
                            is_contract: __field1,
                            code_hash: __field2,
                            own_code_hash: __field3,
                            caller_is_origin: __field4,
                            caller_is_root: __field5,
                            address: __field6,
                            gas_left: __field7,
                            balance: __field8,
                            value_transferred: __field9,
                            minimum_balance: __field10,
                            block_number: __field11,
                            now: __field12,
                            weight_to_fee: __field13,
                            gas: __field14,
                            input: __field15,
                            input_per_byte: __field16,
                            r#return: __field17,
                            return_per_byte: __field18,
                            terminate: __field19,
                            random: __field20,
                            deposit_event: __field21,
                            deposit_event_per_topic: __field22,
                            deposit_event_per_byte: __field23,
                            debug_message: __field24,
                            debug_message_per_byte: __field25,
                            set_storage: __field26,
                            set_storage_per_new_byte: __field27,
                            set_storage_per_old_byte: __field28,
                            set_code_hash: __field29,
                            clear_storage: __field30,
                            clear_storage_per_byte: __field31,
                            contains_storage: __field32,
                            contains_storage_per_byte: __field33,
                            get_storage: __field34,
                            get_storage_per_byte: __field35,
                            take_storage: __field36,
                            take_storage_per_byte: __field37,
                            transfer: __field38,
                            call: __field39,
                            delegate_call: __field40,
                            call_transfer_surcharge: __field41,
                            call_per_cloned_byte: __field42,
                            instantiate: __field43,
                            instantiate_transfer_surcharge: __field44,
                            instantiate_per_input_byte: __field45,
                            instantiate_per_salt_byte: __field46,
                            hash_sha2_256: __field47,
                            hash_sha2_256_per_byte: __field48,
                            hash_keccak_256: __field49,
                            hash_keccak_256_per_byte: __field50,
                            hash_blake2_256: __field51,
                            hash_blake2_256_per_byte: __field52,
                            hash_blake2_128: __field53,
                            hash_blake2_128_per_byte: __field54,
                            ecdsa_recover: __field55,
                            ecdsa_to_eth_address: __field56,
                            sr25519_verify: __field57,
                            sr25519_verify_per_byte: __field58,
                            reentrance_count: __field59,
                            account_reentrance_count: __field60,
                            instantiation_nonce: __field61,
                            _phantom: __field62,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field11: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field12: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field13: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field14: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field15: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field16: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field17: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field18: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field19: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field20: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field21: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field22: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field23: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field24: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field25: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field26: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field27: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field28: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field29: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field30: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field31: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field32: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field33: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field34: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field35: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field36: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field37: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field38: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field39: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field40: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field41: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field42: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field43: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field44: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field45: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field46: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field47: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field48: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field49: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field50: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field51: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field52: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field53: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field54: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field55: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field56: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field57: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field58: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field59: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field60: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field61: _serde::__private::Option<Weight> =
                            _serde::__private::None;
                        let mut __field62: _serde::__private::Option<PhantomData<T>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "caller",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "is_contract",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "code_hash",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "own_code_hash",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "caller_is_origin",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "caller_is_root",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "address",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "gas_left",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balance",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value_transferred",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "minimum_balance",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block_number",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "now",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "weight_to_fee",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "gas",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "input",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "input_per_byte",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "return",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "return_per_byte",
                                            ),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "terminate",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field20 => {
                                    if _serde::__private::Option::is_some(&__field20) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "random",
                                            ),
                                        );
                                    }
                                    __field20 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field21 => {
                                    if _serde::__private::Option::is_some(&__field21) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deposit_event",
                                            ),
                                        );
                                    }
                                    __field21 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field22 => {
                                    if _serde::__private::Option::is_some(&__field22) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deposit_event_per_topic",
                                            ),
                                        );
                                    }
                                    __field22 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field23 => {
                                    if _serde::__private::Option::is_some(&__field23) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deposit_event_per_byte",
                                            ),
                                        );
                                    }
                                    __field23 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field24 => {
                                    if _serde::__private::Option::is_some(&__field24) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "debug_message",
                                            ),
                                        );
                                    }
                                    __field24 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field25 => {
                                    if _serde::__private::Option::is_some(&__field25) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "debug_message_per_byte",
                                            ),
                                        );
                                    }
                                    __field25 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field26 => {
                                    if _serde::__private::Option::is_some(&__field26) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "set_storage",
                                            ),
                                        );
                                    }
                                    __field26 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field27 => {
                                    if _serde::__private::Option::is_some(&__field27) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "set_storage_per_new_byte",
                                            ),
                                        );
                                    }
                                    __field27 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field28 => {
                                    if _serde::__private::Option::is_some(&__field28) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "set_storage_per_old_byte",
                                            ),
                                        );
                                    }
                                    __field28 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field29 => {
                                    if _serde::__private::Option::is_some(&__field29) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "set_code_hash",
                                            ),
                                        );
                                    }
                                    __field29 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field30 => {
                                    if _serde::__private::Option::is_some(&__field30) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "clear_storage",
                                            ),
                                        );
                                    }
                                    __field30 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field31 => {
                                    if _serde::__private::Option::is_some(&__field31) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "clear_storage_per_byte",
                                            ),
                                        );
                                    }
                                    __field31 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field32 => {
                                    if _serde::__private::Option::is_some(&__field32) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contains_storage",
                                            ),
                                        );
                                    }
                                    __field32 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field33 => {
                                    if _serde::__private::Option::is_some(&__field33) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contains_storage_per_byte",
                                            ),
                                        );
                                    }
                                    __field33 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field34 => {
                                    if _serde::__private::Option::is_some(&__field34) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "get_storage",
                                            ),
                                        );
                                    }
                                    __field34 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field35 => {
                                    if _serde::__private::Option::is_some(&__field35) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "get_storage_per_byte",
                                            ),
                                        );
                                    }
                                    __field35 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field36 => {
                                    if _serde::__private::Option::is_some(&__field36) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "take_storage",
                                            ),
                                        );
                                    }
                                    __field36 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field37 => {
                                    if _serde::__private::Option::is_some(&__field37) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "take_storage_per_byte",
                                            ),
                                        );
                                    }
                                    __field37 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field38 => {
                                    if _serde::__private::Option::is_some(&__field38) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transfer",
                                            ),
                                        );
                                    }
                                    __field38 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field39 => {
                                    if _serde::__private::Option::is_some(&__field39) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "call",
                                            ),
                                        );
                                    }
                                    __field39 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field40 => {
                                    if _serde::__private::Option::is_some(&__field40) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "delegate_call",
                                            ),
                                        );
                                    }
                                    __field40 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field41 => {
                                    if _serde::__private::Option::is_some(&__field41) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "call_transfer_surcharge",
                                            ),
                                        );
                                    }
                                    __field41 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field42 => {
                                    if _serde::__private::Option::is_some(&__field42) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "call_per_cloned_byte",
                                            ),
                                        );
                                    }
                                    __field42 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field43 => {
                                    if _serde::__private::Option::is_some(&__field43) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "instantiate",
                                            ),
                                        );
                                    }
                                    __field43 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field44 => {
                                    if _serde::__private::Option::is_some(&__field44) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "instantiate_transfer_surcharge",
                                            ),
                                        );
                                    }
                                    __field44 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field45 => {
                                    if _serde::__private::Option::is_some(&__field45) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "instantiate_per_input_byte",
                                            ),
                                        );
                                    }
                                    __field45 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field46 => {
                                    if _serde::__private::Option::is_some(&__field46) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "instantiate_per_salt_byte",
                                            ),
                                        );
                                    }
                                    __field46 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field47 => {
                                    if _serde::__private::Option::is_some(&__field47) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_sha2_256",
                                            ),
                                        );
                                    }
                                    __field47 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field48 => {
                                    if _serde::__private::Option::is_some(&__field48) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_sha2_256_per_byte",
                                            ),
                                        );
                                    }
                                    __field48 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field49 => {
                                    if _serde::__private::Option::is_some(&__field49) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_keccak_256",
                                            ),
                                        );
                                    }
                                    __field49 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field50 => {
                                    if _serde::__private::Option::is_some(&__field50) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_keccak_256_per_byte",
                                            ),
                                        );
                                    }
                                    __field50 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field51 => {
                                    if _serde::__private::Option::is_some(&__field51) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_blake2_256",
                                            ),
                                        );
                                    }
                                    __field51 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field52 => {
                                    if _serde::__private::Option::is_some(&__field52) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_blake2_256_per_byte",
                                            ),
                                        );
                                    }
                                    __field52 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field53 => {
                                    if _serde::__private::Option::is_some(&__field53) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_blake2_128",
                                            ),
                                        );
                                    }
                                    __field53 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field54 => {
                                    if _serde::__private::Option::is_some(&__field54) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hash_blake2_128_per_byte",
                                            ),
                                        );
                                    }
                                    __field54 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field55 => {
                                    if _serde::__private::Option::is_some(&__field55) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ecdsa_recover",
                                            ),
                                        );
                                    }
                                    __field55 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field56 => {
                                    if _serde::__private::Option::is_some(&__field56) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ecdsa_to_eth_address",
                                            ),
                                        );
                                    }
                                    __field56 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field57 => {
                                    if _serde::__private::Option::is_some(&__field57) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sr25519_verify",
                                            ),
                                        );
                                    }
                                    __field57 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field58 => {
                                    if _serde::__private::Option::is_some(&__field58) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sr25519_verify_per_byte",
                                            ),
                                        );
                                    }
                                    __field58 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field59 => {
                                    if _serde::__private::Option::is_some(&__field59) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reentrance_count",
                                            ),
                                        );
                                    }
                                    __field59 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field60 => {
                                    if _serde::__private::Option::is_some(&__field60) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_reentrance_count",
                                            ),
                                        );
                                    }
                                    __field60 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field61 => {
                                    if _serde::__private::Option::is_some(&__field61) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "instantiation_nonce",
                                            ),
                                        );
                                    }
                                    __field61 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Weight>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field62 => {
                                    if _serde::__private::Option::is_some(&__field62) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "_phantom",
                                            ),
                                        );
                                    }
                                    __field62 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<PhantomData<T>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("caller") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("is_contract") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("code_hash") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("own_code_hash") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("caller_is_origin") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("caller_is_root") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("address") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("gas_left") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("balance") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("value_transferred") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("minimum_balance") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("block_number") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("now") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("weight_to_fee") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("gas") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("input") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("input_per_byte") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("return") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("return_per_byte") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("terminate") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field20 = match __field20 {
                            _serde::__private::Some(__field20) => __field20,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("random") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field21 = match __field21 {
                            _serde::__private::Some(__field21) => __field21,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("deposit_event") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field22 = match __field22 {
                            _serde::__private::Some(__field22) => __field22,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "deposit_event_per_topic",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field23 = match __field23 {
                            _serde::__private::Some(__field23) => __field23,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("deposit_event_per_byte")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field24 = match __field24 {
                            _serde::__private::Some(__field24) => __field24,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("debug_message") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field25 = match __field25 {
                            _serde::__private::Some(__field25) => __field25,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("debug_message_per_byte")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field26 = match __field26 {
                            _serde::__private::Some(__field26) => __field26,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("set_storage") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field27 = match __field27 {
                            _serde::__private::Some(__field27) => __field27,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "set_storage_per_new_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field28 = match __field28 {
                            _serde::__private::Some(__field28) => __field28,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "set_storage_per_old_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field29 = match __field29 {
                            _serde::__private::Some(__field29) => __field29,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("set_code_hash") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field30 = match __field30 {
                            _serde::__private::Some(__field30) => __field30,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("clear_storage") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field31 = match __field31 {
                            _serde::__private::Some(__field31) => __field31,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("clear_storage_per_byte")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field32 = match __field32 {
                            _serde::__private::Some(__field32) => __field32,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("contains_storage") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field33 = match __field33 {
                            _serde::__private::Some(__field33) => __field33,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "contains_storage_per_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field34 = match __field34 {
                            _serde::__private::Some(__field34) => __field34,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("get_storage") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field35 = match __field35 {
                            _serde::__private::Some(__field35) => __field35,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("get_storage_per_byte") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field36 = match __field36 {
                            _serde::__private::Some(__field36) => __field36,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("take_storage") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field37 = match __field37 {
                            _serde::__private::Some(__field37) => __field37,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("take_storage_per_byte")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field38 = match __field38 {
                            _serde::__private::Some(__field38) => __field38,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("transfer") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field39 = match __field39 {
                            _serde::__private::Some(__field39) => __field39,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("call") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field40 = match __field40 {
                            _serde::__private::Some(__field40) => __field40,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("delegate_call") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field41 = match __field41 {
                            _serde::__private::Some(__field41) => __field41,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "call_transfer_surcharge",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field42 = match __field42 {
                            _serde::__private::Some(__field42) => __field42,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("call_per_cloned_byte") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field43 = match __field43 {
                            _serde::__private::Some(__field43) => __field43,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("instantiate") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field44 = match __field44 {
                            _serde::__private::Some(__field44) => __field44,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "instantiate_transfer_surcharge",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field45 = match __field45 {
                            _serde::__private::Some(__field45) => __field45,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "instantiate_per_input_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field46 = match __field46 {
                            _serde::__private::Some(__field46) => __field46,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "instantiate_per_salt_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field47 = match __field47 {
                            _serde::__private::Some(__field47) => __field47,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("hash_sha2_256") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field48 = match __field48 {
                            _serde::__private::Some(__field48) => __field48,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("hash_sha2_256_per_byte")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field49 = match __field49 {
                            _serde::__private::Some(__field49) => __field49,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("hash_keccak_256") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field50 = match __field50 {
                            _serde::__private::Some(__field50) => __field50,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "hash_keccak_256_per_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field51 = match __field51 {
                            _serde::__private::Some(__field51) => __field51,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("hash_blake2_256") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field52 = match __field52 {
                            _serde::__private::Some(__field52) => __field52,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "hash_blake2_256_per_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field53 = match __field53 {
                            _serde::__private::Some(__field53) => __field53,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("hash_blake2_128") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field54 = match __field54 {
                            _serde::__private::Some(__field54) => __field54,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "hash_blake2_128_per_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field55 = match __field55 {
                            _serde::__private::Some(__field55) => __field55,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("ecdsa_recover") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field56 = match __field56 {
                            _serde::__private::Some(__field56) => __field56,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("ecdsa_to_eth_address") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field57 = match __field57 {
                            _serde::__private::Some(__field57) => __field57,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("sr25519_verify") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field58 = match __field58 {
                            _serde::__private::Some(__field58) => __field58,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "sr25519_verify_per_byte",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field59 = match __field59 {
                            _serde::__private::Some(__field59) => __field59,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("reentrance_count") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field60 = match __field60 {
                            _serde::__private::Some(__field60) => __field60,
                            _serde::__private::None => match _serde::__private::de::missing_field(
                                "account_reentrance_count",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                        };
                        let __field61 = match __field61 {
                            _serde::__private::Some(__field61) => __field61,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("instantiation_nonce") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field62 = match __field62 {
                            _serde::__private::Some(__field62) => __field62,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("_phantom") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(HostFnWeights {
                            caller: __field0,
                            is_contract: __field1,
                            code_hash: __field2,
                            own_code_hash: __field3,
                            caller_is_origin: __field4,
                            caller_is_root: __field5,
                            address: __field6,
                            gas_left: __field7,
                            balance: __field8,
                            value_transferred: __field9,
                            minimum_balance: __field10,
                            block_number: __field11,
                            now: __field12,
                            weight_to_fee: __field13,
                            gas: __field14,
                            input: __field15,
                            input_per_byte: __field16,
                            r#return: __field17,
                            return_per_byte: __field18,
                            terminate: __field19,
                            random: __field20,
                            deposit_event: __field21,
                            deposit_event_per_topic: __field22,
                            deposit_event_per_byte: __field23,
                            debug_message: __field24,
                            debug_message_per_byte: __field25,
                            set_storage: __field26,
                            set_storage_per_new_byte: __field27,
                            set_storage_per_old_byte: __field28,
                            set_code_hash: __field29,
                            clear_storage: __field30,
                            clear_storage_per_byte: __field31,
                            contains_storage: __field32,
                            contains_storage_per_byte: __field33,
                            get_storage: __field34,
                            get_storage_per_byte: __field35,
                            take_storage: __field36,
                            take_storage_per_byte: __field37,
                            transfer: __field38,
                            call: __field39,
                            delegate_call: __field40,
                            call_transfer_surcharge: __field41,
                            call_per_cloned_byte: __field42,
                            instantiate: __field43,
                            instantiate_transfer_surcharge: __field44,
                            instantiate_per_input_byte: __field45,
                            instantiate_per_salt_byte: __field46,
                            hash_sha2_256: __field47,
                            hash_sha2_256_per_byte: __field48,
                            hash_keccak_256: __field49,
                            hash_keccak_256_per_byte: __field50,
                            hash_blake2_256: __field51,
                            hash_blake2_256_per_byte: __field52,
                            hash_blake2_128: __field53,
                            hash_blake2_128_per_byte: __field54,
                            ecdsa_recover: __field55,
                            ecdsa_to_eth_address: __field56,
                            sr25519_verify: __field57,
                            sr25519_verify_per_byte: __field58,
                            reentrance_count: __field59,
                            account_reentrance_count: __field60,
                            instantiation_nonce: __field61,
                            _phantom: __field62,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "caller",
                    "is_contract",
                    "code_hash",
                    "own_code_hash",
                    "caller_is_origin",
                    "caller_is_root",
                    "address",
                    "gas_left",
                    "balance",
                    "value_transferred",
                    "minimum_balance",
                    "block_number",
                    "now",
                    "weight_to_fee",
                    "gas",
                    "input",
                    "input_per_byte",
                    "return",
                    "return_per_byte",
                    "terminate",
                    "random",
                    "deposit_event",
                    "deposit_event_per_topic",
                    "deposit_event_per_byte",
                    "debug_message",
                    "debug_message_per_byte",
                    "set_storage",
                    "set_storage_per_new_byte",
                    "set_storage_per_old_byte",
                    "set_code_hash",
                    "clear_storage",
                    "clear_storage_per_byte",
                    "contains_storage",
                    "contains_storage_per_byte",
                    "get_storage",
                    "get_storage_per_byte",
                    "take_storage",
                    "take_storage_per_byte",
                    "transfer",
                    "call",
                    "delegate_call",
                    "call_transfer_surcharge",
                    "call_per_cloned_byte",
                    "instantiate",
                    "instantiate_transfer_surcharge",
                    "instantiate_per_input_byte",
                    "instantiate_per_salt_byte",
                    "hash_sha2_256",
                    "hash_sha2_256_per_byte",
                    "hash_keccak_256",
                    "hash_keccak_256_per_byte",
                    "hash_blake2_256",
                    "hash_blake2_256_per_byte",
                    "hash_blake2_128",
                    "hash_blake2_128_per_byte",
                    "ecdsa_recover",
                    "ecdsa_to_eth_address",
                    "sr25519_verify",
                    "sr25519_verify_per_byte",
                    "reentrance_count",
                    "account_reentrance_count",
                    "instantiation_nonce",
                    "_phantom",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "HostFnWeights",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<HostFnWeights<T>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Default for Limits {
        fn default() -> Self {
            Self {
                event_topics: 4,
                globals: 256,
                locals: 1024,
                parameters: 128,
                memory_pages: 16,
                table_size: 4096,
                br_table_size: 256,
                subject_len: 32,
                payload_len: 16 * 1024,
                runtime_memory: 1024 * 1024 * 128,
            }
        }
    }
    impl<T: Config> Default for InstructionWeights<T> {
        fn default() -> Self {
            Self {
                version: 4,
                fallback: 0,
                i64const: ((T::WeightInfo::instr_i64const(1)
                    .saturating_sub(T::WeightInfo::instr_i64const(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                i64load: ((T::WeightInfo::instr_i64load(1)
                    .saturating_sub(T::WeightInfo::instr_i64load(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64store: ((T::WeightInfo::instr_i64store(1)
                    .saturating_sub(T::WeightInfo::instr_i64store(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                select: ((T::WeightInfo::instr_select(1)
                    .saturating_sub(T::WeightInfo::instr_select(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(4),
                    ),
                r#if: ((T::WeightInfo::instr_if(1).saturating_sub(T::WeightInfo::instr_if(0)))
                    .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                br: ((T::WeightInfo::instr_br(1).saturating_sub(T::WeightInfo::instr_br(0)))
                    .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                br_if: ((T::WeightInfo::instr_br_if(1)
                    .saturating_sub(T::WeightInfo::instr_br_if(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                br_table: ((T::WeightInfo::instr_br_table(1)
                    .saturating_sub(T::WeightInfo::instr_br_table(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                br_table_per_entry: ((T::WeightInfo::instr_br_table_per_entry(1)
                    .saturating_sub(T::WeightInfo::instr_br_table_per_entry(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(0),
                    ),
                call: ((T::WeightInfo::instr_call(1).saturating_sub(T::WeightInfo::instr_call(0)))
                    .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                call_indirect: ((T::WeightInfo::instr_call_indirect(1)
                    .saturating_sub(T::WeightInfo::instr_call_indirect(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                call_per_local: ((T::WeightInfo::instr_call_per_local(1)
                    .saturating_sub(T::WeightInfo::instr_call_per_local(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(0),
                    ),
                local_get: ((T::WeightInfo::instr_local_get(1)
                    .saturating_sub(T::WeightInfo::instr_local_get(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                local_set: ((T::WeightInfo::instr_local_set(1)
                    .saturating_sub(T::WeightInfo::instr_local_set(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                local_tee: ((T::WeightInfo::instr_local_tee(1)
                    .saturating_sub(T::WeightInfo::instr_local_tee(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                global_get: ((T::WeightInfo::instr_global_get(1)
                    .saturating_sub(T::WeightInfo::instr_global_get(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                global_set: ((T::WeightInfo::instr_global_set(1)
                    .saturating_sub(T::WeightInfo::instr_global_set(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                memory_current: ((T::WeightInfo::instr_memory_current(1)
                    .saturating_sub(T::WeightInfo::instr_memory_current(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                memory_grow: ((T::WeightInfo::instr_memory_grow(1)
                    .saturating_sub(T::WeightInfo::instr_memory_grow(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(1),
                    ),
                i64clz: ((T::WeightInfo::instr_i64clz(1)
                    .saturating_sub(T::WeightInfo::instr_i64clz(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64ctz: ((T::WeightInfo::instr_i64ctz(1)
                    .saturating_sub(T::WeightInfo::instr_i64ctz(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64popcnt: ((T::WeightInfo::instr_i64popcnt(1)
                    .saturating_sub(T::WeightInfo::instr_i64popcnt(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64eqz: ((T::WeightInfo::instr_i64eqz(1)
                    .saturating_sub(T::WeightInfo::instr_i64eqz(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64extendsi32: ((T::WeightInfo::instr_i64extendsi32(1)
                    .saturating_sub(T::WeightInfo::instr_i64extendsi32(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64extendui32: ((T::WeightInfo::instr_i64extendui32(1)
                    .saturating_sub(T::WeightInfo::instr_i64extendui32(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i32wrapi64: ((T::WeightInfo::instr_i32wrapi64(1)
                    .saturating_sub(T::WeightInfo::instr_i32wrapi64(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(2),
                    ),
                i64eq: ((T::WeightInfo::instr_i64eq(1)
                    .saturating_sub(T::WeightInfo::instr_i64eq(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64ne: ((T::WeightInfo::instr_i64ne(1)
                    .saturating_sub(T::WeightInfo::instr_i64ne(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64lts: ((T::WeightInfo::instr_i64lts(1)
                    .saturating_sub(T::WeightInfo::instr_i64lts(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64ltu: ((T::WeightInfo::instr_i64ltu(1)
                    .saturating_sub(T::WeightInfo::instr_i64ltu(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64gts: ((T::WeightInfo::instr_i64gts(1)
                    .saturating_sub(T::WeightInfo::instr_i64gts(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64gtu: ((T::WeightInfo::instr_i64gtu(1)
                    .saturating_sub(T::WeightInfo::instr_i64gtu(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64les: ((T::WeightInfo::instr_i64les(1)
                    .saturating_sub(T::WeightInfo::instr_i64les(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64leu: ((T::WeightInfo::instr_i64leu(1)
                    .saturating_sub(T::WeightInfo::instr_i64leu(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64ges: ((T::WeightInfo::instr_i64ges(1)
                    .saturating_sub(T::WeightInfo::instr_i64ges(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64geu: ((T::WeightInfo::instr_i64geu(1)
                    .saturating_sub(T::WeightInfo::instr_i64geu(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64add: ((T::WeightInfo::instr_i64add(1)
                    .saturating_sub(T::WeightInfo::instr_i64add(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64sub: ((T::WeightInfo::instr_i64sub(1)
                    .saturating_sub(T::WeightInfo::instr_i64sub(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64mul: ((T::WeightInfo::instr_i64mul(1)
                    .saturating_sub(T::WeightInfo::instr_i64mul(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64divs: ((T::WeightInfo::instr_i64divs(1)
                    .saturating_sub(T::WeightInfo::instr_i64divs(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64divu: ((T::WeightInfo::instr_i64divu(1)
                    .saturating_sub(T::WeightInfo::instr_i64divu(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64rems: ((T::WeightInfo::instr_i64rems(1)
                    .saturating_sub(T::WeightInfo::instr_i64rems(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64remu: ((T::WeightInfo::instr_i64remu(1)
                    .saturating_sub(T::WeightInfo::instr_i64remu(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64and: ((T::WeightInfo::instr_i64and(1)
                    .saturating_sub(T::WeightInfo::instr_i64and(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64or: ((T::WeightInfo::instr_i64or(1)
                    .saturating_sub(T::WeightInfo::instr_i64or(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64xor: ((T::WeightInfo::instr_i64xor(1)
                    .saturating_sub(T::WeightInfo::instr_i64xor(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64shl: ((T::WeightInfo::instr_i64shl(1)
                    .saturating_sub(T::WeightInfo::instr_i64shl(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64shrs: ((T::WeightInfo::instr_i64shrs(1)
                    .saturating_sub(T::WeightInfo::instr_i64shrs(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64shru: ((T::WeightInfo::instr_i64shru(1)
                    .saturating_sub(T::WeightInfo::instr_i64shru(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64rotl: ((T::WeightInfo::instr_i64rotl(1)
                    .saturating_sub(T::WeightInfo::instr_i64rotl(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                i64rotr: ((T::WeightInfo::instr_i64rotr(1)
                    .saturating_sub(T::WeightInfo::instr_i64rotr(0)))
                .ref_time() as u32)
                    .saturating_sub(
                        ((T::WeightInfo::instr_i64const(1)
                            .saturating_sub(T::WeightInfo::instr_i64const(0)))
                        .ref_time() as u32
                            / 2)
                        .saturating_mul(3),
                    ),
                _phantom: PhantomData,
            }
        }
    }
    impl<T: Config> Default for HostFnWeights<T> {
        fn default() -> Self {
            Self {
                caller: (T::WeightInfo::seal_caller(1)
                    .saturating_sub(T::WeightInfo::seal_caller(0))),
                is_contract: (T::WeightInfo::seal_is_contract(1)
                    .saturating_sub(T::WeightInfo::seal_is_contract(0))),
                code_hash: (T::WeightInfo::seal_code_hash(1)
                    .saturating_sub(T::WeightInfo::seal_code_hash(0))),
                own_code_hash: (T::WeightInfo::seal_own_code_hash(1)
                    .saturating_sub(T::WeightInfo::seal_own_code_hash(0))),
                caller_is_origin: (T::WeightInfo::seal_caller_is_origin(1)
                    .saturating_sub(T::WeightInfo::seal_caller_is_origin(0))),
                caller_is_root: (T::WeightInfo::seal_caller_is_root(1)
                    .saturating_sub(T::WeightInfo::seal_caller_is_root(0))),
                address: (T::WeightInfo::seal_address(1)
                    .saturating_sub(T::WeightInfo::seal_address(0))),
                gas_left: (T::WeightInfo::seal_gas_left(1)
                    .saturating_sub(T::WeightInfo::seal_gas_left(0))),
                balance: (T::WeightInfo::seal_balance(1)
                    .saturating_sub(T::WeightInfo::seal_balance(0))),
                value_transferred: (T::WeightInfo::seal_value_transferred(1)
                    .saturating_sub(T::WeightInfo::seal_value_transferred(0))),
                minimum_balance: (T::WeightInfo::seal_minimum_balance(1)
                    .saturating_sub(T::WeightInfo::seal_minimum_balance(0))),
                block_number: (T::WeightInfo::seal_block_number(1)
                    .saturating_sub(T::WeightInfo::seal_block_number(0))),
                now: (T::WeightInfo::seal_now(1).saturating_sub(T::WeightInfo::seal_now(0))),
                weight_to_fee: (T::WeightInfo::seal_weight_to_fee(1)
                    .saturating_sub(T::WeightInfo::seal_weight_to_fee(0))),
                gas: (T::WeightInfo::seal_gas(1).saturating_sub(T::WeightInfo::seal_gas(0)))
                    .set_proof_size(0),
                input: (T::WeightInfo::seal_input(1).saturating_sub(T::WeightInfo::seal_input(0))),
                input_per_byte: (T::WeightInfo::seal_input_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_input_per_byte(0))),
                r#return: (T::WeightInfo::seal_return(1)
                    .saturating_sub(T::WeightInfo::seal_return(0))),
                return_per_byte: (T::WeightInfo::seal_return_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_return_per_byte(0))),
                terminate: (T::WeightInfo::seal_terminate(1)
                    .saturating_sub(T::WeightInfo::seal_terminate(0))),
                random: (T::WeightInfo::seal_random(1)
                    .saturating_sub(T::WeightInfo::seal_random(0))),
                deposit_event: (T::WeightInfo::seal_deposit_event(1)
                    .saturating_sub(T::WeightInfo::seal_deposit_event(0))),
                deposit_event_per_topic: (T::WeightInfo::seal_deposit_event_per_topic_and_byte(
                    1, 0,
                )
                .saturating_sub(T::WeightInfo::seal_deposit_event_per_topic_and_byte(0, 0))),
                deposit_event_per_byte: (T::WeightInfo::seal_deposit_event_per_topic_and_byte(
                    0, 1,
                )
                .saturating_sub(T::WeightInfo::seal_deposit_event_per_topic_and_byte(0, 0))),
                debug_message: (T::WeightInfo::seal_debug_message(1)
                    .saturating_sub(T::WeightInfo::seal_debug_message(0))),
                debug_message_per_byte: (T::WeightInfo::seal_debug_message_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_debug_message_per_byte(0))),
                set_storage: (T::WeightInfo::seal_set_storage(1)
                    .saturating_sub(T::WeightInfo::seal_set_storage(0))),
                set_code_hash: (T::WeightInfo::seal_set_code_hash(1)
                    .saturating_sub(T::WeightInfo::seal_set_code_hash(0))),
                set_storage_per_new_byte: (T::WeightInfo::seal_set_storage_per_new_byte(1)
                    .saturating_sub(T::WeightInfo::seal_set_storage_per_new_byte(0))),
                set_storage_per_old_byte: (T::WeightInfo::seal_set_storage_per_old_byte(1)
                    .saturating_sub(T::WeightInfo::seal_set_storage_per_old_byte(0))),
                clear_storage: (T::WeightInfo::seal_clear_storage(1)
                    .saturating_sub(T::WeightInfo::seal_clear_storage(0))),
                clear_storage_per_byte: (T::WeightInfo::seal_clear_storage_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_clear_storage_per_byte(0))),
                contains_storage: (T::WeightInfo::seal_contains_storage(1)
                    .saturating_sub(T::WeightInfo::seal_contains_storage(0))),
                contains_storage_per_byte: (T::WeightInfo::seal_contains_storage_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_contains_storage_per_byte(0))),
                get_storage: (T::WeightInfo::seal_get_storage(1)
                    .saturating_sub(T::WeightInfo::seal_get_storage(0))),
                get_storage_per_byte: (T::WeightInfo::seal_get_storage_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_get_storage_per_byte(0))),
                take_storage: (T::WeightInfo::seal_take_storage(1)
                    .saturating_sub(T::WeightInfo::seal_take_storage(0))),
                take_storage_per_byte: (T::WeightInfo::seal_take_storage_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_take_storage_per_byte(0))),
                transfer: (T::WeightInfo::seal_transfer(1)
                    .saturating_sub(T::WeightInfo::seal_transfer(0))),
                call: (T::WeightInfo::seal_call(1).saturating_sub(T::WeightInfo::seal_call(0))),
                delegate_call: (T::WeightInfo::seal_delegate_call(1)
                    .saturating_sub(T::WeightInfo::seal_delegate_call(0))),
                call_transfer_surcharge: (T::WeightInfo::seal_call_per_transfer_clone_byte(1, 0)
                    .saturating_sub(T::WeightInfo::seal_call_per_transfer_clone_byte(0, 0))),
                call_per_cloned_byte: (T::WeightInfo::seal_call_per_transfer_clone_byte(0, 1)
                    .saturating_sub(T::WeightInfo::seal_call_per_transfer_clone_byte(0, 0))),
                instantiate: (T::WeightInfo::seal_instantiate(1)
                    .saturating_sub(T::WeightInfo::seal_instantiate(0))),
                instantiate_transfer_surcharge:
                    (T::WeightInfo::seal_instantiate_per_transfer_input_salt_byte(1, 0, 0)
                        .saturating_sub(
                            T::WeightInfo::seal_instantiate_per_transfer_input_salt_byte(0, 0, 0),
                        )),
                instantiate_per_input_byte:
                    (T::WeightInfo::seal_instantiate_per_transfer_input_salt_byte(0, 1, 0)
                        .saturating_sub(
                            T::WeightInfo::seal_instantiate_per_transfer_input_salt_byte(0, 0, 0),
                        )),
                instantiate_per_salt_byte:
                    (T::WeightInfo::seal_instantiate_per_transfer_input_salt_byte(0, 0, 1)
                        .saturating_sub(
                            T::WeightInfo::seal_instantiate_per_transfer_input_salt_byte(0, 0, 0),
                        )),
                hash_sha2_256: (T::WeightInfo::seal_hash_sha2_256(1)
                    .saturating_sub(T::WeightInfo::seal_hash_sha2_256(0))),
                hash_sha2_256_per_byte: (T::WeightInfo::seal_hash_sha2_256_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_hash_sha2_256_per_byte(0))),
                hash_keccak_256: (T::WeightInfo::seal_hash_keccak_256(1)
                    .saturating_sub(T::WeightInfo::seal_hash_keccak_256(0))),
                hash_keccak_256_per_byte: (T::WeightInfo::seal_hash_keccak_256_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_hash_keccak_256_per_byte(0))),
                hash_blake2_256: (T::WeightInfo::seal_hash_blake2_256(1)
                    .saturating_sub(T::WeightInfo::seal_hash_blake2_256(0))),
                hash_blake2_256_per_byte: (T::WeightInfo::seal_hash_blake2_256_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_hash_blake2_256_per_byte(0))),
                hash_blake2_128: (T::WeightInfo::seal_hash_blake2_128(1)
                    .saturating_sub(T::WeightInfo::seal_hash_blake2_128(0))),
                hash_blake2_128_per_byte: (T::WeightInfo::seal_hash_blake2_128_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_hash_blake2_128_per_byte(0))),
                ecdsa_recover: (T::WeightInfo::seal_ecdsa_recover(1)
                    .saturating_sub(T::WeightInfo::seal_ecdsa_recover(0))),
                sr25519_verify: (T::WeightInfo::seal_sr25519_verify(1)
                    .saturating_sub(T::WeightInfo::seal_sr25519_verify(0))),
                sr25519_verify_per_byte: (T::WeightInfo::seal_sr25519_verify_per_byte(1)
                    .saturating_sub(T::WeightInfo::seal_sr25519_verify_per_byte(0))),
                ecdsa_to_eth_address: (T::WeightInfo::seal_ecdsa_to_eth_address(1)
                    .saturating_sub(T::WeightInfo::seal_ecdsa_to_eth_address(0))),
                reentrance_count: (T::WeightInfo::seal_reentrance_count(1)
                    .saturating_sub(T::WeightInfo::seal_reentrance_count(0))),
                account_reentrance_count: (T::WeightInfo::seal_account_reentrance_count(1)
                    .saturating_sub(T::WeightInfo::seal_account_reentrance_count(0))),
                instantiation_nonce: (T::WeightInfo::seal_instantiation_nonce(1)
                    .saturating_sub(T::WeightInfo::seal_instantiation_nonce(0))),
                _phantom: PhantomData,
            }
        }
    }
    struct ScheduleRules<'a, T: Config> {
        schedule: &'a Schedule<T>,
        determinism: Determinism,
    }
    impl<T: Config> Schedule<T> {
        pub(crate) fn rules(&self, determinism: Determinism) -> impl gas_metering::Rules + '_ {
            ScheduleRules {
                schedule: self,
                determinism,
            }
        }
    }
    impl<'a, T: Config> gas_metering::Rules for ScheduleRules<'a, T> {
        fn instruction_cost(&self, instruction: &elements::Instruction) -> Option<u32> {
            use self::elements::Instruction::*;
            let w = &self.schedule.instruction_weights;
            let weight = match *instruction {
                End | Unreachable | Return | Else => 0,
                I32Const(_) | I64Const(_) | Block(_) | Loop(_) | Nop | Drop => w.i64const,
                I32Load(_, _)
                | I32Load8S(_, _)
                | I32Load8U(_, _)
                | I32Load16S(_, _)
                | I32Load16U(_, _)
                | I64Load(_, _)
                | I64Load8S(_, _)
                | I64Load8U(_, _)
                | I64Load16S(_, _)
                | I64Load16U(_, _)
                | I64Load32S(_, _)
                | I64Load32U(_, _) => w.i64load,
                I32Store(_, _)
                | I32Store8(_, _)
                | I32Store16(_, _)
                | I64Store(_, _)
                | I64Store8(_, _)
                | I64Store16(_, _)
                | I64Store32(_, _) => w.i64store,
                Select => w.select,
                If(_) => w.r#if,
                Br(_) => w.br,
                BrIf(_) => w.br_if,
                Call(_) => w.call,
                GetLocal(_) => w.local_get,
                SetLocal(_) => w.local_set,
                TeeLocal(_) => w.local_tee,
                GetGlobal(_) => w.global_get,
                SetGlobal(_) => w.global_set,
                CurrentMemory(_) => w.memory_current,
                GrowMemory(_) => w.memory_grow,
                CallIndirect(_, _) => w.call_indirect,
                BrTable(ref data) => w
                    .br_table
                    .saturating_add(w.br_table_per_entry.saturating_mul(data.table.len() as u32)),
                I32Clz | I64Clz => w.i64clz,
                I32Ctz | I64Ctz => w.i64ctz,
                I32Popcnt | I64Popcnt => w.i64popcnt,
                I32Eqz | I64Eqz => w.i64eqz,
                I64ExtendSI32 => w.i64extendsi32,
                I64ExtendUI32 => w.i64extendui32,
                I32WrapI64 => w.i32wrapi64,
                I32Eq | I64Eq => w.i64eq,
                I32Ne | I64Ne => w.i64ne,
                I32LtS | I64LtS => w.i64lts,
                I32LtU | I64LtU => w.i64ltu,
                I32GtS | I64GtS => w.i64gts,
                I32GtU | I64GtU => w.i64gtu,
                I32LeS | I64LeS => w.i64les,
                I32LeU | I64LeU => w.i64leu,
                I32GeS | I64GeS => w.i64ges,
                I32GeU | I64GeU => w.i64geu,
                I32Add | I64Add => w.i64add,
                I32Sub | I64Sub => w.i64sub,
                I32Mul | I64Mul => w.i64mul,
                I32DivS | I64DivS => w.i64divs,
                I32DivU | I64DivU => w.i64divu,
                I32RemS | I64RemS => w.i64rems,
                I32RemU | I64RemU => w.i64remu,
                I32And | I64And => w.i64and,
                I32Or | I64Or => w.i64or,
                I32Xor | I64Xor => w.i64xor,
                I32Shl | I64Shl => w.i64shl,
                I32ShrS | I64ShrS => w.i64shrs,
                I32ShrU | I64ShrU => w.i64shru,
                I32Rotl | I64Rotl => w.i64rotl,
                I32Rotr | I64Rotr => w.i64rotr,
                _ if (match self.determinism {
                    Determinism::Relaxed => true,
                    _ => false,
                }) && w.fallback > 0 =>
                {
                    w.fallback
                }
                _ => return None,
            };
            Some(weight)
        }
        fn memory_grow_cost(&self) -> gas_metering::MemoryGrowCost {
            gas_metering::MemoryGrowCost::Free
        }
        fn call_per_local_cost(&self) -> u32 {
            self.schedule.instruction_weights.call_per_local
        }
    }
}
mod storage {
    //! This module contains routines for accessing and altering a contract related state.
    pub mod meter {
        //! This module contains functions to meter the storage deposit.
        use crate::{
            storage::{ContractInfo, DepositAccount},
            BalanceOf, Config, Error, Inspect, Origin, Pallet, System,
        };
        use codec::Encode;
        use frame_support::{
            dispatch::{fmt::Debug, DispatchError},
            ensure,
            traits::{
                tokens::{Fortitude::Polite, Preservation::Protect, WithdrawConsequence},
                Currency, ExistenceRequirement, Get,
            },
            DefaultNoBound, RuntimeDebugNoBound,
        };
        use pallet_contracts_primitives::StorageDeposit as Deposit;
        use sp_runtime::{
            traits::{Saturating, Zero},
            FixedPointNumber, FixedU128,
        };
        use sp_std::{marker::PhantomData, vec::Vec};
        /// Deposit that uses the native currency's balance type.
        pub type DepositOf<T> = Deposit<BalanceOf<T>>;
        /// A production root storage meter that actually charges from its origin.
        pub type Meter<T> = RawMeter<T, ReservingExt, Root>;
        /// A production nested storage meter that actually charges from its origin.
        pub type NestedMeter<T> = RawMeter<T, ReservingExt, Nested>;
        /// A production storage meter that actually charges from its origin.
        ///
        /// This can be used where we want to be generic over the state (Root vs. Nested).
        pub type GenericMeter<T, S> = RawMeter<T, ReservingExt, S>;
        /// A trait that allows to decouple the metering from the charging of balance.
        ///
        /// This mostly exists for testing so that the charging can be mocked.
        pub trait Ext<T: Config> {
            /// This checks whether `origin` is able to afford the storage deposit limit.
            ///
            /// It is necessary to do this check beforehand so that the charge won't fail later on.
            ///
            /// `origin`: The origin of the call stack from which is responsible for putting down a deposit.
            /// `limit`: The limit with which the meter was constructed.
            /// `min_leftover`: How much `free_balance` in addition to the existential deposit (ed) should
            /// be left inside the `origin` account.
            ///
            /// Returns the limit that should be used by the meter. If origin can't afford the `limit`
            /// it returns `Err`.
            fn check_limit(
                origin: &T::AccountId,
                limit: Option<BalanceOf<T>>,
                min_leftover: BalanceOf<T>,
            ) -> Result<BalanceOf<T>, DispatchError>;
            /// This is called to inform the implementer that some balance should be charged due to
            /// some interaction of the `origin` with a `contract`.
            ///
            /// The balance transfer can either flow from `origin` to `deposit_account` or the other way
            /// around depending on whether `amount` constitutes a `Charge` or a `Refund`.
            /// It is guaranteed that this succeeds because no more balance than returned by
            /// `check_limit` is ever charged. This is why this function is infallible.
            /// `terminated` designates whether the `contract` was terminated.
            fn charge(
                origin: &T::AccountId,
                deposit_account: &DepositAccount<T>,
                amount: &DepositOf<T>,
                terminated: bool,
            ) -> Result<(), DispatchError>;
        }
        /// This [`Ext`] is used for actual on-chain execution when balance needs to be charged.
        ///
        /// It uses [`ReservableCurrency`] in order to do accomplish the reserves.
        pub enum ReservingExt {}
        /// Used to implement a type state pattern for the meter.
        ///
        /// It is sealed and cannot be implemented outside of this module.
        pub trait State: private::Sealed {}
        /// State parameter that constitutes a meter that is in its root state.
        pub struct Root;
        #[automatically_derived]
        impl ::core::default::Default for Root {
            #[inline]
            fn default() -> Root {
                Root {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Root {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "Root")
            }
        }
        /// State parameter that constitutes a meter that is in its nested state.
        /// Its value indicates whether the nested meter has its own limit.
        pub enum Nested {
            #[default]
            DerivedLimit,
            OwnLimit,
        }
        const _: () = {
            impl core::default::Default for Nested {
                fn default() -> Self {
                    Self::DerivedLimit
                }
            }
        };
        const _: () = {
            impl core::fmt::Debug for Nested {
                fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                    match *self {
                        Self::DerivedLimit => fmt.write_str("Nested::DerivedLimit"),
                        Self::OwnLimit => fmt.write_str("Nested::OwnLimit"),
                    }
                }
            }
        };
        impl State for Root {}
        impl State for Nested {}
        /// A type that allows the metering of consumed or freed storage of a single contract call stack.
        pub struct RawMeter<T: Config, E, S: State + Default + Debug> {
            /// The limit of how much balance this meter is allowed to consume.
            limit: BalanceOf<T>,
            /// The amount of balance that was used in this meter and all of its already absorbed children.
            total_deposit: DepositOf<T>,
            /// The amount of storage changes that were recorded in this meter alone.
            own_contribution: Contribution<T>,
            /// List of charges that should be applied at the end of a contract stack execution.
            ///
            /// We only have one charge per contract hence the size of this vector is
            /// limited by the maximum call depth.
            charges: Vec<Charge<T>>,
            /// We store the nested state to determine if it has a special limit for sub-call.
            nested: S,
            /// Type parameter only used in impls.
            _phantom: PhantomData<E>,
        }
        const _: () = {
            impl<T: Config, E, S: State + Default + Debug> core::default::Default for RawMeter<T, E, S> {
                fn default() -> Self {
                    Self {
                        limit: core::default::Default::default(),
                        total_deposit: core::default::Default::default(),
                        own_contribution: core::default::Default::default(),
                        charges: core::default::Default::default(),
                        nested: core::default::Default::default(),
                        _phantom: core::default::Default::default(),
                    }
                }
            }
        };
        const _: () = {
            impl<T: Config, E, S: State + Default + Debug> core::fmt::Debug for RawMeter<T, E, S> {
                fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                    fmt.debug_struct("RawMeter")
                        .field("limit", &self.limit)
                        .field("total_deposit", &self.total_deposit)
                        .field("own_contribution", &self.own_contribution)
                        .field("charges", &self.charges)
                        .field("nested", &self.nested)
                        .field("_phantom", &self._phantom)
                        .finish()
                }
            }
        };
        /// This type is used to describe a storage change when charging from the meter.
        pub struct Diff {
            /// How many bytes were added to storage.
            pub bytes_added: u32,
            /// How many bytes were removed from storage.
            pub bytes_removed: u32,
            /// How many storage items were added to storage.
            pub items_added: u32,
            /// How many storage items were removed from storage.
            pub items_removed: u32,
        }
        #[automatically_derived]
        impl ::core::default::Default for Diff {
            #[inline]
            fn default() -> Diff {
                Diff {
                    bytes_added: ::core::default::Default::default(),
                    bytes_removed: ::core::default::Default::default(),
                    items_added: ::core::default::Default::default(),
                    items_removed: ::core::default::Default::default(),
                }
            }
        }
        const _: () = {
            impl core::fmt::Debug for Diff {
                fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                    fmt.debug_struct("Diff")
                        .field("bytes_added", &self.bytes_added)
                        .field("bytes_removed", &self.bytes_removed)
                        .field("items_added", &self.items_added)
                        .field("items_removed", &self.items_removed)
                        .finish()
                }
            }
        };
        impl Diff {
            /// Calculate how much of a charge or refund results from applying the diff and store it
            /// in the passed `info` if any.
            ///
            /// # Note
            ///
            /// In case `None` is passed for `info` only charges are calculated. This is because refunds
            /// are calculated pro rata of the existing storage within a contract and hence need extract
            /// this information from the passed `info`.
            pub fn update_contract<T: Config>(
                &self,
                info: Option<&mut ContractInfo<T>>,
            ) -> DepositOf<T> {
                let per_byte = T::DepositPerByte::get();
                let per_item = T::DepositPerItem::get();
                let bytes_added = self.bytes_added.saturating_sub(self.bytes_removed);
                let items_added = self.items_added.saturating_sub(self.items_removed);
                let mut bytes_deposit =
                    Deposit::Charge(per_byte.saturating_mul((bytes_added).into()));
                let mut items_deposit =
                    Deposit::Charge(per_item.saturating_mul((items_added).into()));
                let info = if let Some(info) = info {
                    info
                } else {
                    if true {
                        match (&self.bytes_removed, &0) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    };
                    if true {
                        match (&self.items_removed, &0) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    };
                    return bytes_deposit.saturating_add(&items_deposit);
                };
                let bytes_removed = self.bytes_removed.saturating_sub(self.bytes_added);
                let items_removed = self.items_removed.saturating_sub(self.items_added);
                let ratio = FixedU128::checked_from_rational(bytes_removed, info.storage_bytes)
                    .unwrap_or_default()
                    .min(FixedU128::from_u32(1));
                bytes_deposit = bytes_deposit.saturating_add(&Deposit::Refund(
                    ratio.saturating_mul_int(info.storage_byte_deposit),
                ));
                let ratio = FixedU128::checked_from_rational(items_removed, info.storage_items)
                    .unwrap_or_default()
                    .min(FixedU128::from_u32(1));
                items_deposit = items_deposit.saturating_add(&Deposit::Refund(
                    ratio.saturating_mul_int(info.storage_item_deposit),
                ));
                info.storage_bytes = info
                    .storage_bytes
                    .saturating_add(bytes_added)
                    .saturating_sub(bytes_removed);
                info.storage_items = info
                    .storage_items
                    .saturating_add(items_added)
                    .saturating_sub(items_removed);
                match &bytes_deposit {
                    Deposit::Charge(amount) => {
                        info.storage_byte_deposit =
                            info.storage_byte_deposit.saturating_add(*amount)
                    }
                    Deposit::Refund(amount) => {
                        info.storage_byte_deposit =
                            info.storage_byte_deposit.saturating_sub(*amount)
                    }
                }
                match &items_deposit {
                    Deposit::Charge(amount) => {
                        info.storage_item_deposit =
                            info.storage_item_deposit.saturating_add(*amount)
                    }
                    Deposit::Refund(amount) => {
                        info.storage_item_deposit =
                            info.storage_item_deposit.saturating_sub(*amount)
                    }
                }
                bytes_deposit.saturating_add(&items_deposit)
            }
        }
        impl Diff {
            fn saturating_add(&self, rhs: &Self) -> Self {
                Self {
                    bytes_added: self.bytes_added.saturating_add(rhs.bytes_added),
                    bytes_removed: self.bytes_removed.saturating_add(rhs.bytes_removed),
                    items_added: self.items_added.saturating_add(rhs.items_added),
                    items_removed: self.items_removed.saturating_add(rhs.items_removed),
                }
            }
        }
        /// Records information to charge or refund a plain account.
        ///
        /// All the charges are deferred to the end of a whole call stack. Reason is that by doing
        /// this we can do all the refunds before doing any charge. This way a plain account can use
        /// more deposit than it has balance as along as it is covered by a refund. This
        /// essentially makes the order of storage changes irrelevant with regard to the deposit system.
        /// The only exception is when a special (tougher) deposit limit is specified for a cross-contract
        /// call. In that case the limit is enforced once the call is returned, rolling it back if
        /// exhausted.
        struct Charge<T: Config> {
            deposit_account: DepositAccount<T>,
            amount: DepositOf<T>,
            terminated: bool,
        }
        const _: () = {
            impl<T: Config> core::fmt::Debug for Charge<T> {
                fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                    fmt.debug_struct("Charge")
                        .field("deposit_account", &self.deposit_account)
                        .field("amount", &self.amount)
                        .field("terminated", &self.terminated)
                        .finish()
                }
            }
        };
        #[automatically_derived]
        impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for Charge<T> {
            #[inline]
            fn clone(&self) -> Charge<T> {
                Charge {
                    deposit_account: ::core::clone::Clone::clone(&self.deposit_account),
                    amount: ::core::clone::Clone::clone(&self.amount),
                    terminated: ::core::clone::Clone::clone(&self.terminated),
                }
            }
        }
        /// Records the storage changes of a storage meter.
        enum Contribution<T: Config> {
            /// The contract the meter belongs to is alive and accumulates changes using a [`Diff`].
            Alive(Diff),
            /// The meter was checked against its limit using [`RawMeter::enforce_limit`] at the end of
            /// its execution. In this process the [`Diff`] was converted into a [`Deposit`].
            Checked(DepositOf<T>),
            /// The contract was terminated. In this process the [`Diff`] was converted into a [`Deposit`]
            /// in order to calculate the refund.
            Terminated(DepositOf<T>),
        }
        const _: () = {
            impl<T: Config> core::fmt::Debug for Contribution<T> {
                fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                    match *self {
                        Self::Alive(ref _0) => {
                            fmt.debug_tuple("Contribution::Alive").field(&_0).finish()
                        }
                        Self::Checked(ref _0) => {
                            fmt.debug_tuple("Contribution::Checked").field(&_0).finish()
                        }
                        Self::Terminated(ref _0) => fmt
                            .debug_tuple("Contribution::Terminated")
                            .field(&_0)
                            .finish(),
                    }
                }
            }
        };
        impl<T: Config> Contribution<T> {
            /// See [`Diff::update_contract`].
            fn update_contract(&self, info: Option<&mut ContractInfo<T>>) -> DepositOf<T> {
                match self {
                    Self::Alive(diff) => diff.update_contract::<T>(info),
                    Self::Terminated(deposit) | Self::Checked(deposit) => deposit.clone(),
                }
            }
        }
        impl<T: Config> Default for Contribution<T> {
            fn default() -> Self {
                Self::Alive(Default::default())
            }
        }
        /// Functions that apply to all states.
        impl<T, E, S> RawMeter<T, E, S>
        where
            T: Config,
            E: Ext<T>,
            S: State + Default + Debug,
        {
            /// Create a new child that has its `limit`.
            /// Passing `0` as the limit is interpreted as to take whatever is remaining from its parent.
            ///
            /// This is called whenever a new subcall is initiated in order to track the storage
            /// usage for this sub call separately. This is necessary because we want to exchange balance
            /// with the current contract we are interacting with.
            pub fn nested(&self, limit: BalanceOf<T>) -> RawMeter<T, E, Nested> {
                if true {
                    if !self.is_alive() {
                        ::core::panicking::panic("assertion failed: self.is_alive()")
                    };
                };
                let limit = self.available().min(limit);
                if limit.is_zero() {
                    RawMeter {
                        limit: self.available(),
                        ..Default::default()
                    }
                } else {
                    RawMeter {
                        limit,
                        nested: Nested::OwnLimit,
                        ..Default::default()
                    }
                }
            }
            /// Absorb a child that was spawned to handle a sub call.
            ///
            /// This should be called whenever a sub call comes to its end and it is **not** reverted.
            /// This does the actual balance transfer from/to `origin` and `deposit_account` based on the
            /// overall storage consumption of the call. It also updates the supplied contract info.
            ///
            /// In case a contract reverted the child meter should just be dropped in order to revert
            /// any changes it recorded.
            ///
            /// # Parameters
            ///
            /// - `absorbed`: The child storage meter that should be absorbed.
            /// - `origin`: The origin that spawned the original root meter.
            /// - `deposit_account`: The contract's deposit account that this sub call belongs to.
            /// - `info`: The info of the contract in question. `None` if the contract was terminated.
            pub fn absorb(
                &mut self,
                absorbed: RawMeter<T, E, Nested>,
                deposit_account: DepositAccount<T>,
                info: Option<&mut ContractInfo<T>>,
            ) {
                let own_deposit = absorbed.own_contribution.update_contract(info);
                self.total_deposit = self
                    .total_deposit
                    .saturating_add(&absorbed.total_deposit)
                    .saturating_add(&own_deposit);
                self.charges.extend_from_slice(&absorbed.charges);
                if !own_deposit.is_zero() {
                    self.charges.push(Charge {
                        deposit_account,
                        amount: own_deposit,
                        terminated: absorbed.is_terminated(),
                    });
                }
            }
            /// The amount of balance that is still available from the original `limit`.
            fn available(&self) -> BalanceOf<T> {
                self.total_deposit.available(&self.limit)
            }
            /// True if the contract is alive.
            fn is_alive(&self) -> bool {
                match self.own_contribution {
                    Contribution::Alive(_) => true,
                    _ => false,
                }
            }
            /// True if the contract is terminated.
            fn is_terminated(&self) -> bool {
                match self.own_contribution {
                    Contribution::Terminated(_) => true,
                    _ => false,
                }
            }
        }
        /// Functions that only apply to the root state.
        impl<T, E> RawMeter<T, E, Root>
        where
            T: Config,
            E: Ext<T>,
        {
            /// Create new storage meter for the specified `origin` and `limit`.
            ///
            /// This tries to [`Ext::check_limit`] on `origin` and fails if this is not possible.
            pub fn new(
                origin: &Origin<T>,
                limit: Option<BalanceOf<T>>,
                min_leftover: BalanceOf<T>,
            ) -> Result<Self, DispatchError> {
                return match origin {
                    Origin::Root => Ok(Self {
                        limit: limit.unwrap_or(T::DefaultDepositLimit::get()),
                        ..Default::default()
                    }),
                    Origin::Signed(o) => {
                        let limit = E::check_limit(o, limit, min_leftover)?;
                        Ok(Self {
                            limit,
                            ..Default::default()
                        })
                    }
                };
            }
            /// The total amount of deposit that should change hands as result of the execution
            /// that this meter was passed into. This will also perform all the charges accumulated
            /// in the whole contract stack.
            ///
            /// This drops the root meter in order to make sure it is only called when the whole
            /// execution did finish.
            pub fn try_into_deposit(
                self,
                origin: &Origin<T>,
            ) -> Result<DepositOf<T>, DispatchError> {
                let origin = match origin {
                    Origin::Root => return Ok(Deposit::Charge(Zero::zero())),
                    Origin::Signed(o) => o,
                };
                for charge in self.charges.iter().filter(|c| match c.amount {
                    Deposit::Refund(_) => true,
                    _ => false,
                }) {
                    E::charge(
                        origin,
                        &charge.deposit_account,
                        &charge.amount,
                        charge.terminated,
                    )?;
                }
                for charge in self.charges.iter().filter(|c| match c.amount {
                    Deposit::Charge(_) => true,
                    _ => false,
                }) {
                    E::charge(
                        origin,
                        &charge.deposit_account,
                        &charge.amount,
                        charge.terminated,
                    )?;
                }
                Ok(self.total_deposit)
            }
        }
        /// Functions that only apply to the nested state.
        impl<T, E> RawMeter<T, E, Nested>
        where
            T: Config,
            E: Ext<T>,
        {
            /// Charge `diff` from the meter.
            pub fn charge(&mut self, diff: &Diff) {
                match &mut self.own_contribution {
                    Contribution::Alive(own) => *own = own.saturating_add(diff),
                    _ => ::core::panicking::panic_fmt(format_args!(
                        "Charge is never called after termination; qed"
                    )),
                };
            }
            /// Charge from `origin` a storage deposit for contract instantiation.
            ///
            /// This immediately transfers the balance in order to create the account.
            pub fn charge_instantiate(
                &mut self,
                origin: &T::AccountId,
                contract: &T::AccountId,
                info: &mut ContractInfo<T>,
            ) -> Result<DepositOf<T>, DispatchError> {
                if true {
                    if !self.is_alive() {
                        ::core::panicking::panic("assertion failed: self.is_alive()")
                    };
                };
                let ed = Pallet::<T>::min_balance();
                let mut deposit = Diff {
                    bytes_added: info.encoded_size() as u32,
                    items_added: 1,
                    ..Default::default()
                }
                .update_contract::<T>(None);
                deposit = deposit
                    .max(Deposit::Charge(ed))
                    .saturating_add(&Deposit::Charge(ed));
                if deposit.charge_or_zero() > self.limit {
                    return Err(<Error<T>>::StorageDepositLimitExhausted.into());
                }
                self.total_deposit = deposit.clone();
                info.storage_base_deposit = deposit.charge_or_zero();
                E::charge(
                    origin,
                    info.deposit_account(),
                    &deposit.saturating_sub(&Deposit::Charge(ed)),
                    false,
                )?;
                System::<T>::inc_consumers(info.deposit_account())?;
                T::Currency::transfer(origin, contract, ed, ExistenceRequirement::KeepAlive)?;
                System::<T>::inc_consumers(contract)?;
                Ok(deposit)
            }
            /// Call to tell the meter that the currently executing contract was executed.
            ///
            /// This will manipulate the meter so that all storage deposit accumulated in
            /// `contract_info` will be refunded to the `origin` of the meter.
            pub fn terminate(&mut self, info: &ContractInfo<T>) {
                if true {
                    if !self.is_alive() {
                        ::core::panicking::panic("assertion failed: self.is_alive()")
                    };
                };
                self.own_contribution =
                    Contribution::Terminated(Deposit::Refund(info.total_deposit()));
            }
            /// [`Self::charge`] does not enforce the storage limit since we want to do this check as late
            /// as possible to allow later refunds to offset earlier charges.
            ///
            /// # Note
            ///
            /// We normally need to call this **once** for every call stack and not for every cross contract
            /// call. However, if a dedicated limit is specified for a sub-call, this needs to be called
            /// once the sub-call has returned. For this, the [`Self::enforce_subcall_limit`] wrapper is
            /// used.
            pub fn enforce_limit(
                &mut self,
                info: Option<&mut ContractInfo<T>>,
            ) -> Result<(), DispatchError> {
                let deposit = self.own_contribution.update_contract(info);
                let total_deposit = self.total_deposit.saturating_add(&deposit);
                if self.is_alive() {
                    self.own_contribution = Contribution::Checked(deposit);
                }
                if let Deposit::Charge(amount) = total_deposit {
                    if amount > self.limit {
                        return Err(<Error<T>>::StorageDepositLimitExhausted.into());
                    }
                }
                Ok(())
            }
            /// This is a wrapper around [`Self::enforce_limit`] to use on the exit from a sub-call to
            /// enforce its special limit if needed.
            pub fn enforce_subcall_limit(
                &mut self,
                info: Option<&mut ContractInfo<T>>,
            ) -> Result<(), DispatchError> {
                match self.nested {
                    Nested::OwnLimit => self.enforce_limit(info),
                    Nested::DerivedLimit => Ok(()),
                }
            }
        }
        impl<T: Config> Ext<T> for ReservingExt {
            fn check_limit(
                origin: &T::AccountId,
                limit: Option<BalanceOf<T>>,
                min_leftover: BalanceOf<T>,
            ) -> Result<BalanceOf<T>, DispatchError> {
                let max = T::Currency::reducible_balance(origin, Protect, Polite)
                    .saturating_sub(min_leftover)
                    .saturating_sub(Pallet::<T>::min_balance());
                let default = max.min(T::DefaultDepositLimit::get());
                let limit = limit.unwrap_or(default);
                {
                    if !(limit <= max
                        && match T::Currency::can_withdraw(origin, limit) {
                            WithdrawConsequence::Success => true,
                            _ => false,
                        })
                    {
                        {
                            return Err(<Error<T>>::StorageDepositNotEnoughFunds.into());
                        };
                    }
                };
                Ok(limit)
            }
            fn charge(
                origin: &T::AccountId,
                deposit_account: &DepositAccount<T>,
                amount: &DepositOf<T>,
                terminated: bool,
            ) -> Result<(), DispatchError> {
                match amount {
                    Deposit::Charge(amount) => T::Currency::transfer(
                        origin,
                        deposit_account,
                        *amount,
                        ExistenceRequirement::KeepAlive,
                    ),
                    Deposit::Refund(amount) => {
                        if terminated {
                            System::<T>::dec_consumers(&deposit_account);
                        }
                        T::Currency::transfer(
                            deposit_account,
                            origin,
                            *amount,
                            ExistenceRequirement::AllowDeath,
                        )
                    }
                }
            }
        }
        mod private {
            pub trait Sealed {}
            impl Sealed for super::Root {}
            impl Sealed for super::Nested {}
        }
    }
    use crate::{
        exec::{AccountIdOf, Key},
        weights::WeightInfo,
        AddressGenerator, BalanceOf, CodeHash, Config, ContractInfoOf, DeletionQueue,
        DeletionQueueCounter, Error, Pallet, TrieId, SENTINEL,
    };
    use codec::{Decode, Encode, MaxEncodedLen};
    use frame_support::{
        dispatch::DispatchError,
        storage::child::{self, ChildInfo},
        weights::Weight,
        DefaultNoBound, RuntimeDebugNoBound,
    };
    use scale_info::TypeInfo;
    use sp_io::KillStorageResult;
    use sp_runtime::{
        traits::{Hash, Saturating, Zero},
        RuntimeDebug,
    };
    use sp_std::{marker::PhantomData, ops::Deref, prelude::*};
    /// Information for managing an account and its sub trie abstraction.
    /// This is the required info to cache for an account.
    /// 用于管理帐户及其子三重抽象的信息。这是缓存帐户所需的信息。
    #[scale_info(skip_type_params(T))]
    pub struct ContractInfo<T: Config> {
        /// Unique ID for the subtree encoded as a bytes vector.
        pub trie_id: TrieId,
        /// The account that holds this contracts storage deposit.
        ///
        /// This is held in a separate account to prevent the contract from spending it.
        deposit_account: DepositAccount<T>,
        /// The code associated with a given account.
        pub code_hash: CodeHash<T>,
        /// How many bytes of storage are accumulated in this contract's child trie.
        storage_bytes: u32,
        /// How many items of storage are accumulated in this contract's child trie.
        storage_items: u32,
        /// This records to how much deposit the accumulated `storage_bytes` amount to.
        pub storage_byte_deposit: BalanceOf<T>,
        /// This records to how much deposit the accumulated `storage_items` amount to.
        storage_item_deposit: BalanceOf<T>,
        /// This records how much deposit is put down in order to pay for the contract itself.
        ///
        /// We need to store this information separately so it is not used when calculating any refunds
        /// since the base deposit can only ever be refunded on contract termination.
        storage_base_deposit: BalanceOf<T>,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for ContractInfo<T>
        where
            DepositAccount<T>: ::codec::Encode,
            DepositAccount<T>: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.trie_id, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.deposit_account, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.code_hash, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.storage_bytes, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.storage_items, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.storage_byte_deposit, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.storage_item_deposit, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.storage_base_deposit, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for ContractInfo<T>
        where
            DepositAccount<T>: ::codec::Encode,
            DepositAccount<T>: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for ContractInfo<T>
        where
            DepositAccount<T>: ::codec::Decode,
            DepositAccount<T>: ::codec::Decode,
            CodeHash<T>: ::codec::Decode,
            CodeHash<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(ContractInfo::<T> {
                    trie_id: {
                        let __codec_res_edqy =
                            <TrieId as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `ContractInfo::trie_id`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    deposit_account: {
                        let __codec_res_edqy =
                            <DepositAccount<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `ContractInfo::deposit_account`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    code_hash: {
                        let __codec_res_edqy =
                            <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `ContractInfo::code_hash`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    storage_bytes: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `ContractInfo::storage_bytes`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    storage_items: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `ContractInfo::storage_items`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    storage_byte_deposit: {
                        let __codec_res_edqy =
                            <BalanceOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `ContractInfo::storage_byte_deposit`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    storage_item_deposit: {
                        let __codec_res_edqy =
                            <BalanceOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `ContractInfo::storage_item_deposit`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    storage_base_deposit: {
                        let __codec_res_edqy =
                            <BalanceOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `ContractInfo::storage_base_deposit`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for ContractInfo<T> {
        #[inline]
        fn clone(&self) -> ContractInfo<T> {
            ContractInfo {
                trie_id: ::core::clone::Clone::clone(&self.trie_id),
                deposit_account: ::core::clone::Clone::clone(&self.deposit_account),
                code_hash: ::core::clone::Clone::clone(&self.code_hash),
                storage_bytes: ::core::clone::Clone::clone(&self.storage_bytes),
                storage_items: ::core::clone::Clone::clone(&self.storage_items),
                storage_byte_deposit: ::core::clone::Clone::clone(&self.storage_byte_deposit),
                storage_item_deposit: ::core::clone::Clone::clone(&self.storage_item_deposit),
                storage_base_deposit: ::core::clone::Clone::clone(&self.storage_base_deposit),
            }
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralPartialEq for ContractInfo<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for ContractInfo<T> {
        #[inline]
        fn eq(&self, other: &ContractInfo<T>) -> bool {
            self.trie_id == other.trie_id
                && self.deposit_account == other.deposit_account
                && self.code_hash == other.code_hash
                && self.storage_bytes == other.storage_bytes
                && self.storage_items == other.storage_items
                && self.storage_byte_deposit == other.storage_byte_deposit
                && self.storage_item_deposit == other.storage_item_deposit
                && self.storage_base_deposit == other.storage_base_deposit
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralEq for ContractInfo<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for ContractInfo<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TrieId>;
            let _: ::core::cmp::AssertParamIsEq<DepositAccount<T>>;
            let _: ::core::cmp::AssertParamIsEq<CodeHash<T>>;
            let _: ::core::cmp::AssertParamIsEq<u32>;
            let _: ::core::cmp::AssertParamIsEq<BalanceOf<T>>;
            let _: ::core::cmp::AssertParamIsEq<BalanceOf<T>>;
            let _: ::core::cmp::AssertParamIsEq<BalanceOf<T>>;
        }
    }
    impl<T: Config> core::fmt::Debug for ContractInfo<T>
    where
        T: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_struct("ContractInfo")
                .field("trie_id", &self.trie_id)
                .field("deposit_account", &self.deposit_account)
                .field("code_hash", &self.code_hash)
                .field("storage_bytes", &self.storage_bytes)
                .field("storage_items", &self.storage_items)
                .field("storage_byte_deposit", &self.storage_byte_deposit)
                .field("storage_item_deposit", &self.storage_item_deposit)
                .field("storage_base_deposit", &self.storage_base_deposit)
                .finish()
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for ContractInfo<T>
        where
            DepositAccount<T>: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("ContractInfo" , "pallet_contracts::storage")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["Information for managing an account and its sub trie abstraction." , "This is the required info to cache for an account."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < TrieId > () . name ("trie_id") . type_name ("TrieId") . docs (& ["Unique ID for the subtree encoded as a bytes vector."])) . field (| f | f . ty :: < DepositAccount < T > > () . name ("deposit_account") . type_name ("DepositAccount<T>") . docs (& ["The account that holds this contracts storage deposit." , "" , "This is held in a separate account to prevent the contract from spending it."])) . field (| f | f . ty :: < CodeHash < T > > () . name ("code_hash") . type_name ("CodeHash<T>") . docs (& ["The code associated with a given account."])) . field (| f | f . ty :: < u32 > () . name ("storage_bytes") . type_name ("u32") . docs (& ["How many bytes of storage are accumulated in this contract's child trie."])) . field (| f | f . ty :: < u32 > () . name ("storage_items") . type_name ("u32") . docs (& ["How many items of storage are accumulated in this contract's child trie."])) . field (| f | f . ty :: < BalanceOf < T > > () . name ("storage_byte_deposit") . type_name ("BalanceOf<T>") . docs (& ["This records to how much deposit the accumulated `storage_bytes` amount to."])) . field (| f | f . ty :: < BalanceOf < T > > () . name ("storage_item_deposit") . type_name ("BalanceOf<T>") . docs (& ["This records to how much deposit the accumulated `storage_items` amount to."])) . field (| f | f . ty :: < BalanceOf < T > > () . name ("storage_base_deposit") . type_name ("BalanceOf<T>") . docs (& ["This records how much deposit is put down in order to pay for the contract itself." , "" , "We need to store this information separately so it is not used when calculating any refunds" , "since the base deposit can only ever be refunded on contract termination."])))
            }
        };
    };
    const _: () = {
        impl<T: Config> ::codec::MaxEncodedLen for ContractInfo<T>
        where
            DepositAccount<T>: ::codec::MaxEncodedLen,
            DepositAccount<T>: ::codec::MaxEncodedLen,
            CodeHash<T>: ::codec::MaxEncodedLen,
            CodeHash<T>: ::codec::MaxEncodedLen,
            BalanceOf<T>: ::codec::MaxEncodedLen,
            BalanceOf<T>: ::codec::MaxEncodedLen,
            BalanceOf<T>: ::codec::MaxEncodedLen,
            BalanceOf<T>: ::codec::MaxEncodedLen,
            BalanceOf<T>: ::codec::MaxEncodedLen,
            BalanceOf<T>: ::codec::MaxEncodedLen,
        {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize
                    .saturating_add(<TrieId>::max_encoded_len())
                    .saturating_add(<DepositAccount<T>>::max_encoded_len())
                    .saturating_add(<CodeHash<T>>::max_encoded_len())
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<BalanceOf<T>>::max_encoded_len())
                    .saturating_add(<BalanceOf<T>>::max_encoded_len())
                    .saturating_add(<BalanceOf<T>>::max_encoded_len())
            }
        }
    };
    impl<T: Config> ContractInfo<T> {
        /// Constructs a new contract info **without** writing it to storage.
        ///
        /// This returns an `Err` if an contract with the supplied `account` already exists
        /// in storage.
        pub fn new(
            account: &AccountIdOf<T>,
            nonce: u64,
            code_hash: CodeHash<T>,
        ) -> Result<Self, DispatchError> {
            if <ContractInfoOf<T>>::contains_key(account) {
                return Err(Error::<T>::DuplicateContract.into());
            }
            let trie_id = {
                let buf = (account, nonce).using_encoded(T::Hashing::hash);
                buf.as_ref().to_vec().try_into().expect(
                    "Runtime uses a reasonable hash size. Hence sizeof(T::Hash) <= 128; qed",
                )
            };
            let deposit_account = DepositAccount(T::AddressGenerator::deposit_address(account));
            let contract = Self {
                trie_id,
                deposit_account,
                code_hash,
                storage_bytes: 0,
                storage_items: 0,
                storage_byte_deposit: Zero::zero(),
                storage_item_deposit: Zero::zero(),
                storage_base_deposit: Zero::zero(),
            };
            Ok(contract)
        }
        /// Associated child trie unique id is built from the hash part of the trie id.
        pub fn child_trie_info(&self) -> ChildInfo {
            ChildInfo::new_default(self.trie_id.as_ref())
        }
        /// The deposit paying for the accumulated storage generated within the contract's child trie.
        pub fn extra_deposit(&self) -> BalanceOf<T> {
            self.storage_byte_deposit
                .saturating_add(self.storage_item_deposit)
        }
        /// Same as [`Self::extra_deposit`] but including the base deposit.
        pub fn total_deposit(&self) -> BalanceOf<T> {
            self.extra_deposit()
                .saturating_add(self.storage_base_deposit)
                .saturating_sub(Pallet::<T>::min_balance())
        }
        /// Return the account that storage deposits should be deposited into.
        pub fn deposit_account(&self) -> &DepositAccount<T> {
            &self.deposit_account
        }
        /// Reads a storage kv pair of a contract.
        ///
        /// The read is performed from the `trie_id` only. The `address` is not necessary. If the
        /// contract doesn't store under the given `key` `None` is returned.
        pub fn read(&self, key: &Key<T>) -> Option<Vec<u8>> {
            child::get_raw(&self.child_trie_info(), key.hash().as_slice())
        }
        /// Returns `Some(len)` (in bytes) if a storage item exists at `key`.
        ///
        /// Returns `None` if the `key` wasn't previously set by `set_storage` or
        /// was deleted.
        /// 返回值的长度（以字节为单位），而不读取它。 None 如果不存在。
        pub fn size(&self, key: &Key<T>) -> Option<u32> {
            child::len(&self.child_trie_info(), key.hash().as_slice())
        }
        /// Update a storage entry into a contract's kv storage.
        ///
        /// If the `new_value` is `None` then the kv pair is removed. If `take` is true
        /// a [`WriteOutcome::Taken`] is returned instead of a [`WriteOutcome::Overwritten`].
        ///
        /// This function also records how much storage was created or removed if a `storage_meter`
        /// is supplied. It should only be absent for testing or benchmarking code.
        pub fn write(
            &self,
            key: &Key<T>,
            new_value: Option<Vec<u8>>,
            storage_meter: Option<&mut meter::NestedMeter<T>>,
            take: bool,
        ) -> Result<WriteOutcome, DispatchError> {
            let child_trie_info = &self.child_trie_info();
            let hashed_key = key.hash();
            let (old_len, old_value) = if take {
                let val = child::get_raw(child_trie_info, &hashed_key);
                (val.as_ref().map(|v| v.len() as u32), val)
            } else {
                (child::len(child_trie_info, &hashed_key), None)
            };
            if let Some(storage_meter) = storage_meter {
                let mut diff = meter::Diff::default();
                match (old_len, new_value.as_ref().map(|v| v.len() as u32)) {
                    (Some(old_len), Some(new_len)) => {
                        if new_len > old_len {
                            diff.bytes_added = new_len - old_len;
                        } else {
                            diff.bytes_removed = old_len - new_len;
                        }
                    }
                    (None, Some(new_len)) => {
                        diff.bytes_added = new_len;
                        diff.items_added = 1;
                    }
                    (Some(old_len), None) => {
                        diff.bytes_removed = old_len;
                        diff.items_removed = 1;
                    }
                    (None, None) => (),
                }
                storage_meter.charge(&diff);
            }
            match &new_value {
                Some(new_value) => child::put_raw(child_trie_info, &hashed_key, new_value),
                None => child::kill(child_trie_info, &hashed_key),
            }
            Ok(match (old_len, old_value) {
                (None, _) => WriteOutcome::New,
                (Some(old_len), None) => WriteOutcome::Overwritten(old_len),
                (Some(_), Some(old_value)) => WriteOutcome::Taken(old_value),
            })
        }
        /// Push a contract's trie to the deletion queue for lazy removal.
        ///
        /// You must make sure that the contract is also removed when queuing the trie for deletion.
        pub fn queue_trie_for_deletion(&self) {
            DeletionQueueManager::<T>::load().insert(self.trie_id.clone());
        }
        /// Calculates the weight that is necessary to remove one key from the trie and how many
        /// of those keys can be deleted from the deletion queue given the supplied weight limit.
        pub fn deletion_budget(weight_limit: Weight) -> (Weight, u32) {
            let base_weight = T::WeightInfo::on_process_deletion_queue_batch();
            let weight_per_key = T::WeightInfo::on_initialize_per_trie_key(1)
                - T::WeightInfo::on_initialize_per_trie_key(0);
            let key_budget = weight_limit
                .saturating_sub(base_weight)
                .checked_div_per_component(&weight_per_key)
                .unwrap_or(0) as u32;
            (weight_per_key, key_budget)
        }
        /// Delete as many items from the deletion queue possible within the supplied weight limit.
        ///
        /// It returns the amount of weight used for that task.
        pub fn process_deletion_queue_batch(weight_limit: Weight) -> Weight {
            let mut queue = <DeletionQueueManager<T>>::load();
            if queue.is_empty() {
                return Weight::zero();
            }
            let (weight_per_key, mut remaining_key_budget) = Self::deletion_budget(weight_limit);
            if remaining_key_budget == 0 {
                return weight_limit;
            }
            while remaining_key_budget > 0 {
                let Some (entry) = queue . next () else { break } ;
                #[allow(deprecated)]
                let outcome = child::kill_storage(
                    &ChildInfo::new_default(&entry.trie_id),
                    Some(remaining_key_budget),
                );
                match outcome {
                    KillStorageResult::SomeRemaining(_) => return weight_limit,
                    KillStorageResult::AllRemoved(keys_removed) => {
                        entry.remove();
                        remaining_key_budget = remaining_key_budget.saturating_sub(keys_removed);
                    }
                };
            }
            weight_limit
                .saturating_sub(weight_per_key.saturating_mul(u64::from(remaining_key_budget)))
        }
        /// Returns the code hash of the contract specified by `account` ID.
        pub fn load_code_hash(account: &AccountIdOf<T>) -> Option<CodeHash<T>> {
            <ContractInfoOf<T>>::get(account).map(|i| i.code_hash)
        }
    }
    /// Information about what happened to the pre-existing value when calling [`ContractInfo::write`].
    pub enum WriteOutcome {
        /// No value existed at the specified key.
        New,
        /// A value of the returned length was overwritten.
        Overwritten(u32),
        /// The returned value was taken out of storage before being overwritten.
        ///
        /// This is only returned when specifically requested because it causes additional work
        /// depending on the size of the pre-existing value. When not requested [`Self::Overwritten`]
        /// is returned instead.
        Taken(Vec<u8>),
    }
    impl WriteOutcome {
        /// Extracts the size of the overwritten value or `0` if there
        /// was no value in storage.
        pub fn old_len(&self) -> u32 {
            match self {
                Self::New => 0,
                Self::Overwritten(len) => *len,
                Self::Taken(value) => value.len() as u32,
            }
        }
        /// Extracts the size of the overwritten value or `SENTINEL` if there
        /// was no value in storage.
        ///
        /// # Note
        ///
        /// We cannot use `0` as sentinel value because there could be a zero sized
        /// storage entry which is different from a non existing one.
        pub fn old_len_with_sentinel(&self) -> u32 {
            match self {
                Self::New => SENTINEL,
                Self::Overwritten(len) => *len,
                Self::Taken(value) => value.len() as u32,
            }
        }
    }
    #[scale_info(skip_type_params(T))]
    pub struct DepositAccount<T: Config>(AccountIdOf<T>);
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for DepositAccount<T>
        where
            AccountIdOf<T>: ::codec::Encode,
            AccountIdOf<T>: ::codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
            }
            fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                ::codec::Encode::encode(&&self.0)
            }
            fn using_encoded<R, F: ::core::ops::FnOnce(&[::core::primitive::u8]) -> R>(
                &self,
                f: F,
            ) -> R {
                ::codec::Encode::using_encoded(&&self.0, f)
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for DepositAccount<T>
        where
            AccountIdOf<T>: ::codec::Encode,
            AccountIdOf<T>: ::codec::Encode,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for DepositAccount<T>
        where
            AccountIdOf<T>: ::codec::Decode,
            AccountIdOf<T>: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(DepositAccount::<T>({
                    let __codec_res_edqy =
                        <AccountIdOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `DepositAccount.0`"),
                            )
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                }))
            }
        }
    };
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for DepositAccount<T> {
        #[inline]
        fn clone(&self) -> DepositAccount<T> {
            DepositAccount(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralPartialEq for DepositAccount<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for DepositAccount<T> {
        #[inline]
        fn eq(&self, other: &DepositAccount<T>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<T: Config> ::core::marker::StructuralEq for DepositAccount<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for DepositAccount<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<AccountIdOf<T>>;
        }
    }
    const _: () = {
        impl<T: Config> core::fmt::Debug for DepositAccount<T> {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                fmt.debug_tuple("DepositAccount").field(&self.0).finish()
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for DepositAccount<T>
        where
            AccountIdOf<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(::scale_info::Path::new(
                        "DepositAccount",
                        "pallet_contracts::storage",
                    ))
                    .type_params(<[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::scale_info::TypeParameter::new(
                            "T",
                            ::core::option::Option::None,
                        )]),
                    ))
                    .composite(
                        ::scale_info::build::Fields::unnamed()
                            .field(|f| f.ty::<AccountIdOf<T>>().type_name("AccountIdOf<T>")),
                    )
            }
        };
    };
    const _: () = {
        impl<T: Config> ::codec::MaxEncodedLen for DepositAccount<T>
        where
            AccountIdOf<T>: ::codec::MaxEncodedLen,
            AccountIdOf<T>: ::codec::MaxEncodedLen,
        {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<AccountIdOf<T>>::max_encoded_len())
            }
        }
    };
    impl<T: Config> Deref for DepositAccount<T> {
        type Target = AccountIdOf<T>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    /// Manage the removal of contracts storage that are marked for deletion.
    ///
    /// When a contract is deleted by calling `seal_terminate` it becomes inaccessible
    /// immediately, but the deletion of the storage items it has accumulated is performed
    /// later by pulling the contract from the queue in the `on_idle` hook.
    #[scale_info(skip_type_params(T))]
    pub struct DeletionQueueManager<T: Config> {
        /// Counter used as a key for inserting a new deleted contract in the queue.
        /// The counter is incremented after each insertion.
        insert_counter: u32,
        /// The index used to read the next element to be deleted in the queue.
        /// The counter is incremented after each deletion.
        delete_counter: u32,
        _phantom: PhantomData<T>,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for DeletionQueueManager<T>
        where
            PhantomData<T>: ::codec::Encode,
            PhantomData<T>: ::codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.insert_counter, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.delete_counter, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self._phantom, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for DeletionQueueManager<T>
        where
            PhantomData<T>: ::codec::Encode,
            PhantomData<T>: ::codec::Encode,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for DeletionQueueManager<T>
        where
            PhantomData<T>: ::codec::Decode,
            PhantomData<T>: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(DeletionQueueManager::<T> {
                    insert_counter: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `DeletionQueueManager::insert_counter`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    delete_counter: {
                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(e.chain(
                                    "Could not decode `DeletionQueueManager::delete_counter`",
                                ))
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    _phantom: {
                        let __codec_res_edqy =
                            <PhantomData<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `DeletionQueueManager::_phantom`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for DeletionQueueManager<T>
        where
            PhantomData<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("DeletionQueueManager" , "pallet_contracts::storage")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["Manage the removal of contracts storage that are marked for deletion." , "" , "When a contract is deleted by calling `seal_terminate` it becomes inaccessible" , "immediately, but the deletion of the storage items it has accumulated is performed" , "later by pulling the contract from the queue in the `on_idle` hook."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < u32 > () . name ("insert_counter") . type_name ("u32") . docs (& ["Counter used as a key for inserting a new deleted contract in the queue." , "The counter is incremented after each insertion."])) . field (| f | f . ty :: < u32 > () . name ("delete_counter") . type_name ("u32") . docs (& ["The index used to read the next element to be deleted in the queue." , "The counter is incremented after each deletion."])) . field (| f | f . ty :: < PhantomData < T > > () . name ("_phantom") . type_name ("PhantomData<T>")))
            }
        };
    };
    const _: () = {
        impl<T: Config> ::codec::MaxEncodedLen for DeletionQueueManager<T>
        where
            PhantomData<T>: ::codec::MaxEncodedLen,
            PhantomData<T>: ::codec::MaxEncodedLen,
        {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<PhantomData<T>>::max_encoded_len())
            }
        }
    };
    const _: () = {
        impl<T: Config> core::default::Default for DeletionQueueManager<T> {
            fn default() -> Self {
                Self {
                    insert_counter: core::default::Default::default(),
                    delete_counter: core::default::Default::default(),
                    _phantom: core::default::Default::default(),
                }
            }
        }
    };
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for DeletionQueueManager<T> {
        #[inline]
        fn clone(&self) -> DeletionQueueManager<T> {
            DeletionQueueManager {
                insert_counter: ::core::clone::Clone::clone(&self.insert_counter),
                delete_counter: ::core::clone::Clone::clone(&self.delete_counter),
                _phantom: ::core::clone::Clone::clone(&self._phantom),
            }
        }
    }
    /// View on a contract that is marked for deletion.
    struct DeletionQueueEntry<'a, T: Config> {
        /// the trie id of the contract to delete.
        trie_id: TrieId,
        /// A mutable reference on the queue so that the contract can be removed, and none can be added
        /// or read in the meantime.
        queue: &'a mut DeletionQueueManager<T>,
    }
    impl<'a, T: Config> DeletionQueueEntry<'a, T> {
        /// Remove the contract from the deletion queue.
        fn remove(self) {
            <DeletionQueue<T>>::remove(self.queue.delete_counter);
            self.queue.delete_counter = self.queue.delete_counter.wrapping_add(1);
            <DeletionQueueCounter<T>>::set(self.queue.clone());
        }
    }
    impl<T: Config> DeletionQueueManager<T> {
        /// Load the `DeletionQueueCounter`, so we can perform read or write operations on the
        /// DeletionQueue storage.
        fn load() -> Self {
            <DeletionQueueCounter<T>>::get()
        }
        /// Returns `true` if the queue contains no elements.
        fn is_empty(&self) -> bool {
            self.insert_counter.wrapping_sub(self.delete_counter) == 0
        }
        /// Insert a contract in the deletion queue.
        fn insert(&mut self, trie_id: TrieId) {
            <DeletionQueue<T>>::insert(self.insert_counter, trie_id);
            self.insert_counter = self.insert_counter.wrapping_add(1);
            <DeletionQueueCounter<T>>::set(self.clone());
        }
        /// Fetch the next contract to be deleted.
        ///
        /// Note:
        /// we use the delete counter to get the next value to read from the queue and thus don't pay
        /// the cost of an extra call to `sp_io::storage::next_key` to lookup the next entry in the map
        fn next(&mut self) -> Option<DeletionQueueEntry<T>> {
            if self.is_empty() {
                return None;
            }
            let entry = <DeletionQueue<T>>::get(self.delete_counter);
            entry.map(|trie_id| DeletionQueueEntry {
                trie_id,
                queue: self,
            })
        }
    }
}
mod wasm {
    //! This module provides a means for executing contracts
    //! represented in wasm.
    mod code_cache {
        //! A module that implements instrumented code cache.
        //!
        //! - In order to run contract code we need to instrument it with gas metering.
        //! To do that we need to provide the schedule which will supply exact gas costs values.
        //! We cache this code in the storage saving the schedule version.
        //! - Before running contract code we check if the cached code has the schedule version that
        //! is equal to the current saved schedule.
        //! If it is equal then run the code, if it isn't reinstrument with the current schedule.
        //! - When we update the schedule we want it to have strictly greater version than the current saved
        //!   one:
        //! this guarantees that every instrumented contract code in cache cannot have the version equal to
        //! the current one. Thus, before executing a contract it should be reinstrument with new schedule.
        use crate::{
            gas::{GasMeter, Token},
            wasm::{prepare, PrefabWasmModule},
            weights::WeightInfo,
            CodeHash, CodeStorage, Config, Error, Event, OwnerInfoOf, Pallet, PristineCode,
            Schedule, Weight,
        };
        use frame_support::{
            dispatch::{DispatchError, DispatchResult},
            ensure,
            traits::{Get, ReservableCurrency},
            WeakBoundedVec,
        };
        use sp_runtime::traits::BadOrigin;
        use sp_std::vec;
        /// Put the instrumented module in storage.
        ///
        /// Increments the refcount of the in-storage `prefab_module` if it already exists in storage
        /// under the specified `code_hash`.
        pub fn store<T: Config>(
            mut module: PrefabWasmModule<T>,
            instantiated: bool,
        ) -> DispatchResult {
            let code_hash = sp_std::mem::take(&mut module.code_hash);
            <OwnerInfoOf<T>>::mutate(&code_hash, |owner_info| match owner_info {
                Some(owner_info) if instantiated => {
                    owner_info.refcount = owner_info.refcount.checked_add(1).expect(
                        "
					refcount is 64bit. Generating this overflow would require to store
					_at least_ 18 exabyte of data assuming that a contract consumes only
					one byte of data. Any node would run out of storage space before hitting
					this overflow.
					qed
				",
                    );
                    Ok(())
                }
                Some(_) => {
                    <CodeStorage<T>>::insert(&code_hash, module);
                    Ok(())
                }
                None => {
                    let orig_code = module.original_code.take().expect(
                        "
					If an executable isn't in storage it was uploaded.
					If it was uploaded the original code must exist. qed
				",
                    );
                    let mut new_owner_info = module.owner_info.take().expect(
                        "If an executable isn't in storage it was uploaded.
				If it was uploaded the owner info was generated and attached. qed
				",
                    );
                    T::Currency::reserve(&new_owner_info.owner, new_owner_info.deposit)
                        .map_err(|_| <Error<T>>::StorageDepositNotEnoughFunds)?;
                    new_owner_info.refcount = if instantiated { 1 } else { 0 };
                    <PristineCode<T>>::insert(&code_hash, orig_code);
                    <CodeStorage<T>>::insert(&code_hash, module);
                    *owner_info = Some(new_owner_info);
                    <Pallet<T>>::deposit_event(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([code_hash]),
                        ),
                        Event::CodeStored { code_hash },
                    );
                    Ok(())
                }
            })
        }
        /// Decrement the refcount of a code in-storage by one.
        ///
        /// # Note
        ///
        /// A contract whose refcount dropped to zero isn't automatically removed. A `remove_code`
        /// transaction must be submitted by the original uploader to do so.
        pub fn decrement_refcount<T: Config>(code_hash: CodeHash<T>) {
            <OwnerInfoOf<T>>::mutate(code_hash, |existing| {
                if let Some(info) = existing {
                    info.refcount = info.refcount.saturating_sub(1);
                }
            });
        }
        /// Increment the refcount of a code in-storage by one.
        ///
        /// # Errors
        ///
        /// [`Error::CodeNotFound`] is returned if the specified `code_hash` does not exist.
        pub fn increment_refcount<T: Config>(code_hash: CodeHash<T>) -> Result<(), DispatchError> {
            <OwnerInfoOf<T>>::mutate(code_hash, |existing| -> Result<(), DispatchError> {
                if let Some(info) = existing {
                    info.refcount = info.refcount.saturating_add(1);
                    Ok(())
                } else {
                    Err(Error::<T>::CodeNotFound.into())
                }
            })
        }
        /// Try to remove code together with all associated information.
        pub fn try_remove<T: Config>(
            origin: &T::AccountId,
            code_hash: CodeHash<T>,
        ) -> DispatchResult {
            <OwnerInfoOf<T>>::try_mutate_exists(&code_hash, |existing| {
                if let Some(owner_info) = existing {
                    {
                        if !(owner_info.refcount == 0) {
                            {
                                return Err(<Error<T>>::CodeInUse.into());
                            };
                        }
                    };
                    {
                        if !(&owner_info.owner == origin) {
                            {
                                return Err(BadOrigin.into());
                            };
                        }
                    };
                    T::Currency::unreserve(&owner_info.owner, owner_info.deposit);
                    *existing = None;
                    <PristineCode<T>>::remove(&code_hash);
                    <CodeStorage<T>>::remove(&code_hash);
                    <Pallet<T>>::deposit_event(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([code_hash]),
                        ),
                        Event::CodeRemoved { code_hash },
                    );
                    Ok(())
                } else {
                    Err(<Error<T>>::CodeNotFound.into())
                }
            })
        }
        /// Load code with the given code hash.
        ///
        /// If the module was instrumented with a lower version of schedule than
        /// the current one given as an argument, then this function will perform
        /// re-instrumentation and update the cache in the storage.
        pub fn load<T: Config>(
            code_hash: CodeHash<T>,
            schedule: &Schedule<T>,
            gas_meter: &mut GasMeter<T>,
        ) -> Result<PrefabWasmModule<T>, DispatchError> {
            let max_code_len = T::MaxCodeLen::get();
            let charged = gas_meter.charge(CodeToken::Load(max_code_len))?;
            let mut prefab_module =
                <CodeStorage<T>>::get(code_hash).ok_or(Error::<T>::CodeNotFound)?;
            let instrumented_code_len = prefab_module.code.len() as u32;
            gas_meter.adjust_gas(charged, CodeToken::Load(instrumented_code_len));
            prefab_module.code_hash = code_hash;
            if prefab_module.instruction_weights_version < schedule.instruction_weights.version {
                let charged = gas_meter.charge(CodeToken::Reinstrument(instrumented_code_len))?;
                let orig_code_len = reinstrument(&mut prefab_module, schedule)?;
                gas_meter.adjust_gas(charged, CodeToken::Reinstrument(orig_code_len));
            }
            Ok(prefab_module)
        }
        /// Instruments the passed prefab wasm module with the supplied schedule.
        ///
        /// Returns the size in bytes of the uninstrumented code.
        pub fn reinstrument<T: Config>(
            prefab_module: &mut PrefabWasmModule<T>,
            schedule: &Schedule<T>,
        ) -> Result<u32, DispatchError> {
            let original_code =
                <PristineCode<T>>::get(&prefab_module.code_hash).ok_or(Error::<T>::CodeNotFound)?;
            let original_code_len = original_code.len();
            prefab_module.code = WeakBoundedVec::force_from(
                prepare::reinstrument::<super::runtime::Env, T>(
                    &original_code,
                    schedule,
                    prefab_module.determinism,
                )?,
                Some("Contract exceeds size limit after re-instrumentation."),
            );
            prefab_module.instruction_weights_version = schedule.instruction_weights.version;
            <CodeStorage<T>>::insert(&prefab_module.code_hash, &*prefab_module);
            Ok(original_code_len as u32)
        }
        /// Costs for operations that are related to code handling.
        enum CodeToken {
            /// Weight for reinstrumenting a contract contract of the supplied size in bytes.
            Reinstrument(u32),
            /// Weight for loading a contract per byte.
            Load(u32),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CodeToken {
            #[inline]
            fn clone(&self) -> CodeToken {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for CodeToken {}
        impl<T: Config> Token<T> for CodeToken {
            fn weight(&self) -> Weight {
                use self::CodeToken::*;
                match *self {
                    Reinstrument(len) => T::WeightInfo::reinstrument(len),
                    Load(len) => T::WeightInfo::call_with_code_per_byte(len)
                        .saturating_sub(T::WeightInfo::call_with_code_per_byte(0)),
                }
            }
        }
    }
    mod prepare {
        //! This module takes care of loading, checking and preprocessing of a
        //! wasm module before execution. It also extracts some essential information
        //! from a module.
        use crate::{
            chain_extension::ChainExtension,
            storage::meter::Diff,
            wasm::{
                runtime::AllowDeprecatedInterface, Determinism, Environment, OwnerInfo,
                PrefabWasmModule,
            },
            AccountIdOf, CodeVec, Config, Error, Schedule, LOG_TARGET,
        };
        use codec::{Encode, MaxEncodedLen};
        use sp_runtime::{traits::Hash, DispatchError};
        use sp_std::prelude::*;
        use wasm_instrument::{
            gas_metering,
            parity_wasm::elements::{self, External, Internal, MemoryType, Type, ValueType},
        };
        use wasmi::StackLimits;
        use wasmparser::{Validator, WasmFeatures};
        /// Imported memory must be located inside this module. The reason for hardcoding is that current
        /// compiler toolchains might not support specifying other modules than "env" for memory imports.
        pub const IMPORT_MODULE_MEMORY: &str = "env";
        /// Determines whether a module should be instantiated during preparation.
        pub enum TryInstantiate {
            /// Do the instantiation to make sure that the module is valid.
            ///
            /// This should be used if a module is only uploaded but not executed. We need
            /// to make sure that it can be actually instantiated.
            Instantiate,
            /// Skip the instantiation during preparation.
            ///
            /// This makes sense when the preparation takes place as part of an instantiation. Then
            /// this instantiation would fail the whole transaction and an extra check is not
            /// necessary.
            Skip,
        }
        /// The reason why a contract is instrumented.
        enum InstrumentReason {
            /// A new code is uploaded.
            New,
            /// Existing code is re-instrumented.
            Reinstrument,
        }
        struct ContractModule<'a, T: Config> {
            /// A deserialized module. The module is valid (this is Guaranteed by `new` method).
            module: elements::Module,
            schedule: &'a Schedule<T>,
        }
        impl<'a, T: Config> ContractModule<'a, T> {
            /// Creates a new instance of `ContractModule`.
            ///
            /// Returns `Err` if the `original_code` couldn't be decoded or
            /// if it contains an invalid module.
            fn new(original_code: &[u8], schedule: &'a Schedule<T>) -> Result<Self, &'static str> {
                let module = elements::deserialize_buffer(original_code)
                    .map_err(|_| "Can't decode wasm code")?;
                Ok(ContractModule { module, schedule })
            }
            /// Ensures that module doesn't declare internal memories.
            ///
            /// In this runtime we only allow wasm module to import memory from the environment.
            /// Memory section contains declarations of internal linear memories, so if we find one
            /// we reject such a module.
            fn ensure_no_internal_memory(&self) -> Result<(), &'static str> {
                if self
                    .module
                    .memory_section()
                    .map_or(false, |ms| ms.entries().len() > 0)
                {
                    return Err("module declares internal memory");
                }
                Ok(())
            }
            /// Ensures that tables declared in the module are not too big.
            fn ensure_table_size_limit(&self, limit: u32) -> Result<(), &'static str> {
                if let Some(table_section) = self.module.table_section() {
                    if table_section.entries().len() > 1 {
                        return Err("multiple tables declared");
                    }
                    if let Some(table_type) = table_section.entries().first() {
                        if table_type.limits().initial() > limit {
                            return Err("table exceeds maximum size allowed");
                        }
                    }
                }
                Ok(())
            }
            /// Ensure that any `br_table` instruction adheres to its immediate value limit.
            fn ensure_br_table_size_limit(&self, limit: u32) -> Result<(), &'static str> {
                let code_section = if let Some(type_section) = self.module.code_section() {
                    type_section
                } else {
                    return Ok(());
                };
                for instr in code_section
                    .bodies()
                    .iter()
                    .flat_map(|body| body.code().elements())
                {
                    use self::elements::Instruction::BrTable;
                    if let BrTable(table) = instr {
                        if table.table.len() > limit as usize {
                            return Err("BrTable's immediate value is too big.");
                        }
                    }
                }
                Ok(())
            }
            fn ensure_global_variable_limit(&self, limit: u32) -> Result<(), &'static str> {
                if let Some(global_section) = self.module.global_section() {
                    if global_section.entries().len() > limit as usize {
                        return Err("module declares too many globals");
                    }
                }
                Ok(())
            }
            fn ensure_local_variable_limit(&self, limit: u32) -> Result<(), &'static str> {
                if let Some(code_section) = self.module.code_section() {
                    for func_body in code_section.bodies() {
                        let locals_count: u32 = func_body
                            .locals()
                            .iter()
                            .map(|val_type| val_type.count())
                            .sum();
                        if locals_count > limit {
                            return Err("single function declares too many locals");
                        }
                    }
                }
                Ok(())
            }
            /// Ensure that no function exists that has more parameters than allowed.
            fn ensure_parameter_limit(&self, limit: u32) -> Result<(), &'static str> {
                let type_section = if let Some(type_section) = self.module.type_section() {
                    type_section
                } else {
                    return Ok(());
                };
                for Type::Function(func) in type_section.types() {
                    if func.params().len() > limit as usize {
                        return Err("Use of a function type with too many parameters.");
                    }
                }
                Ok(())
            }
            fn inject_gas_metering(self, determinism: Determinism) -> Result<Self, &'static str> {
                let gas_rules = self.schedule.rules(determinism);
                let backend = gas_metering::host_function::Injector::new("seal0", "gas");
                let contract_module = gas_metering::inject(self.module, backend, &gas_rules)
                    .map_err(|_| "gas instrumentation failed")?;
                Ok(ContractModule {
                    module: contract_module,
                    schedule: self.schedule,
                })
            }
            /// Check that the module has required exported functions. For now
            /// these are just entrypoints:
            ///
            /// - 'call'
            /// - 'deploy'
            ///
            /// Any other exports are not allowed.
            fn scan_exports(&self) -> Result<(), &'static str> {
                let mut deploy_found = false;
                let mut call_found = false;
                let module = &self.module;
                let types = module.type_section().map(|ts| ts.types()).unwrap_or(&[]);
                let export_entries = module
                    .export_section()
                    .map(|is| is.entries())
                    .unwrap_or(&[]);
                let func_entries = module
                    .function_section()
                    .map(|fs| fs.entries())
                    .unwrap_or(&[]);
                let fn_space_offset = module
                    .import_section()
                    .map(|is| is.entries())
                    .unwrap_or(&[])
                    .iter()
                    .filter(|entry| match *entry.external() {
                        External::Function(_) => true,
                        _ => false,
                    })
                    .count();
                for export in export_entries {
                    match export.field() {
                        "call" => call_found = true,
                        "deploy" => deploy_found = true,
                        _ => {
                            return Err("unknown export: expecting only deploy and call functions")
                        }
                    }
                    let fn_idx = match export.internal() {
                        Internal::Function(ref fn_idx) => *fn_idx,
                        _ => return Err("expected a function"),
                    };
                    let fn_idx = match fn_idx.checked_sub(fn_space_offset as u32) {
                        Some(fn_idx) => fn_idx,
                        None => return Err("entry point points to an imported function"),
                    };
                    let func_ty_idx = func_entries
                        .get(fn_idx as usize)
                        .ok_or("export refers to non-existent function")?
                        .type_ref();
                    let Type::Function(ref func_ty) = types
                        .get(func_ty_idx as usize)
                        .ok_or("function has a non-existent type")?;
                    if !(func_ty.params().is_empty()
                        && (func_ty.results().is_empty() || func_ty.results() == [ValueType::I32]))
                    {
                        return Err("entry point has wrong signature");
                    }
                }
                if !deploy_found {
                    return Err("deploy function isn't exported");
                }
                if !call_found {
                    return Err("call function isn't exported");
                }
                Ok(())
            }
            /// Scan an import section if any.
            ///
            /// This makes sure that the import section looks as we expect it from a contract
            /// and enforces and returns the memory type declared by the contract if any.
            ///
            /// `import_fn_banlist`: list of function names that are disallowed to be imported
            fn scan_imports(
                &self,
                import_fn_banlist: &[&[u8]],
            ) -> Result<Option<&MemoryType>, &'static str> {
                let module = &self.module;
                let import_entries = module
                    .import_section()
                    .map(|is| is.entries())
                    .unwrap_or(&[]);
                let mut imported_mem_type = None;
                for import in import_entries {
                    match *import.external() {
                        External::Table(_) => return Err("Cannot import tables"),
                        External::Global(_) => return Err("Cannot import globals"),
                        External::Function(_) => {
                            if !T::ChainExtension::enabled()
                                && import.field().as_bytes() == b"seal_call_chain_extension"
                            {
                                return Err ("module uses chain extensions but chain extensions are disabled");
                            }
                            if import_fn_banlist
                                .iter()
                                .any(|f| import.field().as_bytes() == *f)
                            {
                                return Err("module imports a banned function");
                            }
                        }
                        External::Memory(ref memory_type) => {
                            if import.module() != IMPORT_MODULE_MEMORY {
                                return Err("Invalid module for imported memory");
                            }
                            if import.field() != "memory" {
                                return Err("Memory import must have the field name 'memory'");
                            }
                            if imported_mem_type.is_some() {
                                return Err("Multiple memory imports defined");
                            }
                            imported_mem_type = Some(memory_type);
                            continue;
                        }
                    }
                }
                Ok(imported_mem_type)
            }
            fn into_wasm_code(self) -> Result<Vec<u8>, &'static str> {
                elements::serialize(self.module)
                    .map_err(|_| "error serializing instrumented module")
            }
        }
        fn get_memory_limits<T: Config>(
            module: Option<&MemoryType>,
            schedule: &Schedule<T>,
        ) -> Result<(u32, u32), &'static str> {
            if let Some(memory_type) = module {
                let limits = memory_type.limits();
                match (limits.initial(), limits.maximum()) {
                    (initial, Some(maximum)) if initial > maximum => Err(
                        "Requested initial number of pages should not exceed the requested maximum",
                    ),
                    (_, Some(maximum)) if maximum > schedule.limits.memory_pages => {
                        Err("Maximum number of pages should not exceed the configured maximum.")
                    }
                    (initial, Some(maximum)) => Ok((initial, maximum)),
                    (_, None) => Err("Maximum number of pages should be always declared."),
                }
            } else {
                Ok((0, 0))
            }
        }
        /// Check and instrument the given `original_code`.
        ///
        /// On success it returns the instrumented versions together with its `(initial, maximum)`
        /// error requirement. The memory requirement was also validated against the `schedule`.
        fn instrument<E, T>(
            original_code: &[u8],
            schedule: &Schedule<T>,
            determinism: Determinism,
            try_instantiate: TryInstantiate,
            reason: InstrumentReason,
        ) -> Result<(Vec<u8>, (u32, u32)), (DispatchError, &'static str)>
        where
            E: Environment<()>,
            T: Config,
        {
            Validator::new_with_features(WasmFeatures {
                relaxed_simd: false,
                threads: false,
                tail_call: false,
                multi_memory: false,
                exceptions: false,
                memory64: false,
                extended_const: false,
                component_model: false,
                floats: match determinism {
                    Determinism::Relaxed => true,
                    _ => false,
                },
                mutable_global: false,
                saturating_float_to_int: false,
                sign_extension: false,
                bulk_memory: false,
                multi_value: false,
                reference_types: false,
                simd: false,
                memory_control: false,
            })
            .validate_all(original_code)
            .map_err(|err| {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            format_args!("{0}", err),
                            lvl,
                            &(
                                LOG_TARGET,
                                "pallet_contracts::wasm::prepare",
                                "frame/contracts/src/wasm/prepare.rs",
                                382u32,
                            ),
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                (
                    Error::<T>::CodeRejected.into(),
                    "validation of new code failed",
                )
            })?;
            let (code, (initial, maximum)) = (|| {
                let contract_module = ContractModule::new(original_code, schedule)?;
                contract_module.scan_exports()?;
                contract_module.ensure_no_internal_memory()?;
                contract_module.ensure_table_size_limit(schedule.limits.table_size)?;
                contract_module.ensure_global_variable_limit(schedule.limits.globals)?;
                contract_module.ensure_local_variable_limit(schedule.limits.locals)?;
                contract_module.ensure_parameter_limit(schedule.limits.parameters)?;
                contract_module.ensure_br_table_size_limit(schedule.limits.br_table_size)?;
                let disallowed_imports = [b"gas".as_ref()];
                let memory_limits = get_memory_limits(
                    contract_module.scan_imports(&disallowed_imports)?,
                    schedule,
                )?;
                let code = contract_module
                    .inject_gas_metering(determinism)?
                    .into_wasm_code()?;
                Ok((code, memory_limits))
            })()
            .map_err(|msg: &str| {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            format_args!("new code rejected: {0}", msg),
                            lvl,
                            &(
                                LOG_TARGET,
                                "pallet_contracts::wasm::prepare",
                                "frame/contracts/src/wasm/prepare.rs",
                                406u32,
                            ),
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                (Error::<T>::CodeRejected.into(), msg)
            })?;
            if match try_instantiate {
                TryInstantiate::Instantiate => true,
                _ => false,
            } {
                let stack_limits = StackLimits::new(1, 1, 0).expect("initial <= max; qed");
                PrefabWasmModule::<T>::instantiate::<E, _>(
                    &code,
                    (),
                    (initial, maximum),
                    stack_limits,
                    match reason {
                        InstrumentReason::New => AllowDeprecatedInterface::No,
                        InstrumentReason::Reinstrument => AllowDeprecatedInterface::Yes,
                    },
                )
                .map_err(|err| {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                format_args!("{0}", err),
                                lvl,
                                &(
                                    LOG_TARGET,
                                    "pallet_contracts::wasm::prepare",
                                    "frame/contracts/src/wasm/prepare.rs",
                                    429u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    (
                        Error::<T>::CodeRejected.into(),
                        "new code rejected after instrumentation",
                    )
                })?;
            }
            Ok((code, (initial, maximum)))
        }
        /// Loads the given module given in `original_code`, performs some checks on it and
        /// does some preprocessing.
        ///
        /// The checks are:
        ///
        /// - the provided code is a valid wasm module
        /// - the module doesn't define an internal memory instance
        /// - imported memory (if any) doesn't reserve more memory than permitted by the `schedule`
        /// - all imported functions from the external environment matches defined by `env` module
        ///
        /// The preprocessing includes injecting code for gas metering and metering the height of stack.
        pub fn prepare<E, T>(
            original_code: CodeVec<T>,
            schedule: &Schedule<T>,
            owner: AccountIdOf<T>,
            determinism: Determinism,
            try_instantiate: TryInstantiate,
        ) -> Result<PrefabWasmModule<T>, (DispatchError, &'static str)>
        where
            E: Environment<()>,
            T: Config,
        {
            let (code, (initial, maximum)) = instrument::<E, T>(
                original_code.as_ref(),
                schedule,
                determinism,
                try_instantiate,
                InstrumentReason::New,
            )?;
            let original_code_len = original_code.len();
            let mut module = PrefabWasmModule {
                instruction_weights_version: schedule.instruction_weights.version,
                initial,
                maximum,
                code: code
                    .try_into()
                    .map_err(|_| (<Error<T>>::CodeTooLarge.into(), ""))?,
                code_hash: T::Hashing::hash(&original_code),
                original_code: Some(original_code),
                owner_info: None,
                determinism,
            };
            let bytes_added = module
                .encoded_size()
                .saturating_add(original_code_len)
                .saturating_add(<OwnerInfo<T>>::max_encoded_len())
                as u32;
            let deposit = Diff {
                bytes_added,
                items_added: 3,
                ..Default::default()
            }
            .update_contract::<T>(None)
            .charge_or_zero();
            module.owner_info = Some(OwnerInfo {
                owner,
                deposit,
                refcount: 0,
            });
            Ok(module)
        }
        /// Same as [`prepare`] but without constructing a new module.
        ///
        /// Used to update the code of an existing module to the newest [`Schedule`] version.
        /// Stictly speaking is not necessary to check the existing code before reinstrumenting because
        /// it can't change in the meantime. However, since we recently switched the validation library
        /// we want to re-validate to weed out any bugs that were lurking in the old version.
        pub fn reinstrument<E, T>(
            original_code: &[u8],
            schedule: &Schedule<T>,
            determinism: Determinism,
        ) -> Result<Vec<u8>, DispatchError>
        where
            E: Environment<()>,
            T: Config,
        {
            instrument::<E, T>(
                original_code,
                schedule,
                determinism,
                TryInstantiate::Skip,
                InstrumentReason::Reinstrument,
            )
            .map_err(|(err, msg)| {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            format_args!("CodeRejected during reinstrument: {0}", msg),
                            lvl,
                            &(
                                LOG_TARGET,
                                "pallet_contracts::wasm::prepare",
                                "frame/contracts/src/wasm/prepare.rs",
                                521u32,
                            ),
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                err
            })
            .map(|(code, _)| code)
        }
    }
    mod runtime {
        //! Environment definition of the wasm smart-contract runtime.
        //! wasm 智能合约运行时的环境定义。
        use crate::{
            exec::{ExecError, ExecResult, Ext, Key, TopicOf},
            gas::{ChargedAmount, Token},
            schedule::HostFnWeights,
            BalanceOf, CodeHash, Config, DebugBufferVec, Error, SENTINEL,
        };
        use bitflags::bitflags;
        use codec::{Decode, DecodeLimit, Encode, MaxEncodedLen};
        use frame_support::{
            dispatch::DispatchError, ensure, traits::Get, weights::Weight, RuntimeDebug,
        };
        use pallet_contracts_primitives::{ExecReturnValue, ReturnFlags};
        use pallet_contracts_proc_macro::define_env;
        use sp_io::hashing::{blake2_128, blake2_256, keccak_256, sha2_256};
        use sp_runtime::traits::{Bounded, Zero};
        use sp_std::{fmt, prelude::*};
        use wasmi::{core::HostError, errors::LinkerError, Linker, Memory, Store};
        /// The maximum nesting depth a contract can use when encoding types.
        const MAX_DECODE_NESTING: u32 = 256;
        /// Passed to [`Environment`] to determine whether it should expose deprecated interfaces.
        pub enum AllowDeprecatedInterface {
            /// No deprecated interfaces are exposed.
            No,
            /// Deprecated interfaces are exposed.
            Yes,
        }
        /// Passed to [`Environment`] to determine whether it should expose unstable interfaces.
        pub enum AllowUnstableInterface {
            /// No unstable interfaces are exposed.
            No,
            /// Unstable interfaces are exposed.
            Yes,
        }
        /// Trait implemented by the [`define_env`](pallet_contracts_proc_macro::define_env) macro for the
        /// emitted `Env` struct.
        pub trait Environment<HostState> {
            /// Adds all declared functions to the supplied [`Linker`](wasmi::Linker) and
            /// [`Store`](wasmi::Store).
            fn define(
                store: &mut Store<HostState>,
                linker: &mut Linker<HostState>,
                allow_unstable: AllowUnstableInterface,
                allow_deprecated: AllowDeprecatedInterface,
            ) -> Result<(), LinkerError>;
        }
        /// Type of a storage key.
        #[allow(dead_code)]
        enum KeyType {
            /// Legacy fix sized key `[u8;32]`.
            Fix,
            /// Variable sized key used in transparent hashing,
            /// cannot be larger than MaxStorageKeyLen.
            Var(u32),
        }
        /// Every error that can be returned to a contract when it calls any of the host functions.
        ///
        /// # Note
        ///
        /// This enum can be extended in the future: New codes can be added but existing codes
        /// will not be changed or removed. This means that any contract **must not** exhaustively
        /// match return codes. Instead, contracts should prepare for unknown variants and deal with
        /// those errors gracefully in order to be forward compatible.
        #[repr(u32)]
        pub enum ReturnCode {
            /// API call successful.
            Success = 0,
            /// The called function trapped and has its state changes reverted.
            /// In this case no output buffer is returned.
            CalleeTrapped = 1,
            /// The called function ran to completion but decided to revert its state.
            /// An output buffer is returned when one was supplied.
            CalleeReverted = 2,
            /// The passed key does not exist in storage.
            KeyNotFound = 3,
            /// See [`Error::TransferFailed`].
            TransferFailed = 5,
            /// No code could be found at the supplied code hash.
            CodeNotFound = 7,
            /// The contract that was called is no contract (a plain account).
            NotCallable = 8,
            /// The call dispatched by `seal_call_runtime` was executed but returned an error.
            CallRuntimeFailed = 10,
            /// ECDSA pubkey recovery failed (most probably wrong recovery id or signature), or
            /// ECDSA compressed pubkey conversion into Ethereum address failed (most probably
            /// wrong pubkey provided).
            EcdsaRecoverFailed = 11,
            /// sr25519 signature verification failed.
            Sr25519VerifyFailed = 12,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ReturnCode {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ReturnCode::Success => "Success",
                        ReturnCode::CalleeTrapped => "CalleeTrapped",
                        ReturnCode::CalleeReverted => "CalleeReverted",
                        ReturnCode::KeyNotFound => "KeyNotFound",
                        ReturnCode::TransferFailed => "TransferFailed",
                        ReturnCode::CodeNotFound => "CodeNotFound",
                        ReturnCode::NotCallable => "NotCallable",
                        ReturnCode::CallRuntimeFailed => "CallRuntimeFailed",
                        ReturnCode::EcdsaRecoverFailed => "EcdsaRecoverFailed",
                        ReturnCode::Sr25519VerifyFailed => "Sr25519VerifyFailed",
                    },
                )
            }
        }
        impl From<ExecReturnValue> for ReturnCode {
            fn from(from: ExecReturnValue) -> Self {
                if from.flags.contains(ReturnFlags::REVERT) {
                    Self::CalleeReverted
                } else {
                    Self::Success
                }
            }
        }
        impl From<ReturnCode> for u32 {
            fn from(code: ReturnCode) -> u32 {
                code as u32
            }
        }
        /// The data passed through when a contract uses `seal_return`.
        pub struct ReturnData {
            /// The flags as passed through by the contract. They are still unchecked and
            /// will later be parsed into a `ReturnFlags` bitflags struct.
            flags: u32,
            /// The output buffer passed by the contract as return data.
            data: Vec<u8>,
        }
        impl core::fmt::Debug for ReturnData {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                fmt.debug_struct("ReturnData")
                    .field("flags", &self.flags)
                    .field("data", &self.data)
                    .finish()
            }
        }
        /// Enumerates all possible reasons why a trap was generated.
        ///
        /// This is either used to supply the caller with more information about why an error
        /// occurred (the SupervisorError variant).
        /// The other case is where the trap does not constitute an error but rather was invoked
        /// as a quick way to terminate the application (all other variants).
        pub enum TrapReason {
            /// The supervisor trapped the contract because of an error condition occurred during
            /// execution in privileged code.
            SupervisorError(DispatchError),
            /// Signals that trap was generated in response to call `seal_return` host function.
            Return(ReturnData),
            /// Signals that a trap was generated in response to a successful call to the
            /// `seal_terminate` host function.
            Termination,
        }
        impl core::fmt::Debug for TrapReason {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    Self::SupervisorError(ref a0) => fmt
                        .debug_tuple("TrapReason::SupervisorError")
                        .field(a0)
                        .finish(),
                    Self::Return(ref a0) => {
                        fmt.debug_tuple("TrapReason::Return").field(a0).finish()
                    }
                    Self::Termination => fmt.debug_tuple("TrapReason::Termination").finish(),
                    _ => Ok(()),
                }
            }
        }
        impl<T: Into<DispatchError>> From<T> for TrapReason {
            fn from(from: T) -> Self {
                Self::SupervisorError(from.into())
            }
        }
        impl fmt::Display for TrapReason {
            fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
                Ok(())
            }
        }
        impl HostError for TrapReason {}
        pub enum RuntimeCosts {
            /// Charge the gas meter with the cost of a metering block. The charged costs are
            /// the supplied cost of the block plus the overhead of the metering itself.
            MeteringBlock(u64),
            /// Weight charged for copying data from the sandbox.
            CopyFromContract(u32),
            /// Weight charged for copying data to the sandbox.
            CopyToContract(u32),
            /// Weight of calling `seal_caller`.
            Caller,
            /// Weight of calling `seal_is_contract`.
            IsContract,
            /// Weight of calling `seal_code_hash`.
            CodeHash,
            /// Weight of calling `seal_own_code_hash`.
            OwnCodeHash,
            /// Weight of calling `seal_caller_is_origin`.
            CallerIsOrigin,
            /// Weight of calling `caller_is_root`.
            CallerIsRoot,
            /// Weight of calling `seal_address`.
            Address,
            /// Weight of calling `seal_gas_left`.
            GasLeft,
            /// Weight of calling `seal_balance`.
            Balance,
            /// Weight of calling `seal_value_transferred`.
            ValueTransferred,
            /// Weight of calling `seal_minimum_balance`.
            MinimumBalance,
            /// Weight of calling `seal_block_number`.
            BlockNumber,
            /// Weight of calling `seal_now`.
            Now,
            /// Weight of calling `seal_weight_to_fee`.
            WeightToFee,
            /// Weight of calling `seal_input` without the weight of copying the input.
            InputBase,
            /// Weight of calling `seal_return` for the given output size.
            Return(u32),
            /// Weight of calling `seal_terminate`.
            Terminate,
            /// Weight of calling `seal_random`. It includes the weight for copying the subject.
            Random,
            /// Weight of calling `seal_deposit_event` with the given number of topics and event size.
            DepositEvent { num_topic: u32, len: u32 },
            /// Weight of calling `seal_debug_message` per byte of passed message.
            DebugMessage(u32),
            /// Weight of calling `seal_set_storage` for the given storage item sizes.
            SetStorage { old_bytes: u32, new_bytes: u32 },
            /// Weight of calling `seal_clear_storage` per cleared byte.
            ClearStorage(u32),
            /// Weight of calling `seal_contains_storage` per byte of the checked item.
            ContainsStorage(u32),
            /// Weight of calling `seal_get_storage` with the specified size in storage.
            GetStorage(u32),
            /// Weight of calling `seal_take_storage` for the given size.
            TakeStorage(u32),
            /// Weight of calling `seal_transfer`.
            Transfer,
            /// Base weight of calling `seal_call`.
            CallBase,
            /// Weight of calling `seal_delegate_call` for the given input size.
            DelegateCallBase,
            /// Weight of the transfer performed during a call.
            CallSurchargeTransfer,
            /// Weight per byte that is cloned by supplying the `CLONE_INPUT` flag.
            CallInputCloned(u32),
            /// Weight of calling `seal_instantiate` for the given input length and salt.
            InstantiateBase { input_data_len: u32, salt_len: u32 },
            /// Weight of the transfer performed during an instantiate.
            InstantiateSurchargeTransfer,
            /// Weight of calling `seal_hash_sha_256` for the given input size.
            HashSha256(u32),
            /// Weight of calling `seal_hash_keccak_256` for the given input size.
            HashKeccak256(u32),
            /// Weight of calling `seal_hash_blake2_256` for the given input size.
            HashBlake256(u32),
            /// Weight of calling `seal_hash_blake2_128` for the given input size.
            HashBlake128(u32),
            /// Weight of calling `seal_ecdsa_recover`.
            EcdsaRecovery,
            /// Weight of calling `seal_sr25519_verify` for the given input size.
            Sr25519Verify(u32),
            /// Weight charged by a chain extension through `seal_call_chain_extension`.
            ChainExtension(Weight),
            /// Weight charged for calling into the runtime.
            CallRuntime(Weight),
            /// Weight of calling `seal_set_code_hash`
            SetCodeHash,
            /// Weight of calling `ecdsa_to_eth_address`
            EcdsaToEthAddress,
            /// Weight of calling `reentrance_count`
            ReentrantCount,
            /// Weight of calling `account_reentrance_count`
            AccountEntranceCount,
            /// Weight of calling `instantiation_nonce`
            InstantationNonce,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RuntimeCosts {}
        #[automatically_derived]
        impl ::core::clone::Clone for RuntimeCosts {
            #[inline]
            fn clone(&self) -> RuntimeCosts {
                let _: ::core::clone::AssertParamIsClone<u64>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                let _: ::core::clone::AssertParamIsClone<Weight>;
                *self
            }
        }
        impl RuntimeCosts {
            fn token<T: Config>(&self, s: &HostFnWeights<T>) -> RuntimeToken {
                use self::RuntimeCosts::*;
                let weight = match *self {
                    MeteringBlock(amount) => s.gas.saturating_add(Weight::from_parts(amount, 0)),
                    CopyFromContract(len) => s.return_per_byte.saturating_mul(len.into()),
                    CopyToContract(len) => s.input_per_byte.saturating_mul(len.into()),
                    Caller => s.caller,
                    IsContract => s.is_contract,
                    CodeHash => s.code_hash,
                    OwnCodeHash => s.own_code_hash,
                    CallerIsOrigin => s.caller_is_origin,
                    CallerIsRoot => s.caller_is_root,
                    Address => s.address,
                    GasLeft => s.gas_left,
                    Balance => s.balance,
                    ValueTransferred => s.value_transferred,
                    MinimumBalance => s.minimum_balance,
                    BlockNumber => s.block_number,
                    Now => s.now,
                    WeightToFee => s.weight_to_fee,
                    InputBase => s.input,
                    Return(len) => s
                        .r#return
                        .saturating_add(s.return_per_byte.saturating_mul(len.into())),
                    Terminate => s.terminate,
                    Random => s.random,
                    DepositEvent { num_topic, len } => s
                        .deposit_event
                        .saturating_add(s.deposit_event_per_topic.saturating_mul(num_topic.into()))
                        .saturating_add(s.deposit_event_per_byte.saturating_mul(len.into())),
                    DebugMessage(len) => s
                        .debug_message
                        .saturating_add(s.deposit_event_per_byte.saturating_mul(len.into())),
                    SetStorage {
                        new_bytes,
                        old_bytes,
                    } => s
                        .set_storage
                        .saturating_add(s.set_storage_per_new_byte.saturating_mul(new_bytes.into()))
                        .saturating_add(
                            s.set_storage_per_old_byte.saturating_mul(old_bytes.into()),
                        ),
                    ClearStorage(len) => s
                        .clear_storage
                        .saturating_add(s.clear_storage_per_byte.saturating_mul(len.into())),
                    ContainsStorage(len) => s
                        .contains_storage
                        .saturating_add(s.contains_storage_per_byte.saturating_mul(len.into())),
                    GetStorage(len) => s
                        .get_storage
                        .saturating_add(s.get_storage_per_byte.saturating_mul(len.into())),
                    TakeStorage(len) => s
                        .take_storage
                        .saturating_add(s.take_storage_per_byte.saturating_mul(len.into())),
                    Transfer => s.transfer,
                    CallBase => s.call,
                    DelegateCallBase => s.delegate_call,
                    CallSurchargeTransfer => s.call_transfer_surcharge,
                    CallInputCloned(len) => s.call_per_cloned_byte.saturating_mul(len.into()),
                    InstantiateBase {
                        input_data_len,
                        salt_len,
                    } => s
                        .instantiate
                        .saturating_add(
                            s.instantiate_per_input_byte
                                .saturating_mul(input_data_len.into()),
                        )
                        .saturating_add(
                            s.instantiate_per_salt_byte.saturating_mul(salt_len.into()),
                        ),
                    InstantiateSurchargeTransfer => s.instantiate_transfer_surcharge,
                    HashSha256(len) => s
                        .hash_sha2_256
                        .saturating_add(s.hash_sha2_256_per_byte.saturating_mul(len.into())),
                    HashKeccak256(len) => s
                        .hash_keccak_256
                        .saturating_add(s.hash_keccak_256_per_byte.saturating_mul(len.into())),
                    HashBlake256(len) => s
                        .hash_blake2_256
                        .saturating_add(s.hash_blake2_256_per_byte.saturating_mul(len.into())),
                    HashBlake128(len) => s
                        .hash_blake2_128
                        .saturating_add(s.hash_blake2_128_per_byte.saturating_mul(len.into())),
                    EcdsaRecovery => s.ecdsa_recover,
                    Sr25519Verify(len) => s
                        .sr25519_verify
                        .saturating_add(s.sr25519_verify_per_byte.saturating_mul(len.into())),
                    ChainExtension(weight) => weight,
                    CallRuntime(weight) => weight,
                    SetCodeHash => s.set_code_hash,
                    EcdsaToEthAddress => s.ecdsa_to_eth_address,
                    ReentrantCount => s.reentrance_count,
                    AccountEntranceCount => s.account_reentrance_count,
                    InstantationNonce => s.instantiation_nonce,
                };
                RuntimeToken { weight }
            }
        }
        struct RuntimeToken {
            weight: Weight,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RuntimeToken {}
        #[automatically_derived]
        impl ::core::clone::Clone for RuntimeToken {
            #[inline]
            fn clone(&self) -> RuntimeToken {
                let _: ::core::clone::AssertParamIsClone<Weight>;
                *self
            }
        }
        impl<T: Config> Token<T> for RuntimeToken {
            fn weight(&self) -> Weight {
                self.weight
            }
        }
        /// Flags used to change the behaviour of `seal_call` and `seal_delegate_call`.
        pub struct CallFlags {
            bits: u32,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for CallFlags {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CallFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CallFlags {
            #[inline]
            fn eq(&self, other: &CallFlags) -> bool {
                self.bits == other.bits
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for CallFlags {}
        #[automatically_derived]
        impl ::core::cmp::Eq for CallFlags {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u32>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CallFlags {
            #[inline]
            fn clone(&self) -> CallFlags {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for CallFlags {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CallFlags,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for CallFlags {
            #[inline]
            fn cmp(&self, other: &CallFlags) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.bits, &other.bits)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for CallFlags {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.bits, state)
            }
        }
        impl ::bitflags::_core::fmt::Debug for CallFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    #[inline]
                    fn FORWARD_INPUT(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn CLONE_INPUT(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn TAIL_CALL(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn ALLOW_REENTRY(&self) -> bool {
                        false
                    }
                }
                #[allow(non_snake_case)]
                impl __BitFlags for CallFlags {
                    #[allow(deprecated)]
                    #[inline]
                    fn FORWARD_INPUT(&self) -> bool {
                        if Self::FORWARD_INPUT.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::FORWARD_INPUT.bits == Self::FORWARD_INPUT.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn CLONE_INPUT(&self) -> bool {
                        if Self::CLONE_INPUT.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::CLONE_INPUT.bits == Self::CLONE_INPUT.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn TAIL_CALL(&self) -> bool {
                        if Self::TAIL_CALL.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::TAIL_CALL.bits == Self::TAIL_CALL.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn ALLOW_REENTRY(&self) -> bool {
                        if Self::ALLOW_REENTRY.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::ALLOW_REENTRY.bits == Self::ALLOW_REENTRY.bits
                        }
                    }
                }
                let mut first = true;
                if <Self as __BitFlags>::FORWARD_INPUT(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("FORWARD_INPUT")?;
                }
                if <Self as __BitFlags>::CLONE_INPUT(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("CLONE_INPUT")?;
                }
                if <Self as __BitFlags>::TAIL_CALL(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("TAIL_CALL")?;
                }
                if <Self as __BitFlags>::ALLOW_REENTRY(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("ALLOW_REENTRY")?;
                }
                let extra_bits = self.bits & !Self::all().bits();
                if extra_bits != 0 {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("0x")?;
                    ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                }
                if first {
                    f.write_str("(empty)")?;
                }
                Ok(())
            }
        }
        impl ::bitflags::_core::fmt::Binary for CallFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::Octal for CallFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::LowerHex for CallFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::UpperHex for CallFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
            }
        }
        #[allow(dead_code)]
        impl CallFlags {
            /// Forward the input of current function to the callee.
            ///
            /// Supplied input pointers are ignored when set.
            ///
            /// # Note
            ///
            /// A forwarding call will consume the current contracts input. Any attempt to
            /// access the input after this call returns will lead to [`Error::InputForwarded`].
            /// It does not matter if this is due to calling `seal_input` or trying another
            /// forwarding call. Consider using [`Self::CLONE_INPUT`] in order to preserve
            /// the input.
            pub const FORWARD_INPUT: Self = Self { bits: 0b0000_0001 };
            /// Identical to [`Self::FORWARD_INPUT`] but without consuming the input.
            ///
            /// This adds some additional weight costs to the call.
            ///
            /// # Note
            ///
            /// This implies [`Self::FORWARD_INPUT`] and takes precedence when both are set.
            pub const CLONE_INPUT: Self = Self { bits: 0b0000_0010 };
            /// Do not return from the call but rather return the result of the callee to the
            /// callers caller.
            ///
            /// # Note
            ///
            /// This makes the current contract completely transparent to its caller by replacing
            /// this contracts potential output by the callee ones. Any code after `seal_call`
            /// can be safely considered unreachable.
            pub const TAIL_CALL: Self = Self { bits: 0b0000_0100 };
            /// Allow the callee to reenter into the current contract.
            ///
            /// Without this flag any reentrancy into the current contract that originates from
            /// the callee (or any of its callees) is denied. This includes the first callee:
            /// You cannot call into yourself with this flag set.
            ///
            /// # Note
            ///
            /// For `seal_delegate_call` should be always unset, otherwise
            /// [`Error::InvalidCallFlags`] is returned.
            pub const ALLOW_REENTRY: Self = Self { bits: 0b0000_1000 };
            /// Returns an empty set of flags.
            #[inline]
            pub const fn empty() -> Self {
                Self { bits: 0 }
            }
            /// Returns the set containing all flags.
            #[inline]
            pub const fn all() -> Self {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    const FORWARD_INPUT: u32 = 0;
                    const CLONE_INPUT: u32 = 0;
                    const TAIL_CALL: u32 = 0;
                    const ALLOW_REENTRY: u32 = 0;
                }
                #[allow(non_snake_case)]
                impl __BitFlags for CallFlags {
                    #[allow(deprecated)]
                    const FORWARD_INPUT: u32 = Self::FORWARD_INPUT.bits;
                    #[allow(deprecated)]
                    const CLONE_INPUT: u32 = Self::CLONE_INPUT.bits;
                    #[allow(deprecated)]
                    const TAIL_CALL: u32 = Self::TAIL_CALL.bits;
                    #[allow(deprecated)]
                    const ALLOW_REENTRY: u32 = Self::ALLOW_REENTRY.bits;
                }
                Self {
                    bits: <Self as __BitFlags>::FORWARD_INPUT
                        | <Self as __BitFlags>::CLONE_INPUT
                        | <Self as __BitFlags>::TAIL_CALL
                        | <Self as __BitFlags>::ALLOW_REENTRY,
                }
            }
            /// Returns the raw value of the flags currently stored.
            #[inline]
            pub const fn bits(&self) -> u32 {
                self.bits
            }
            /// Convert from underlying bit representation, unless that
            /// representation contains bits that do not correspond to a flag.
            #[inline]
            pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
                if (bits & !Self::all().bits()) == 0 {
                    ::bitflags::_core::option::Option::Some(Self { bits })
                } else {
                    ::bitflags::_core::option::Option::None
                }
            }
            /// Convert from underlying bit representation, dropping any bits
            /// that do not correspond to flags.
            #[inline]
            pub const fn from_bits_truncate(bits: u32) -> Self {
                Self {
                    bits: bits & Self::all().bits,
                }
            }
            /// Convert from underlying bit representation, preserving all
            /// bits (even those not corresponding to a defined flag).
            ///
            /// # Safety
            ///
            /// The caller of the `bitflags!` macro can chose to allow or
            /// disallow extra bits for their bitflags type.
            ///
            /// The caller of `from_bits_unchecked()` has to ensure that
            /// all bits correspond to a defined flag or that extra bits
            /// are valid for this bitflags type.
            #[inline]
            pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
                Self { bits }
            }
            /// Returns `true` if no flags are currently stored.
            #[inline]
            pub const fn is_empty(&self) -> bool {
                self.bits() == Self::empty().bits()
            }
            /// Returns `true` if all flags are currently set.
            #[inline]
            pub const fn is_all(&self) -> bool {
                Self::all().bits | self.bits == self.bits
            }
            /// Returns `true` if there are flags common to both `self` and `other`.
            #[inline]
            pub const fn intersects(&self, other: Self) -> bool {
                !(Self {
                    bits: self.bits & other.bits,
                })
                .is_empty()
            }
            /// Returns `true` if all of the flags in `other` are contained within `self`.
            #[inline]
            pub const fn contains(&self, other: Self) -> bool {
                (self.bits & other.bits) == other.bits
            }
            /// Inserts the specified flags in-place.
            #[inline]
            pub fn insert(&mut self, other: Self) {
                self.bits |= other.bits;
            }
            /// Removes the specified flags in-place.
            #[inline]
            pub fn remove(&mut self, other: Self) {
                self.bits &= !other.bits;
            }
            /// Toggles the specified flags in-place.
            #[inline]
            pub fn toggle(&mut self, other: Self) {
                self.bits ^= other.bits;
            }
            /// Inserts or removes the specified flags depending on the passed value.
            #[inline]
            pub fn set(&mut self, other: Self, value: bool) {
                if value {
                    self.insert(other);
                } else {
                    self.remove(other);
                }
            }
            /// Returns the intersection between the flags in `self` and
            /// `other`.
            ///
            /// Specifically, the returned set contains only the flags which are
            /// present in *both* `self` *and* `other`.
            ///
            /// This is equivalent to using the `&` operator (e.g.
            /// [`ops::BitAnd`]), as in `flags & other`.
            ///
            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
            #[inline]
            #[must_use]
            pub const fn intersection(self, other: Self) -> Self {
                Self {
                    bits: self.bits & other.bits,
                }
            }
            /// Returns the union of between the flags in `self` and `other`.
            ///
            /// Specifically, the returned set contains all flags which are
            /// present in *either* `self` *or* `other`, including any which are
            /// present in both (see [`Self::symmetric_difference`] if that
            /// is undesirable).
            ///
            /// This is equivalent to using the `|` operator (e.g.
            /// [`ops::BitOr`]), as in `flags | other`.
            ///
            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
            #[inline]
            #[must_use]
            pub const fn union(self, other: Self) -> Self {
                Self {
                    bits: self.bits | other.bits,
                }
            }
            /// Returns the difference between the flags in `self` and `other`.
            ///
            /// Specifically, the returned set contains all flags present in
            /// `self`, except for the ones present in `other`.
            ///
            /// It is also conceptually equivalent to the "bit-clear" operation:
            /// `flags & !other` (and this syntax is also supported).
            ///
            /// This is equivalent to using the `-` operator (e.g.
            /// [`ops::Sub`]), as in `flags - other`.
            ///
            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
            #[inline]
            #[must_use]
            pub const fn difference(self, other: Self) -> Self {
                Self {
                    bits: self.bits & !other.bits,
                }
            }
            /// Returns the [symmetric difference][sym-diff] between the flags
            /// in `self` and `other`.
            ///
            /// Specifically, the returned set contains the flags present which
            /// are present in `self` or `other`, but that are not present in
            /// both. Equivalently, it contains the flags present in *exactly
            /// one* of the sets `self` and `other`.
            ///
            /// This is equivalent to using the `^` operator (e.g.
            /// [`ops::BitXor`]), as in `flags ^ other`.
            ///
            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
            #[inline]
            #[must_use]
            pub const fn symmetric_difference(self, other: Self) -> Self {
                Self {
                    bits: self.bits ^ other.bits,
                }
            }
            /// Returns the complement of this set of flags.
            ///
            /// Specifically, the returned set contains all the flags which are
            /// not set in `self`, but which are allowed for this type.
            ///
            /// Alternatively, it can be thought of as the set difference
            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
            ///
            /// This is equivalent to using the `!` operator (e.g.
            /// [`ops::Not`]), as in `!flags`.
            ///
            /// [`Self::all()`]: Self::all
            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
            #[inline]
            #[must_use]
            pub const fn complement(self) -> Self {
                Self::from_bits_truncate(!self.bits)
            }
        }
        impl ::bitflags::_core::ops::BitOr for CallFlags {
            type Output = Self;
            /// Returns the union of the two sets of flags.
            #[inline]
            fn bitor(self, other: CallFlags) -> Self {
                Self {
                    bits: self.bits | other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitOrAssign for CallFlags {
            /// Adds the set of flags.
            #[inline]
            fn bitor_assign(&mut self, other: Self) {
                self.bits |= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitXor for CallFlags {
            type Output = Self;
            /// Returns the left flags, but with all the right flags toggled.
            #[inline]
            fn bitxor(self, other: Self) -> Self {
                Self {
                    bits: self.bits ^ other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitXorAssign for CallFlags {
            /// Toggles the set of flags.
            #[inline]
            fn bitxor_assign(&mut self, other: Self) {
                self.bits ^= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitAnd for CallFlags {
            type Output = Self;
            /// Returns the intersection between the two sets of flags.
            #[inline]
            fn bitand(self, other: Self) -> Self {
                Self {
                    bits: self.bits & other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitAndAssign for CallFlags {
            /// Disables all flags disabled in the set.
            #[inline]
            fn bitand_assign(&mut self, other: Self) {
                self.bits &= other.bits;
            }
        }
        impl ::bitflags::_core::ops::Sub for CallFlags {
            type Output = Self;
            /// Returns the set difference of the two sets of flags.
            #[inline]
            fn sub(self, other: Self) -> Self {
                Self {
                    bits: self.bits & !other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::SubAssign for CallFlags {
            /// Disables all flags enabled in the set.
            #[inline]
            fn sub_assign(&mut self, other: Self) {
                self.bits &= !other.bits;
            }
        }
        impl ::bitflags::_core::ops::Not for CallFlags {
            type Output = Self;
            /// Returns the complement of this set of flags.
            #[inline]
            fn not(self) -> Self {
                Self { bits: !self.bits } & Self::all()
            }
        }
        impl ::bitflags::_core::iter::Extend<CallFlags> for CallFlags {
            fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                &mut self,
                iterator: T,
            ) {
                for item in iterator {
                    self.insert(item)
                }
            }
        }
        impl ::bitflags::_core::iter::FromIterator<CallFlags> for CallFlags {
            fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                iterator: T,
            ) -> Self {
                let mut result = Self::empty();
                result.extend(iterator);
                result
            }
        }
        /// The kind of call that should be performed.
        enum CallType {
            /// Execute another instantiated contract
            Call {
                callee_ptr: u32,
                value_ptr: u32,
                deposit_ptr: u32,
                weight: Weight,
            },
            /// Execute deployed code in the context (storage, account ID, value) of the caller contract
            DelegateCall { code_hash_ptr: u32 },
        }
        impl CallType {
            fn cost(&self) -> RuntimeCosts {
                match self {
                    CallType::Call { .. } => RuntimeCosts::CallBase,
                    CallType::DelegateCall { .. } => RuntimeCosts::DelegateCallBase,
                }
            }
        }
        /// This is only appropriate when writing out data of constant size that does not depend on user
        /// input. In this case the costs for this copy was already charged as part of the token at
        /// the beginning of the API entry point.
        fn already_charged(_: u32) -> Option<RuntimeCosts> {
            None
        }
        /// Can only be used for one call.
        pub struct Runtime<'a, E: Ext + 'a> {
            ext: &'a mut E,
            input_data: Option<Vec<u8>>,
            memory: Option<Memory>,
            chain_extension: Option<Box<<E::T as Config>::ChainExtension>>,
        }
        impl<'a, E: Ext + 'a> Runtime<'a, E> {
            pub fn new(ext: &'a mut E, input_data: Vec<u8>) -> Self {
                Runtime {
                    ext,
                    input_data: Some(input_data),
                    memory: None,
                    chain_extension: Some(Box::new(Default::default())),
                }
            }
            pub fn memory(&self) -> Option<Memory> {
                self.memory
            }
            pub fn set_memory(&mut self, memory: Memory) {
                self.memory = Some(memory);
            }
            /// Converts the sandbox result and the runtime state into the execution outcome.
            pub fn to_execution_result(
                self,
                sandbox_result: Result<(), wasmi::Error>,
            ) -> ExecResult {
                use TrapReason::*;
                match sandbox_result {
                    Ok(_) => Ok(ExecReturnValue {
                        flags: ReturnFlags::empty(),
                        data: Vec::new(),
                    }),
                    Err(wasmi::Error::Trap(trap)) => {
                        let reason: TrapReason =
                            trap.downcast().ok_or(Error::<E::T>::ContractTrapped)?;
                        match reason {
                            Return(ReturnData { flags, data }) => {
                                let flags = ReturnFlags::from_bits(flags)
                                    .ok_or(Error::<E::T>::InvalidCallFlags)?;
                                Ok(ExecReturnValue { flags, data })
                            }
                            Termination => Ok(ExecReturnValue {
                                flags: ReturnFlags::empty(),
                                data: Vec::new(),
                            }),
                            SupervisorError(error) => return Err(error.into()),
                        }
                    }
                    Err(_) => Err(Error::<E::T>::CodeRejected.into()),
                }
            }
            /// Get a mutable reference to the inner `Ext`.
            ///
            /// This is mainly for the chain extension to have access to the environment the
            /// contract is executing in.
            pub fn ext(&mut self) -> &mut E {
                self.ext
            }
            /// Charge the gas meter with the specified token.
            ///
            /// Returns `Err(HostError)` if there is not enough gas.
            pub fn charge_gas(
                &mut self,
                costs: RuntimeCosts,
            ) -> Result<ChargedAmount, DispatchError> {
                {
                    let token = costs.token(&self.ext.schedule().host_fn_weights);
                    self.ext.gas_meter().charge(token)
                }
            }
            /// Adjust a previously charged amount down to its actual amount.
            ///
            /// This is when a maximum a priori amount was charged and then should be partially
            /// refunded to match the actual amount.
            pub fn adjust_gas(&mut self, charged: ChargedAmount, actual_costs: RuntimeCosts) {
                let token = actual_costs.token(&self.ext.schedule().host_fn_weights);
                self.ext.gas_meter().adjust_gas(charged, token);
            }
            /// Read designated chunk from the sandbox memory.
            ///
            /// Returns `Err` if one of the following conditions occurs:
            ///
            /// - requested buffer is not within the bounds of the sandbox memory.
            /// 从沙盒内存中读取指定的区块。
            /// 如果出现下列情况之一，则返回 Err ：
            /// 请求的缓冲区不在沙盒内存的范围内
            pub fn read_sandbox_memory(
                &self,
                memory: &[u8],
                ptr: u32,
                len: u32,
            ) -> Result<Vec<u8>, DispatchError> {
                {
                    if !(len <= self.ext.schedule().limits.max_memory_size()) {
                        {
                            return Err(Error::<E::T>::OutOfBounds.into());
                        };
                    }
                };
                let mut buf = ::alloc::vec::from_elem(0u8, len as usize);
                self.read_sandbox_memory_into_buf(memory, ptr, buf.as_mut_slice())?;
                Ok(buf)
            }
            /// Read designated chunk from the sandbox memory into the supplied buffer.
            ///
            /// Returns `Err` if one of the following conditions occurs:
            ///
            /// - requested buffer is not within the bounds of the sandbox memory.
            pub fn read_sandbox_memory_into_buf(
                &self,
                memory: &[u8],
                ptr: u32,
                buf: &mut [u8],
            ) -> Result<(), DispatchError> {
                let ptr = ptr as usize;
                let bound_checked = memory
                    .get(ptr..ptr + buf.len())
                    .ok_or_else(|| Error::<E::T>::OutOfBounds)?;
                buf.copy_from_slice(bound_checked);
                Ok(())
            }
            /// Reads and decodes a type with a size fixed at compile time from contract memory.
            ///
            /// # Note
            ///
            /// The weight of reading a fixed value is included in the overall weight of any
            /// contract callable function.
            pub fn read_sandbox_memory_as<D: Decode + MaxEncodedLen>(
                &self,
                memory: &[u8],
                ptr: u32,
            ) -> Result<D, DispatchError> {
                let ptr = ptr as usize;
                let mut bound_checked = memory
                    .get(ptr..ptr + D::max_encoded_len() as usize)
                    .ok_or_else(|| Error::<E::T>::OutOfBounds)?;
                let decoded =
                    D::decode_all_with_depth_limit(MAX_DECODE_NESTING, &mut bound_checked)
                        .map_err(|_| DispatchError::from(Error::<E::T>::DecodingFailed))?;
                Ok(decoded)
            }
            /// Read designated chunk from the sandbox memory and attempt to decode into the specified type.
            ///
            /// Returns `Err` if one of the following conditions occurs:
            ///
            /// - requested buffer is not within the bounds of the sandbox memory.
            /// - the buffer contents cannot be decoded as the required type.
            ///
            /// # Note
            ///
            /// There must be an extra benchmark for determining the influence of `len` with
            /// regard to the overall weight.
            pub fn read_sandbox_memory_as_unbounded<D: Decode>(
                &self,
                memory: &[u8],
                ptr: u32,
                len: u32,
            ) -> Result<D, DispatchError> {
                let ptr = ptr as usize;
                let mut bound_checked = memory
                    .get(ptr..ptr + len as usize)
                    .ok_or_else(|| Error::<E::T>::OutOfBounds)?;
                let decoded =
                    D::decode_all_with_depth_limit(MAX_DECODE_NESTING, &mut bound_checked)
                        .map_err(|_| DispatchError::from(Error::<E::T>::DecodingFailed))?;
                Ok(decoded)
            }
            /// Write the given buffer and its length to the designated locations in sandbox memory and
            /// charge gas according to the token returned by `create_token`.
            /// `out_ptr` is the location in sandbox memory where `buf` should be written to.
            /// `out_len_ptr` is an in-out location in sandbox memory. It is read to determine the
            /// length of the buffer located at `out_ptr`. If that buffer is large enough the actual
            /// `buf.len()` is written to this location.
            ///
            /// If `out_ptr` is set to the sentinel value of `SENTINEL` and `allow_skip` is true the
            /// operation is skipped and `Ok` is returned. This is supposed to help callers to make copying
            /// output optional. For example to skip copying back the output buffer of an `seal_call`
            /// when the caller is not interested in the result.
            ///
            /// `create_token` can optionally instruct this function to charge the gas meter with the token
            /// it returns. `create_token` receives the variable amount of bytes that are about to be copied
            /// by this function.
            ///
            /// In addition to the error conditions of `write_sandbox_memory` this functions returns
            /// `Err` if the size of the buffer located at `out_ptr` is too small to fit `buf`.
            pub fn write_sandbox_output(
                &mut self,
                memory: &mut [u8],
                out_ptr: u32,
                out_len_ptr: u32,
                buf: &[u8],
                allow_skip: bool,
                create_token: impl FnOnce(u32) -> Option<RuntimeCosts>,
            ) -> Result<(), DispatchError> {
                if allow_skip && out_ptr == SENTINEL {
                    return Ok(());
                }
                let buf_len = buf.len() as u32;
                let len: u32 = self.read_sandbox_memory_as(memory, out_len_ptr)?;
                if len < buf_len {
                    return Err(Error::<E::T>::OutputBufferTooSmall.into());
                }
                if let Some(costs) = create_token(buf_len) {
                    self.charge_gas(costs)?;
                }
                self.write_sandbox_memory(memory, out_ptr, buf)?;
                self.write_sandbox_memory(memory, out_len_ptr, &buf_len.encode())
            }
            /// Write the given buffer to the designated location in the sandbox memory.
            ///
            /// Returns `Err` if one of the following conditions occurs:
            ///
            /// - designated area is not within the bounds of the sandbox memory.
            fn write_sandbox_memory(
                &self,
                memory: &mut [u8],
                ptr: u32,
                buf: &[u8],
            ) -> Result<(), DispatchError> {
                let ptr = ptr as usize;
                let bound_checked = memory
                    .get_mut(ptr..ptr + buf.len())
                    .ok_or_else(|| Error::<E::T>::OutOfBounds)?;
                bound_checked.copy_from_slice(buf);
                Ok(())
            }
            /// Computes the given hash function on the supplied input.
            ///
            /// Reads from the sandboxed input buffer into an intermediate buffer.
            /// Returns the result directly to the output buffer of the sandboxed memory.
            ///
            /// It is the callers responsibility to provide an output buffer that
            /// is large enough to hold the expected amount of bytes returned by the
            /// chosen hash function.
            ///
            /// # Note
            ///
            /// The `input` and `output` buffers may overlap.
            fn compute_hash_on_intermediate_buffer<F, R>(
                &self,
                memory: &mut [u8],
                hash_fn: F,
                input_ptr: u32,
                input_len: u32,
                output_ptr: u32,
            ) -> Result<(), DispatchError>
            where
                F: FnOnce(&[u8]) -> R,
                R: AsRef<[u8]>,
            {
                let input = self.read_sandbox_memory(memory, input_ptr, input_len)?;
                let hash = hash_fn(&input);
                self.write_sandbox_memory(memory, output_ptr, hash.as_ref())?;
                Ok(())
            }
            /// Fallible conversion of `DispatchError` to `ReturnCode`.
            fn err_into_return_code(from: DispatchError) -> Result<ReturnCode, DispatchError> {
                use ReturnCode::*;
                let transfer_failed = Error::<E::T>::TransferFailed.into();
                let no_code = Error::<E::T>::CodeNotFound.into();
                let not_found = Error::<E::T>::ContractNotFound.into();
                match from {
                    x if x == transfer_failed => Ok(TransferFailed),
                    x if x == no_code => Ok(CodeNotFound),
                    x if x == not_found => Ok(NotCallable),
                    err => Err(err),
                }
            }
            /// Fallible conversion of a `ExecResult` to `ReturnCode`.
            fn exec_into_return_code(from: ExecResult) -> Result<ReturnCode, DispatchError> {
                use crate::exec::ErrorOrigin::Callee;
                let ExecError { error, origin } = match from {
                    Ok(retval) => return Ok(retval.into()),
                    Err(err) => err,
                };
                match (error, origin) {
                    (_, Callee) => Ok(ReturnCode::CalleeTrapped),
                    (err, _) => Self::err_into_return_code(err),
                }
            }
            fn decode_key(
                &self,
                memory: &[u8],
                key_type: KeyType,
                key_ptr: u32,
            ) -> Result<crate::exec::Key<E::T>, TrapReason> {
                let res = match key_type {
                    KeyType::Fix => {
                        let key = self.read_sandbox_memory(memory, key_ptr, 32u32)?;
                        Key::try_from_fix(key)
                    }
                    KeyType::Var(len) => {
                        {
                            if !(len <= <<E as Ext>::T as Config>::MaxStorageKeyLen::get()) {
                                {
                                    return Err(Error::<E::T>::DecodingFailed.into());
                                };
                            }
                        };
                        let key = self.read_sandbox_memory(memory, key_ptr, len)?;
                        Key::try_from_var(key)
                    }
                };
                res.map_err(|_| Error::<E::T>::DecodingFailed.into())
            }
            fn set_storage(
                &mut self,
                memory: &[u8],
                key_type: KeyType,
                key_ptr: u32,
                value_ptr: u32,
                value_len: u32,
            ) -> Result<u32, TrapReason> {
                let max_size = self.ext.max_value_size();
                let charged = self.charge_gas(RuntimeCosts::SetStorage {
                    new_bytes: value_len,
                    old_bytes: max_size,
                })?;
                if value_len > max_size {
                    return Err(Error::<E::T>::ValueTooLarge.into());
                }
                let key = self.decode_key(memory, key_type, key_ptr)?;
                let value = Some(self.read_sandbox_memory(memory, value_ptr, value_len)?);
                let write_outcome = self.ext.set_storage(&key, value, false)?;
                self.adjust_gas(
                    charged,
                    RuntimeCosts::SetStorage {
                        new_bytes: value_len,
                        old_bytes: write_outcome.old_len(),
                    },
                );
                Ok(write_outcome.old_len_with_sentinel())
            }
            fn clear_storage(
                &mut self,
                memory: &[u8],
                key_type: KeyType,
                key_ptr: u32,
            ) -> Result<u32, TrapReason> {
                let charged =
                    self.charge_gas(RuntimeCosts::ClearStorage(self.ext.max_value_size()))?;
                let key = self.decode_key(memory, key_type, key_ptr)?;
                let outcome = self.ext.set_storage(&key, None, false)?;
                self.adjust_gas(charged, RuntimeCosts::ClearStorage(outcome.old_len()));
                Ok(outcome.old_len_with_sentinel())
            }
            fn get_storage(
                &mut self,
                memory: &mut [u8],
                key_type: KeyType,
                key_ptr: u32,
                out_ptr: u32,
                out_len_ptr: u32,
            ) -> Result<ReturnCode, TrapReason> {
                let charged =
                    self.charge_gas(RuntimeCosts::GetStorage(self.ext.max_value_size()))?;
                let key = self.decode_key(memory, key_type, key_ptr)?;
                let outcome = self.ext.get_storage(&key);
                if let Some(value) = outcome {
                    self.adjust_gas(charged, RuntimeCosts::GetStorage(value.len() as u32));
                    self.write_sandbox_output(
                        memory,
                        out_ptr,
                        out_len_ptr,
                        &value,
                        false,
                        already_charged,
                    )?;
                    Ok(ReturnCode::Success)
                } else {
                    self.adjust_gas(charged, RuntimeCosts::GetStorage(0));
                    Ok(ReturnCode::KeyNotFound)
                }
            }
            fn contains_storage(
                &mut self,
                memory: &[u8],
                key_type: KeyType,
                key_ptr: u32,
            ) -> Result<u32, TrapReason> {
                let charged =
                    self.charge_gas(RuntimeCosts::ContainsStorage(self.ext.max_value_size()))?;
                let key = self.decode_key(memory, key_type, key_ptr)?;
                let outcome = self.ext.get_storage_size(&key);
                self.adjust_gas(charged, RuntimeCosts::ClearStorage(outcome.unwrap_or(0)));
                Ok(outcome.unwrap_or(SENTINEL))
            }
            fn call(
                &mut self,
                memory: &mut [u8],
                flags: CallFlags,
                call_type: CallType,
                input_data_ptr: u32,
                input_data_len: u32,
                output_ptr: u32,
                output_len_ptr: u32,
            ) -> Result<ReturnCode, TrapReason> {
                self.charge_gas(call_type.cost())?;
                let input_data = if flags.contains(CallFlags::CLONE_INPUT) {
                    let input = self
                        .input_data
                        .as_ref()
                        .ok_or(Error::<E::T>::InputForwarded)?;
                    {
                        let token = RuntimeCosts::CallInputCloned(input.len() as u32)
                            .token(&self.ext.schedule().host_fn_weights);
                        self.ext.gas_meter().charge(token)
                    }?;
                    input.clone()
                } else if flags.contains(CallFlags::FORWARD_INPUT) {
                    self.input_data
                        .take()
                        .ok_or(Error::<E::T>::InputForwarded)?
                } else {
                    self.charge_gas(RuntimeCosts::CopyFromContract(input_data_len))?;
                    self.read_sandbox_memory(memory, input_data_ptr, input_data_len)?
                };
                let call_outcome = match call_type {
                    CallType::Call {
                        callee_ptr,
                        value_ptr,
                        deposit_ptr,
                        weight,
                    } => {
                        let callee: <<E as Ext>::T as frame_system::Config>::AccountId =
                            self.read_sandbox_memory_as(memory, callee_ptr)?;
                        let deposit_limit: BalanceOf<<E as Ext>::T> = if deposit_ptr == SENTINEL {
                            BalanceOf::<<E as Ext>::T>::zero()
                        } else {
                            self.read_sandbox_memory_as(memory, deposit_ptr)?
                        };
                        let value: BalanceOf<<E as Ext>::T> =
                            self.read_sandbox_memory_as(memory, value_ptr)?;
                        if value > 0u32.into() {
                            self.charge_gas(RuntimeCosts::CallSurchargeTransfer)?;
                        }
                        self.ext.call(
                            weight,
                            deposit_limit,
                            callee,
                            value,
                            input_data,
                            flags.contains(CallFlags::ALLOW_REENTRY),
                        )
                    }
                    CallType::DelegateCall { code_hash_ptr } => {
                        if flags.contains(CallFlags::ALLOW_REENTRY) {
                            return Err(Error::<E::T>::InvalidCallFlags.into());
                        }
                        let code_hash = self.read_sandbox_memory_as(memory, code_hash_ptr)?;
                        self.ext.delegate_call(code_hash, input_data)
                    }
                };
                if flags.contains(CallFlags::TAIL_CALL) {
                    if let Ok(return_value) = call_outcome {
                        return Err(TrapReason::Return(ReturnData {
                            flags: return_value.flags.bits(),
                            data: return_value.data,
                        }));
                    }
                }
                if let Ok(output) = &call_outcome {
                    self.write_sandbox_output(
                        memory,
                        output_ptr,
                        output_len_ptr,
                        &output.data,
                        true,
                        |len| Some(RuntimeCosts::CopyToContract(len)),
                    )?;
                }
                Ok(Runtime::<E>::exec_into_return_code(call_outcome)?)
            }
            fn instantiate(
                &mut self,
                memory: &mut [u8],
                code_hash_ptr: u32,
                weight: Weight,
                deposit_ptr: u32,
                value_ptr: u32,
                input_data_ptr: u32,
                input_data_len: u32,
                address_ptr: u32,
                address_len_ptr: u32,
                output_ptr: u32,
                output_len_ptr: u32,
                salt_ptr: u32,
                salt_len: u32,
            ) -> Result<ReturnCode, TrapReason> {
                self.charge_gas(RuntimeCosts::InstantiateBase {
                    input_data_len,
                    salt_len,
                })?;
                let deposit_limit: BalanceOf<<E as Ext>::T> = if deposit_ptr == SENTINEL {
                    BalanceOf::<<E as Ext>::T>::zero()
                } else {
                    self.read_sandbox_memory_as(memory, deposit_ptr)?
                };
                let value: BalanceOf<<E as Ext>::T> =
                    self.read_sandbox_memory_as(memory, value_ptr)?;
                if value > 0u32.into() {
                    self.charge_gas(RuntimeCosts::InstantiateSurchargeTransfer)?;
                }
                let code_hash: CodeHash<<E as Ext>::T> =
                    self.read_sandbox_memory_as(memory, code_hash_ptr)?;
                let input_data =
                    self.read_sandbox_memory(memory, input_data_ptr, input_data_len)?;
                let salt = self.read_sandbox_memory(memory, salt_ptr, salt_len)?;
                let instantiate_outcome = self.ext.instantiate(
                    weight,
                    deposit_limit,
                    code_hash,
                    value,
                    input_data,
                    &salt,
                );
                if let Ok((address, output)) = &instantiate_outcome {
                    if !output.flags.contains(ReturnFlags::REVERT) {
                        self.write_sandbox_output(
                            memory,
                            address_ptr,
                            address_len_ptr,
                            &address.encode(),
                            true,
                            already_charged,
                        )?;
                    }
                    self.write_sandbox_output(
                        memory,
                        output_ptr,
                        output_len_ptr,
                        &output.data,
                        true,
                        |len| Some(RuntimeCosts::CopyToContract(len)),
                    )?;
                }
                Ok(Runtime::<E>::exec_into_return_code(
                    instantiate_outcome.map(|(_, retval)| retval),
                )?)
            }
            fn terminate(&mut self, memory: &[u8], beneficiary_ptr: u32) -> Result<(), TrapReason> {
                self.charge_gas(RuntimeCosts::Terminate)?;
                let beneficiary: <<E as Ext>::T as frame_system::Config>::AccountId =
                    self.read_sandbox_memory_as(memory, beneficiary_ptr)?;
                self.ext.terminate(&beneficiary)?;
                Err(TrapReason::Termination)
            }
        }
        pub struct Env;
        impl<'a, E: Ext> crate::wasm::Environment<crate::wasm::runtime::Runtime<'a, E>> for Env {
            fn define(
                store: &mut ::wasmi::Store<crate::wasm::Runtime<E>>,
                linker: &mut ::wasmi::Linker<crate::wasm::Runtime<E>>,
                allow_unstable: AllowUnstableInterface,
                allow_deprecated: AllowDeprecatedInterface,
            ) -> Result<(), ::wasmi::errors::LinkerError> {
                let __allow_unstable__ = match allow_unstable {
                    AllowUnstableInterface::Yes => true,
                    _ => false,
                };
                let __allow_deprecated__ = match allow_deprecated {
                    AllowDeprecatedInterface::Yes => true,
                    _ => false,
                };
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "gas" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , amount : u64 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: MeteringBlock (amount)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::gas(amount: {0:?}) = {1:?}\n" , amount , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: MeteringBlock (amount)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) . map (| _ | ()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::set_storage(key_ptr: {0:?}, value_ptr: {1:?}, value_len: {2:?}) = {3:?}\n" , key_ptr , value_ptr , value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) . map (| _ | ()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::set_storage(key_ptr: {0:?}, value_ptr: {1:?}, value_len: {2:?}) = {3:?}\n" , key_ptr , value_ptr , value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal2" , "set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . set_storage (memory , KeyType :: Var (key_len) , key_ptr , value_ptr , value_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal2::set_storage(key_ptr: {0:?}, key_len: {1:?}, value_ptr: {2:?}, value_len: {3:?}) = {4:?}\n" , key_ptr , key_len , value_ptr , value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . set_storage (memory , KeyType :: Var (key_len) , key_ptr , value_ptr , value_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . clear_storage (memory , KeyType :: Fix , key_ptr) . map (| _ | ()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::clear_storage(key_ptr: {0:?}) = {1:?}\n" , key_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . clear_storage (memory , KeyType :: Fix , key_ptr) . map (| _ | ()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . clear_storage (memory , KeyType :: Var (key_len) , key_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::clear_storage(key_ptr: {0:?}, key_len: {1:?}) = {2:?}\n" , key_ptr , key_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . clear_storage (memory , KeyType :: Var (key_len) , key_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . get_storage (memory , KeyType :: Fix , key_ptr , out_ptr , out_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::get_storage(key_ptr: {0:?}, out_ptr: {1:?}, out_len_ptr: {2:?}) = {3:?}\n" , key_ptr , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . get_storage (memory , KeyType :: Fix , key_ptr , out_ptr , out_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . get_storage (memory , KeyType :: Var (key_len) , key_ptr , out_ptr , out_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::get_storage(key_ptr: {0:?}, key_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , key_ptr , key_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . get_storage (memory , KeyType :: Var (key_len) , key_ptr , out_ptr , out_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker.define(
                        "seal0",
                        "contains_storage",
                        ::wasmi::Func::wrap(
                            &mut *store,
                            |mut __caller__: ::wasmi::Caller<crate::wasm::Runtime<E>>,
                             key_ptr: u32|
                             -> ::core::result::Result<
                                ::core::primitive::u32,
                                ::wasmi::core::Trap,
                            > {
                                let mut func = || -> Result<u32, TrapReason> {
                                    let (memory, ctx) = __caller__
                                        .data()
                                        .memory()
                                        .expect("Memory must be set when setting up host data; qed")
                                        .data_and_store_mut(&mut __caller__);
                                    if {
                                        let lvl = ::log::Level::Trace;
                                        lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                            && ::log::__private_api_enabled(
                                                lvl,
                                                "runtime::contracts::strace",
                                            )
                                    } {
                                        let result =
                                            { ctx.contains_storage(memory, KeyType::Fix, key_ptr) };
                                        {
                                            use sp_std::fmt::Write;
                                            let mut w = sp_std::Writer::default();
                                            let _ = (&mut w).write_fmt(format_args!(
                                                "seal0::contains_storage(key_ptr: {0:?}) = {1:?}\n",
                                                key_ptr, result
                                            ));
                                            let msg = core::str::from_utf8(&w.inner())
                                                .unwrap_or_default();
                                            ctx.ext().append_debug_buffer(msg);
                                        }
                                        result
                                    } else {
                                        {
                                            ctx.contains_storage(memory, KeyType::Fix, key_ptr)
                                        }
                                    }
                                };
                                func()
                                    .map_err(|reason| ::wasmi::core::Trap::from(reason))
                                    .map(::core::convert::Into::into)
                            },
                        ),
                    )?;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . contains_storage (memory , KeyType :: Var (key_len) , key_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::contains_storage(key_ptr: {0:?}, key_len: {1:?}) = {2:?}\n" , key_ptr , key_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . contains_storage (memory , KeyType :: Var (key_len) , key_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "take_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let charged = ctx . charge_gas (RuntimeCosts :: TakeStorage (ctx . ext . max_value_size ())) ? ; { if ! (key_len <= < < E as Ext > :: T as Config > :: MaxStorageKeyLen :: get ()) { { return Err (Error :: < E :: T > :: DecodingFailed . into ()) } ; } } ; let key = ctx . read_sandbox_memory (memory , key_ptr , key_len) ? ; if let crate :: storage :: WriteOutcome :: Taken (value) = ctx . ext . set_storage (& Key :: < E :: T > :: try_from_var (key) . map_err (| _ | Error :: < E :: T > :: DecodingFailed) ? , None , true) ? { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (value . len () as u32)) ; ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (0)) ; Ok (ReturnCode :: KeyNotFound) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::take_storage(key_ptr: {0:?}, key_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , key_ptr , key_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let charged = ctx . charge_gas (RuntimeCosts :: TakeStorage (ctx . ext . max_value_size ())) ? ; { if ! (key_len <= < < E as Ext > :: T as Config > :: MaxStorageKeyLen :: get ()) { { return Err (Error :: < E :: T > :: DecodingFailed . into ()) } ; } } ; let key = ctx . read_sandbox_memory (memory , key_ptr , key_len) ? ; if let crate :: storage :: WriteOutcome :: Taken (value) = ctx . ext . set_storage (& Key :: < E :: T > :: try_from_var (key) . map_err (| _ | Error :: < E :: T > :: DecodingFailed) ? , None , true) ? { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (value . len () as u32)) ; ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (0)) ; Ok (ReturnCode :: KeyNotFound) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "transfer" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 , _account_len : u32 , value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Transfer) ? ; let callee : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; let value : BalanceOf < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , value_ptr) ? ; let result = ctx . ext . transfer (& callee , value) ; match result { Ok (()) => Ok (ReturnCode :: Success) , Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::transfer(account_ptr: {0:?}, _account_len: {1:?}, value_ptr: {2:?}, _value_len: {3:?}) = {4:?}\n" , account_ptr , _account_len , value_ptr , _value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Transfer) ? ; let callee : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; let value : BalanceOf < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , value_ptr) ? ; let result = ctx . ext . transfer (& callee , value) ; match result { Ok (()) => Ok (ReturnCode :: Success) , Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , callee_ptr : u32 , _callee_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: ALLOW_REENTRY , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::call(callee_ptr: {0:?}, _callee_len: {1:?}, gas: {2:?}, value_ptr: {3:?}, _value_len: {4:?}, input_data_ptr: {5:?}, input_data_len: {6:?}, output_ptr: {7:?}, output_len_ptr: {8:?}) = {9:?}\n" , callee_ptr , _callee_len , gas , value_ptr , _value_len , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: ALLOW_REENTRY , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , flags : u32 , callee_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::call(flags: {0:?}, callee_ptr: {1:?}, gas: {2:?}, value_ptr: {3:?}, input_data_ptr: {4:?}, input_data_len: {5:?}, output_ptr: {6:?}, output_len_ptr: {7:?}) = {8:?}\n" , flags , callee_ptr , gas , value_ptr , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal2" , "call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , flags : u32 , callee_ptr : u32 , ref_time_limit : u64 , proof_size_limit : u64 , deposit_ptr : u32 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: Call { callee_ptr , value_ptr , deposit_ptr , weight : Weight :: from_parts (ref_time_limit , proof_size_limit) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal2::call(flags: {0:?}, callee_ptr: {1:?}, ref_time_limit: {2:?}, proof_size_limit: {3:?}, deposit_ptr: {4:?}, value_ptr: {5:?}, input_data_ptr: {6:?}, input_data_len: {7:?}, output_ptr: {8:?}, output_len_ptr: {9:?}) = {10:?}\n" , flags , callee_ptr , ref_time_limit , proof_size_limit , deposit_ptr , value_ptr , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: Call { callee_ptr , value_ptr , deposit_ptr , weight : Weight :: from_parts (ref_time_limit , proof_size_limit) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "delegate_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , flags : u32 , code_hash_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: DelegateCall { code_hash_ptr } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::delegate_call(flags: {0:?}, code_hash_ptr: {1:?}, input_data_ptr: {2:?}, input_data_len: {3:?}, output_ptr: {4:?}, output_len_ptr: {5:?}) = {6:?}\n" , flags , code_hash_ptr , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: DelegateCall { code_hash_ptr } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 , _code_hash_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::instantiate(code_hash_ptr: {0:?}, _code_hash_len: {1:?}, gas: {2:?}, value_ptr: {3:?}, _value_len: {4:?}, input_data_ptr: {5:?}, input_data_len: {6:?}, address_ptr: {7:?}, address_len_ptr: {8:?}, output_ptr: {9:?}, output_len_ptr: {10:?}, salt_ptr: {11:?}, salt_len: {12:?}) = {13:?}\n" , code_hash_ptr , _code_hash_len , gas , value_ptr , _value_len , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::instantiate(code_hash_ptr: {0:?}, gas: {1:?}, value_ptr: {2:?}, input_data_ptr: {3:?}, input_data_len: {4:?}, address_ptr: {5:?}, address_len_ptr: {6:?}, output_ptr: {7:?}, output_len_ptr: {8:?}, salt_ptr: {9:?}, salt_len: {10:?}) = {11:?}\n" , code_hash_ptr , gas , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal2" , "instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 , ref_time_limit : u64 , proof_size_limit : u64 , deposit_ptr : u32 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (ref_time_limit , proof_size_limit) , deposit_ptr , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal2::instantiate(code_hash_ptr: {0:?}, ref_time_limit: {1:?}, proof_size_limit: {2:?}, deposit_ptr: {3:?}, value_ptr: {4:?}, input_data_ptr: {5:?}, input_data_len: {6:?}, address_ptr: {7:?}, address_len_ptr: {8:?}, output_ptr: {9:?}, output_len_ptr: {10:?}, salt_ptr: {11:?}, salt_len: {12:?}) = {13:?}\n" , code_hash_ptr , ref_time_limit , proof_size_limit , deposit_ptr , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (ref_time_limit , proof_size_limit) , deposit_ptr , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , beneficiary_ptr : u32 , _beneficiary_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . terminate (memory , beneficiary_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::terminate(beneficiary_ptr: {0:?}, _beneficiary_len: {1:?}) = {2:?}\n" , beneficiary_ptr , _beneficiary_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . terminate (memory , beneficiary_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , beneficiary_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . terminate (memory , beneficiary_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::terminate(beneficiary_ptr: {0:?}) = {1:?}\n" , beneficiary_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . terminate (memory , beneficiary_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "input" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: InputBase) ? ; if let Some (input) = ctx . input_data . take () { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & input , false , | len | { Some (RuntimeCosts :: CopyToContract (len)) }) ? ; ctx . input_data = Some (input) ; Ok (()) } else { Err (Error :: < E :: T > :: InputForwarded . into ()) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::input(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: InputBase) ? ; if let Some (input) = ctx . input_data . take () { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & input , false , | len | { Some (RuntimeCosts :: CopyToContract (len)) }) ? ; ctx . input_data = Some (input) ; Ok (()) } else { Err (Error :: < E :: T > :: InputForwarded . into ()) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_return" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , flags : u32 , data_ptr : u32 , data_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Return (data_len)) ? ; Err (TrapReason :: Return (ReturnData { flags , data : ctx . read_sandbox_memory (memory , data_ptr , data_len) ? , })) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_return(flags: {0:?}, data_ptr: {1:?}, data_len: {2:?}) = {3:?}\n" , flags , data_ptr , data_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Return (data_len)) ? ; Err (TrapReason :: Return (ReturnData { flags , data : ctx . read_sandbox_memory (memory , data_ptr , data_len) ? , })) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "caller" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Caller) ? ; let caller = ctx . ext . caller () . account_id () ? . clone () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & caller . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::caller(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Caller) ? ; let caller = ctx . ext . caller () . account_id () ? . clone () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & caller . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "is_contract" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: IsContract) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; Ok (ctx . ext . is_contract (& address) as u32) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::is_contract(account_ptr: {0:?}) = {1:?}\n" , account_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: IsContract) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; Ok (ctx . ext . is_contract (& address) as u32) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: CodeHash) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; if let Some (value) = ctx . ext . code_hash (& address) { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value . encode () , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { Ok (ReturnCode :: KeyNotFound) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::code_hash(account_ptr: {0:?}, out_ptr: {1:?}, out_len_ptr: {2:?}) = {3:?}\n" , account_ptr , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: CodeHash) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; if let Some (value) = ctx . ext . code_hash (& address) { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value . encode () , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { Ok (ReturnCode :: KeyNotFound) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "own_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: OwnCodeHash) ? ; let code_hash_encoded = & ctx . ext . own_code_hash () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , code_hash_encoded , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::own_code_hash(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: OwnCodeHash) ? ; let code_hash_encoded = & ctx . ext . own_code_hash () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , code_hash_encoded , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "caller_is_origin" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: CallerIsOrigin) ? ; Ok (ctx . ext . caller_is_origin () as u32) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::caller_is_origin() = {0:?}\n" , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: CallerIsOrigin) ? ; Ok (ctx . ext . caller_is_origin () as u32) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "caller_is_root" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: CallerIsRoot) ? ; Ok (ctx . ext . caller_is_root () as u32) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::caller_is_root() = {0:?}\n" , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: CallerIsRoot) ? ; Ok (ctx . ext . caller_is_root () as u32) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Address) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . address () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::address(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Address) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . address () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "weight_to_fee" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , gas : u64 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let gas = Weight :: from_parts (gas , 0) ; ctx . charge_gas (RuntimeCosts :: WeightToFee) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . get_weight_price (gas) . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::weight_to_fee(gas: {0:?}, out_ptr: {1:?}, out_len_ptr: {2:?}) = {3:?}\n" , gas , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let gas = Weight :: from_parts (gas , 0) ; ctx . charge_gas (RuntimeCosts :: WeightToFee) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . get_weight_price (gas) . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "weight_to_fee" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , ref_time_limit : u64 , proof_size_limit : u64 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let weight = Weight :: from_parts (ref_time_limit , proof_size_limit) ; ctx . charge_gas (RuntimeCosts :: WeightToFee) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . get_weight_price (weight) . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::weight_to_fee(ref_time_limit: {0:?}, proof_size_limit: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , ref_time_limit , proof_size_limit , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let weight = Weight :: from_parts (ref_time_limit , proof_size_limit) ; ctx . charge_gas (RuntimeCosts :: WeightToFee) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . get_weight_price (weight) . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "gas_left" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: GasLeft) ? ; let gas_left = & ctx . ext . gas_meter () . gas_left () . ref_time () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , gas_left , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::gas_left(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: GasLeft) ? ; let gas_left = & ctx . ext . gas_meter () . gas_left () . ref_time () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , gas_left , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "gas_left" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: GasLeft) ? ; let gas_left = & ctx . ext . gas_meter () . gas_left () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , gas_left , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::gas_left(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: GasLeft) ? ; let gas_left = & ctx . ext . gas_meter () . gas_left () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , gas_left , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Balance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . balance () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::balance(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Balance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . balance () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "value_transferred" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: ValueTransferred) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . value_transferred () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::value_transferred(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: ValueTransferred) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . value_transferred () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . 0 . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::random(subject_ptr: {0:?}, subject_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , subject_ptr , subject_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . 0 . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal1" , "random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::random(subject_ptr: {0:?}, subject_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , subject_ptr , subject_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "now" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Now) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . now () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::now(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Now) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . now () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "minimum_balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: MinimumBalance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . minimum_balance () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::minimum_balance(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: MinimumBalance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . minimum_balance () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "tombstone_deposit" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let deposit = < BalanceOf < E :: T > > :: zero () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & deposit , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::tombstone_deposit(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let deposit = < BalanceOf < E :: T > > :: zero () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & deposit , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _dest_ptr : u32 , _dest_len : u32 , _code_hash_ptr : u32 , _code_hash_len : u32 , _rent_allowance_ptr : u32 , _rent_allowance_len : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::restore_to(_dest_ptr: {0:?}, _dest_len: {1:?}, _code_hash_ptr: {2:?}, _code_hash_len: {3:?}, _rent_allowance_ptr: {4:?}, _rent_allowance_len: {5:?}, _delta_ptr: {6:?}, _delta_count: {7:?}) = {8:?}\n" , _dest_ptr , _dest_len , _code_hash_ptr , _code_hash_len , _rent_allowance_ptr , _rent_allowance_len , _delta_ptr , _delta_count , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal1" , "restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _dest_ptr : u32 , _code_hash_ptr : u32 , _rent_allowance_ptr : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::restore_to(_dest_ptr: {0:?}, _code_hash_ptr: {1:?}, _rent_allowance_ptr: {2:?}, _delta_ptr: {3:?}, _delta_count: {4:?}) = {5:?}\n" , _dest_ptr , _code_hash_ptr , _rent_allowance_ptr , _delta_ptr , _delta_count , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::set_rent_allowance(_value_ptr: {0:?}, _value_len: {1:?}) = {2:?}\n" , _value_ptr , _value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal1" , "set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _value_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::set_rent_allowance(_value_ptr: {0:?}) = {1:?}\n" , _value_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let rent_allowance = < BalanceOf < E :: T > > :: max_value () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & rent_allowance , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::rent_allowance(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let rent_allowance = < BalanceOf < E :: T > > :: max_value () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & rent_allowance , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "deposit_event" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , topics_ptr : u32 , topics_len : u32 , data_ptr : u32 , data_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let num_topic = topics_len . checked_div (sp_std :: mem :: size_of :: < TopicOf < E :: T > > () as u32) . ok_or ("Zero sized topics are not allowed") ? ; ctx . charge_gas (RuntimeCosts :: DepositEvent { num_topic , len : data_len , }) ? ; if data_len > ctx . ext . max_value_size () { return Err (Error :: < E :: T > :: ValueTooLarge . into ()) } let topics : Vec < TopicOf < < E as Ext > :: T > > = match topics_len { 0 => Vec :: new () , _ => ctx . read_sandbox_memory_as_unbounded (memory , topics_ptr , topics_len) ? , } ; if topics . len () > ctx . ext . schedule () . limits . event_topics as usize { return Err (Error :: < E :: T > :: TooManyTopics . into ()) } let event_data = ctx . read_sandbox_memory (memory , data_ptr , data_len) ? ; ctx . ext . deposit_event (topics , event_data) ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::deposit_event(topics_ptr: {0:?}, topics_len: {1:?}, data_ptr: {2:?}, data_len: {3:?}) = {4:?}\n" , topics_ptr , topics_len , data_ptr , data_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let num_topic = topics_len . checked_div (sp_std :: mem :: size_of :: < TopicOf < E :: T > > () as u32) . ok_or ("Zero sized topics are not allowed") ? ; ctx . charge_gas (RuntimeCosts :: DepositEvent { num_topic , len : data_len , }) ? ; if data_len > ctx . ext . max_value_size () { return Err (Error :: < E :: T > :: ValueTooLarge . into ()) } let topics : Vec < TopicOf < < E as Ext > :: T > > = match topics_len { 0 => Vec :: new () , _ => ctx . read_sandbox_memory_as_unbounded (memory , topics_ptr , topics_len) ? , } ; if topics . len () > ctx . ext . schedule () . limits . event_topics as usize { return Err (Error :: < E :: T > :: TooManyTopics . into ()) } let event_data = ctx . read_sandbox_memory (memory , data_ptr , data_len) ? ; ctx . ext . deposit_event (topics , event_data) ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "block_number" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: BlockNumber) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . block_number () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::block_number(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: BlockNumber) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . block_number () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "hash_sha2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashSha256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , sha2_256 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::hash_sha2_256(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashSha256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , sha2_256 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "hash_keccak_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashKeccak256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , keccak_256 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::hash_keccak_256(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashKeccak256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , keccak_256 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "hash_blake2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashBlake256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_256 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::hash_blake2_256(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashBlake256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_256 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "hash_blake2_128" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashBlake128 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_128 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::hash_blake2_128(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashBlake128 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_128 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "call_chain_extension" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , id : u32 , input_ptr : u32 , input_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { use crate :: chain_extension :: { ChainExtension , Environment , RetVal , } ; if ! < E :: T as Config > :: ChainExtension :: enabled () { return Err (Error :: < E :: T > :: NoChainExtension . into ()) } let mut chain_extension = ctx . chain_extension . take () . expect ("Constructor initializes with `Some`. This is the only place where it is set to `None`.\
			It is always reset to `Some` afterwards. qed") ; let env = Environment :: new (ctx , memory , id , input_ptr , input_len , output_ptr , output_len_ptr) ; let ret = match chain_extension . call (env) ? { RetVal :: Converging (val) => Ok (val) , RetVal :: Diverging { flags , data } => Err (TrapReason :: Return (ReturnData { flags : flags . bits () , data , })) , } ; ctx . chain_extension = Some (chain_extension) ; ret } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::call_chain_extension(id: {0:?}, input_ptr: {1:?}, input_len: {2:?}, output_ptr: {3:?}, output_len_ptr: {4:?}) = {5:?}\n" , id , input_ptr , input_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { use crate :: chain_extension :: { ChainExtension , Environment , RetVal , } ; if ! < E :: T as Config > :: ChainExtension :: enabled () { return Err (Error :: < E :: T > :: NoChainExtension . into ()) } let mut chain_extension = ctx . chain_extension . take () . expect ("Constructor initializes with `Some`. This is the only place where it is set to `None`.\
			It is always reset to `Some` afterwards. qed") ; let env = Environment :: new (ctx , memory , id , input_ptr , input_len , output_ptr , output_len_ptr) ; let ret = match chain_extension . call (env) ? { RetVal :: Converging (val) => Ok (val) , RetVal :: Diverging { flags , data } => Err (TrapReason :: Return (ReturnData { flags : flags . bits () , data , })) , } ; ctx . chain_extension = Some (chain_extension) ; ret } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "debug_message" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , str_ptr : u32 , str_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let str_len = str_len . min (DebugBufferVec :: < E :: T > :: bound () as u32) ; ctx . charge_gas (RuntimeCosts :: DebugMessage (str_len)) ? ; if ctx . ext . append_debug_buffer ("") { let data = ctx . read_sandbox_memory (memory , str_ptr , str_len) ? ; if let Some (msg) = core :: str :: from_utf8 (& data) . ok () { ctx . ext . append_debug_buffer (msg) ; } } Ok (ReturnCode :: Success) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::debug_message(str_ptr: {0:?}, str_len: {1:?}) = {2:?}\n" , str_ptr , str_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let str_len = str_len . min (DebugBufferVec :: < E :: T > :: bound () as u32) ; ctx . charge_gas (RuntimeCosts :: DebugMessage (str_len)) ? ; if ctx . ext . append_debug_buffer ("") { let data = ctx . read_sandbox_memory (memory , str_ptr , str_len) ? ; if let Some (msg) = core :: str :: from_utf8 (& data) . ok () { ctx . ext . append_debug_buffer (msg) ; } } Ok (ReturnCode :: Success) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "call_runtime" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , call_ptr : u32 , call_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { use frame_support :: dispatch :: { extract_actual_weight , GetDispatchInfo , } ; ctx . charge_gas (RuntimeCosts :: CopyFromContract (call_len)) ? ; let call : < E :: T as Config > :: RuntimeCall = ctx . read_sandbox_memory_as_unbounded (memory , call_ptr , call_len) ? ; let dispatch_info = call . get_dispatch_info () ; let charged = ctx . charge_gas (RuntimeCosts :: CallRuntime (dispatch_info . weight)) ? ; let result = ctx . ext . call_runtime (call) ; let actual_weight = extract_actual_weight (& result , & dispatch_info) ; ctx . adjust_gas (charged , RuntimeCosts :: CallRuntime (actual_weight)) ; match result { Ok (_) => Ok (ReturnCode :: Success) , Err (e) => { if ctx . ext . append_debug_buffer ("") { ctx . ext . append_debug_buffer ("seal0::call_runtime failed with: ") ; ctx . ext . append_debug_buffer (e . into ()) ; } ; Ok (ReturnCode :: CallRuntimeFailed) } } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::call_runtime(call_ptr: {0:?}, call_len: {1:?}) = {2:?}\n" , call_ptr , call_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { use frame_support :: dispatch :: { extract_actual_weight , GetDispatchInfo , } ; ctx . charge_gas (RuntimeCosts :: CopyFromContract (call_len)) ? ; let call : < E :: T as Config > :: RuntimeCall = ctx . read_sandbox_memory_as_unbounded (memory , call_ptr , call_len) ? ; let dispatch_info = call . get_dispatch_info () ; let charged = ctx . charge_gas (RuntimeCosts :: CallRuntime (dispatch_info . weight)) ? ; let result = ctx . ext . call_runtime (call) ; let actual_weight = extract_actual_weight (& result , & dispatch_info) ; ctx . adjust_gas (charged , RuntimeCosts :: CallRuntime (actual_weight)) ; match result { Ok (_) => Ok (ReturnCode :: Success) , Err (e) => { if ctx . ext . append_debug_buffer ("") { ctx . ext . append_debug_buffer ("seal0::call_runtime failed with: ") ; ctx . ext . append_debug_buffer (e . into ()) ; } ; Ok (ReturnCode :: CallRuntimeFailed) } } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "ecdsa_recover" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , signature_ptr : u32 , message_hash_ptr : u32 , output_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: EcdsaRecovery) ? ; let mut signature : [u8 ; 65] = [0 ; 65] ; ctx . read_sandbox_memory_into_buf (memory , signature_ptr , & mut signature) ? ; let mut message_hash : [u8 ; 32] = [0 ; 32] ; ctx . read_sandbox_memory_into_buf (memory , message_hash_ptr , & mut message_hash) ? ; let result = ctx . ext . ecdsa_recover (& signature , & message_hash) ; match result { Ok (pub_key) => { ctx . write_sandbox_memory (memory , output_ptr , pub_key . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::ecdsa_recover(signature_ptr: {0:?}, message_hash_ptr: {1:?}, output_ptr: {2:?}) = {3:?}\n" , signature_ptr , message_hash_ptr , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: EcdsaRecovery) ? ; let mut signature : [u8 ; 65] = [0 ; 65] ; ctx . read_sandbox_memory_into_buf (memory , signature_ptr , & mut signature) ? ; let mut message_hash : [u8 ; 32] = [0 ; 32] ; ctx . read_sandbox_memory_into_buf (memory , message_hash_ptr , & mut message_hash) ? ; let result = ctx . ext . ecdsa_recover (& signature , & message_hash) ; match result { Ok (pub_key) => { ctx . write_sandbox_memory (memory , output_ptr , pub_key . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "sr25519_verify" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , signature_ptr : u32 , pub_key_ptr : u32 , message_len : u32 , message_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Sr25519Verify (message_len)) ? ; let mut signature : [u8 ; 64] = [0 ; 64] ; ctx . read_sandbox_memory_into_buf (memory , signature_ptr , & mut signature) ? ; let mut pub_key : [u8 ; 32] = [0 ; 32] ; ctx . read_sandbox_memory_into_buf (memory , pub_key_ptr , & mut pub_key) ? ; let message : Vec < u8 > = ctx . read_sandbox_memory (memory , message_ptr , message_len) ? ; if ctx . ext . sr25519_verify (& signature , & message , & pub_key) { Ok (ReturnCode :: Success) } else { Ok (ReturnCode :: Sr25519VerifyFailed) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::sr25519_verify(signature_ptr: {0:?}, pub_key_ptr: {1:?}, message_len: {2:?}, message_ptr: {3:?}) = {4:?}\n" , signature_ptr , pub_key_ptr , message_len , message_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Sr25519Verify (message_len)) ? ; let mut signature : [u8 ; 64] = [0 ; 64] ; ctx . read_sandbox_memory_into_buf (memory , signature_ptr , & mut signature) ? ; let mut pub_key : [u8 ; 32] = [0 ; 32] ; ctx . read_sandbox_memory_into_buf (memory , pub_key_ptr , & mut pub_key) ? ; let message : Vec < u8 > = ctx . read_sandbox_memory (memory , message_ptr , message_len) ? ; if ctx . ext . sr25519_verify (& signature , & message , & pub_key) { Ok (ReturnCode :: Success) } else { Ok (ReturnCode :: Sr25519VerifyFailed) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "set_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: SetCodeHash) ? ; let code_hash : CodeHash < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , code_hash_ptr) ? ; match ctx . ext . set_code_hash (code_hash) { Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } Ok (()) => Ok (ReturnCode :: Success) , } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::set_code_hash(code_hash_ptr: {0:?}) = {1:?}\n" , code_hash_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: SetCodeHash) ? ; let code_hash : CodeHash < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , code_hash_ptr) ? ; match ctx . ext . set_code_hash (code_hash) { Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } Ok (()) => Ok (ReturnCode :: Success) , } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "ecdsa_to_eth_address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , out_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: EcdsaToEthAddress) ? ; let mut compressed_key : [u8 ; 33] = [0 ; 33] ; ctx . read_sandbox_memory_into_buf (memory , key_ptr , & mut compressed_key) ? ; let result = ctx . ext . ecdsa_to_eth_address (& compressed_key) ; match result { Ok (eth_address) => { ctx . write_sandbox_memory (memory , out_ptr , eth_address . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::ecdsa_to_eth_address(key_ptr: {0:?}, out_ptr: {1:?}) = {2:?}\n" , key_ptr , out_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: EcdsaToEthAddress) ? ; let mut compressed_key : [u8 ; 33] = [0 ; 33] ; ctx . read_sandbox_memory_into_buf (memory , key_ptr , & mut compressed_key) ? ; let result = ctx . ext . ecdsa_to_eth_address (& compressed_key) ; match result { Ok (eth_address) => { ctx . write_sandbox_memory (memory , out_ptr , eth_address . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "reentrance_count" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: ReentrantCount) ? ; Ok (ctx . ext . reentrance_count ()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::reentrance_count() = {0:?}\n" , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: ReentrantCount) ? ; Ok (ctx . ext . reentrance_count ()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "account_reentrance_count" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: AccountEntranceCount) ? ; let account_id : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; Ok (ctx . ext . account_reentrance_count (& account_id)) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::account_reentrance_count(account_ptr: {0:?}) = {1:?}\n" , account_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: AccountEntranceCount) ? ; let account_id : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; Ok (ctx . ext . account_reentrance_count (& account_id)) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "instantiation_nonce" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > | -> :: core :: result :: Result < :: core :: primitive :: u64 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u64 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: InstantationNonce) ? ; Ok (ctx . ext . nonce ()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::instantiation_nonce() = {0:?}\n" , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: InstantationNonce) ? ; Ok (ctx . ext . nonce ()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) . map (| _ | ()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_set_storage(key_ptr: {0:?}, value_ptr: {1:?}, value_len: {2:?}) = {3:?}\n" , key_ptr , value_ptr , value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) . map (| _ | ()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_set_storage(key_ptr: {0:?}, value_ptr: {1:?}, value_len: {2:?}) = {3:?}\n" , key_ptr , value_ptr , value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . set_storage (memory , KeyType :: Fix , key_ptr , value_ptr , value_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal2" , "seal_set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . set_storage (memory , KeyType :: Var (key_len) , key_ptr , value_ptr , value_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal2::seal_set_storage(key_ptr: {0:?}, key_len: {1:?}, value_ptr: {2:?}, value_len: {3:?}) = {4:?}\n" , key_ptr , key_len , value_ptr , value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . set_storage (memory , KeyType :: Var (key_len) , key_ptr , value_ptr , value_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . clear_storage (memory , KeyType :: Fix , key_ptr) . map (| _ | ()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_clear_storage(key_ptr: {0:?}) = {1:?}\n" , key_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . clear_storage (memory , KeyType :: Fix , key_ptr) . map (| _ | ()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . clear_storage (memory , KeyType :: Var (key_len) , key_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_clear_storage(key_ptr: {0:?}, key_len: {1:?}) = {2:?}\n" , key_ptr , key_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . clear_storage (memory , KeyType :: Var (key_len) , key_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . get_storage (memory , KeyType :: Fix , key_ptr , out_ptr , out_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_get_storage(key_ptr: {0:?}, out_ptr: {1:?}, out_len_ptr: {2:?}) = {3:?}\n" , key_ptr , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . get_storage (memory , KeyType :: Fix , key_ptr , out_ptr , out_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . get_storage (memory , KeyType :: Var (key_len) , key_ptr , out_ptr , out_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_get_storage(key_ptr: {0:?}, key_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , key_ptr , key_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . get_storage (memory , KeyType :: Var (key_len) , key_ptr , out_ptr , out_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . contains_storage (memory , KeyType :: Fix , key_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_contains_storage(key_ptr: {0:?}) = {1:?}\n" , key_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . contains_storage (memory , KeyType :: Fix , key_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . contains_storage (memory , KeyType :: Var (key_len) , key_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_contains_storage(key_ptr: {0:?}, key_len: {1:?}) = {2:?}\n" , key_ptr , key_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . contains_storage (memory , KeyType :: Var (key_len) , key_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_take_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let charged = ctx . charge_gas (RuntimeCosts :: TakeStorage (ctx . ext . max_value_size ())) ? ; { if ! (key_len <= < < E as Ext > :: T as Config > :: MaxStorageKeyLen :: get ()) { { return Err (Error :: < E :: T > :: DecodingFailed . into ()) } ; } } ; let key = ctx . read_sandbox_memory (memory , key_ptr , key_len) ? ; if let crate :: storage :: WriteOutcome :: Taken (value) = ctx . ext . set_storage (& Key :: < E :: T > :: try_from_var (key) . map_err (| _ | Error :: < E :: T > :: DecodingFailed) ? , None , true) ? { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (value . len () as u32)) ; ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (0)) ; Ok (ReturnCode :: KeyNotFound) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_take_storage(key_ptr: {0:?}, key_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , key_ptr , key_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let charged = ctx . charge_gas (RuntimeCosts :: TakeStorage (ctx . ext . max_value_size ())) ? ; { if ! (key_len <= < < E as Ext > :: T as Config > :: MaxStorageKeyLen :: get ()) { { return Err (Error :: < E :: T > :: DecodingFailed . into ()) } ; } } ; let key = ctx . read_sandbox_memory (memory , key_ptr , key_len) ? ; if let crate :: storage :: WriteOutcome :: Taken (value) = ctx . ext . set_storage (& Key :: < E :: T > :: try_from_var (key) . map_err (| _ | Error :: < E :: T > :: DecodingFailed) ? , None , true) ? { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (value . len () as u32)) ; ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { ctx . adjust_gas (charged , RuntimeCosts :: TakeStorage (0)) ; Ok (ReturnCode :: KeyNotFound) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_transfer" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 , _account_len : u32 , value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Transfer) ? ; let callee : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; let value : BalanceOf < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , value_ptr) ? ; let result = ctx . ext . transfer (& callee , value) ; match result { Ok (()) => Ok (ReturnCode :: Success) , Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_transfer(account_ptr: {0:?}, _account_len: {1:?}, value_ptr: {2:?}, _value_len: {3:?}) = {4:?}\n" , account_ptr , _account_len , value_ptr , _value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Transfer) ? ; let callee : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; let value : BalanceOf < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , value_ptr) ? ; let result = ctx . ext . transfer (& callee , value) ; match result { Ok (()) => Ok (ReturnCode :: Success) , Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , callee_ptr : u32 , _callee_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: ALLOW_REENTRY , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_call(callee_ptr: {0:?}, _callee_len: {1:?}, gas: {2:?}, value_ptr: {3:?}, _value_len: {4:?}, input_data_ptr: {5:?}, input_data_len: {6:?}, output_ptr: {7:?}, output_len_ptr: {8:?}) = {9:?}\n" , callee_ptr , _callee_len , gas , value_ptr , _value_len , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: ALLOW_REENTRY , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , flags : u32 , callee_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_call(flags: {0:?}, callee_ptr: {1:?}, gas: {2:?}, value_ptr: {3:?}, input_data_ptr: {4:?}, input_data_len: {5:?}, output_ptr: {6:?}, output_len_ptr: {7:?}) = {8:?}\n" , flags , callee_ptr , gas , value_ptr , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: Call { callee_ptr , value_ptr , deposit_ptr : SENTINEL , weight : Weight :: from_parts (gas , 0) , } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_delegate_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , flags : u32 , code_hash_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: DelegateCall { code_hash_ptr } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_delegate_call(flags: {0:?}, code_hash_ptr: {1:?}, input_data_ptr: {2:?}, input_data_len: {3:?}, output_ptr: {4:?}, output_len_ptr: {5:?}) = {6:?}\n" , flags , code_hash_ptr , input_data_ptr , input_data_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . call (memory , CallFlags :: from_bits (flags) . ok_or (Error :: < E :: T > :: InvalidCallFlags) ? , CallType :: DelegateCall { code_hash_ptr } , input_data_ptr , input_data_len , output_ptr , output_len_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 , _code_hash_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_instantiate(code_hash_ptr: {0:?}, _code_hash_len: {1:?}, gas: {2:?}, value_ptr: {3:?}, _value_len: {4:?}, input_data_ptr: {5:?}, input_data_len: {6:?}, address_ptr: {7:?}, address_len_ptr: {8:?}, output_ptr: {9:?}, output_len_ptr: {10:?}, salt_ptr: {11:?}, salt_len: {12:?}) = {13:?}\n" , code_hash_ptr , _code_hash_len , gas , value_ptr , _value_len , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_instantiate(code_hash_ptr: {0:?}, gas: {1:?}, value_ptr: {2:?}, input_data_ptr: {3:?}, input_data_len: {4:?}, address_ptr: {5:?}, address_len_ptr: {6:?}, output_ptr: {7:?}, output_len_ptr: {8:?}, salt_ptr: {9:?}, salt_len: {10:?}) = {11:?}\n" , code_hash_ptr , gas , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . instantiate (memory , code_hash_ptr , Weight :: from_parts (gas , 0) , SENTINEL , value_ptr , input_data_ptr , input_data_len , address_ptr , address_len_ptr , output_ptr , output_len_ptr , salt_ptr , salt_len) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , beneficiary_ptr : u32 , _beneficiary_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . terminate (memory , beneficiary_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_terminate(beneficiary_ptr: {0:?}, _beneficiary_len: {1:?}) = {2:?}\n" , beneficiary_ptr , _beneficiary_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . terminate (memory , beneficiary_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , beneficiary_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . terminate (memory , beneficiary_ptr) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_terminate(beneficiary_ptr: {0:?}) = {1:?}\n" , beneficiary_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . terminate (memory , beneficiary_ptr) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_input" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: InputBase) ? ; if let Some (input) = ctx . input_data . take () { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & input , false , | len | { Some (RuntimeCosts :: CopyToContract (len)) }) ? ; ctx . input_data = Some (input) ; Ok (()) } else { Err (Error :: < E :: T > :: InputForwarded . into ()) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_input(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: InputBase) ? ; if let Some (input) = ctx . input_data . take () { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & input , false , | len | { Some (RuntimeCosts :: CopyToContract (len)) }) ? ; ctx . input_data = Some (input) ; Ok (()) } else { Err (Error :: < E :: T > :: InputForwarded . into ()) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_caller" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Caller) ? ; let caller = ctx . ext . caller () . account_id () ? . clone () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & caller . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_caller(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Caller) ? ; let caller = ctx . ext . caller () . account_id () ? . clone () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & caller . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_is_contract" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: IsContract) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; Ok (ctx . ext . is_contract (& address) as u32) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_is_contract(account_ptr: {0:?}) = {1:?}\n" , account_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: IsContract) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; Ok (ctx . ext . is_contract (& address) as u32) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , account_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: CodeHash) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; if let Some (value) = ctx . ext . code_hash (& address) { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value . encode () , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { Ok (ReturnCode :: KeyNotFound) } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_code_hash(account_ptr: {0:?}, out_ptr: {1:?}, out_len_ptr: {2:?}) = {3:?}\n" , account_ptr , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: CodeHash) ? ; let address : < < E as Ext > :: T as frame_system :: Config > :: AccountId = ctx . read_sandbox_memory_as (memory , account_ptr) ? ; if let Some (value) = ctx . ext . code_hash (& address) { ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & value . encode () , false , already_charged) ? ; Ok (ReturnCode :: Success) } else { Ok (ReturnCode :: KeyNotFound) } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_own_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: OwnCodeHash) ? ; let code_hash_encoded = & ctx . ext . own_code_hash () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , code_hash_encoded , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_own_code_hash(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: OwnCodeHash) ? ; let code_hash_encoded = & ctx . ext . own_code_hash () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , code_hash_encoded , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_caller_is_origin" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: CallerIsOrigin) ? ; Ok (ctx . ext . caller_is_origin () as u32) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_caller_is_origin() = {0:?}\n" , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: CallerIsOrigin) ? ; Ok (ctx . ext . caller_is_origin () as u32) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Address) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . address () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_address(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Address) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . address () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_weight_to_fee" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , gas : u64 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let gas = Weight :: from_parts (gas , 0) ; ctx . charge_gas (RuntimeCosts :: WeightToFee) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . get_weight_price (gas) . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_weight_to_fee(gas: {0:?}, out_ptr: {1:?}, out_len_ptr: {2:?}) = {3:?}\n" , gas , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let gas = Weight :: from_parts (gas , 0) ; ctx . charge_gas (RuntimeCosts :: WeightToFee) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . get_weight_price (gas) . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_gas_left" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: GasLeft) ? ; let gas_left = & ctx . ext . gas_meter () . gas_left () . ref_time () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , gas_left , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_gas_left(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: GasLeft) ? ; let gas_left = & ctx . ext . gas_meter () . gas_left () . ref_time () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , gas_left , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Balance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . balance () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_balance(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Balance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . balance () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_value_transferred" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: ValueTransferred) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . value_transferred () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_value_transferred(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: ValueTransferred) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . value_transferred () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . 0 . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_random(subject_ptr: {0:?}, subject_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , subject_ptr , subject_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . 0 . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_random(subject_ptr: {0:?}, subject_len: {1:?}, out_ptr: {2:?}, out_len_ptr: {3:?}) = {4:?}\n" , subject_ptr , subject_len , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Random) ? ; if subject_len > ctx . ext . schedule () . limits . subject_len { return Err (Error :: < E :: T > :: RandomSubjectTooLong . into ()) } let subject_buf = ctx . read_sandbox_memory (memory , subject_ptr , subject_len) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . random (& subject_buf) . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_now" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Now) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . now () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_now(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Now) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . now () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_minimum_balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: MinimumBalance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . minimum_balance () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_minimum_balance(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: MinimumBalance) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . minimum_balance () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_tombstone_deposit" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let deposit = < BalanceOf < E :: T > > :: zero () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & deposit , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_tombstone_deposit(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let deposit = < BalanceOf < E :: T > > :: zero () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & deposit , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _dest_ptr : u32 , _dest_len : u32 , _code_hash_ptr : u32 , _code_hash_len : u32 , _rent_allowance_ptr : u32 , _rent_allowance_len : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_restore_to(_dest_ptr: {0:?}, _dest_len: {1:?}, _code_hash_ptr: {2:?}, _code_hash_len: {3:?}, _rent_allowance_ptr: {4:?}, _rent_allowance_len: {5:?}, _delta_ptr: {6:?}, _delta_count: {7:?}) = {8:?}\n" , _dest_ptr , _dest_len , _code_hash_ptr , _code_hash_len , _rent_allowance_ptr , _rent_allowance_len , _delta_ptr , _delta_count , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _dest_ptr : u32 , _code_hash_ptr : u32 , _rent_allowance_ptr : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_restore_to(_dest_ptr: {0:?}, _code_hash_ptr: {1:?}, _rent_allowance_ptr: {2:?}, _delta_ptr: {3:?}, _delta_count: {4:?}) = {5:?}\n" , _dest_ptr , _code_hash_ptr , _rent_allowance_ptr , _delta_ptr , _delta_count , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_set_rent_allowance(_value_ptr: {0:?}, _value_len: {1:?}) = {2:?}\n" , _value_ptr , _value_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal1" , "seal_set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , _value_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal1::seal_set_rent_allowance(_value_ptr: {0:?}) = {1:?}\n" , _value_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: DebugMessage (0)) ? ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let rent_allowance = < BalanceOf < E :: T > > :: max_value () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & rent_allowance , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_rent_allowance(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: Balance) ? ; let rent_allowance = < BalanceOf < E :: T > > :: max_value () . encode () ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & rent_allowance , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_deposit_event" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , topics_ptr : u32 , topics_len : u32 , data_ptr : u32 , data_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let num_topic = topics_len . checked_div (sp_std :: mem :: size_of :: < TopicOf < E :: T > > () as u32) . ok_or ("Zero sized topics are not allowed") ? ; ctx . charge_gas (RuntimeCosts :: DepositEvent { num_topic , len : data_len , }) ? ; if data_len > ctx . ext . max_value_size () { return Err (Error :: < E :: T > :: ValueTooLarge . into ()) } let topics : Vec < TopicOf < < E as Ext > :: T > > = match topics_len { 0 => Vec :: new () , _ => ctx . read_sandbox_memory_as_unbounded (memory , topics_ptr , topics_len) ? , } ; if topics . len () > ctx . ext . schedule () . limits . event_topics as usize { return Err (Error :: < E :: T > :: TooManyTopics . into ()) } let event_data = ctx . read_sandbox_memory (memory , data_ptr , data_len) ? ; ctx . ext . deposit_event (topics , event_data) ; Ok (()) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_deposit_event(topics_ptr: {0:?}, topics_len: {1:?}, data_ptr: {2:?}, data_len: {3:?}) = {4:?}\n" , topics_ptr , topics_len , data_ptr , data_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let num_topic = topics_len . checked_div (sp_std :: mem :: size_of :: < TopicOf < E :: T > > () as u32) . ok_or ("Zero sized topics are not allowed") ? ; ctx . charge_gas (RuntimeCosts :: DepositEvent { num_topic , len : data_len , }) ? ; if data_len > ctx . ext . max_value_size () { return Err (Error :: < E :: T > :: ValueTooLarge . into ()) } let topics : Vec < TopicOf < < E as Ext > :: T > > = match topics_len { 0 => Vec :: new () , _ => ctx . read_sandbox_memory_as_unbounded (memory , topics_ptr , topics_len) ? , } ; if topics . len () > ctx . ext . schedule () . limits . event_topics as usize { return Err (Error :: < E :: T > :: TooManyTopics . into ()) } let event_data = ctx . read_sandbox_memory (memory , data_ptr , data_len) ? ; ctx . ext . deposit_event (topics , event_data) ; Ok (()) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_block_number" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: BlockNumber) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . block_number () . encode () , false , already_charged) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_block_number(out_ptr: {0:?}, out_len_ptr: {1:?}) = {2:?}\n" , out_ptr , out_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: BlockNumber) ? ; Ok (ctx . write_sandbox_output (memory , out_ptr , out_len_ptr , & ctx . ext . block_number () . encode () , false , already_charged) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_hash_sha2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashSha256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , sha2_256 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_hash_sha2_256(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashSha256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , sha2_256 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_hash_keccak_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashKeccak256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , keccak_256 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_hash_keccak_256(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashKeccak256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , keccak_256 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_hash_blake2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashBlake256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_256 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_hash_blake2_256(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashBlake256 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_256 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_hash_blake2_128" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> Result < () , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: HashBlake128 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_128 , input_ptr , input_len , output_ptr) ?) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_hash_blake2_128(input_ptr: {0:?}, input_len: {1:?}, output_ptr: {2:?}) = {3:?}\n" , input_ptr , input_len , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: HashBlake128 (input_len)) ? ; Ok (ctx . compute_hash_on_intermediate_buffer (memory , blake2_128 , input_ptr , input_len , output_ptr) ?) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_call_chain_extension" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , id : u32 , input_ptr : u32 , input_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < u32 , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { use crate :: chain_extension :: { ChainExtension , Environment , RetVal , } ; if ! < E :: T as Config > :: ChainExtension :: enabled () { return Err (Error :: < E :: T > :: NoChainExtension . into ()) } let mut chain_extension = ctx . chain_extension . take () . expect ("Constructor initializes with `Some`. This is the only place where it is set to `None`.\
			It is always reset to `Some` afterwards. qed") ; let env = Environment :: new (ctx , memory , id , input_ptr , input_len , output_ptr , output_len_ptr) ; let ret = match chain_extension . call (env) ? { RetVal :: Converging (val) => Ok (val) , RetVal :: Diverging { flags , data } => Err (TrapReason :: Return (ReturnData { flags : flags . bits () , data , })) , } ; ctx . chain_extension = Some (chain_extension) ; ret } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_call_chain_extension(id: {0:?}, input_ptr: {1:?}, input_len: {2:?}, output_ptr: {3:?}, output_len_ptr: {4:?}) = {5:?}\n" , id , input_ptr , input_len , output_ptr , output_len_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { use crate :: chain_extension :: { ChainExtension , Environment , RetVal , } ; if ! < E :: T as Config > :: ChainExtension :: enabled () { return Err (Error :: < E :: T > :: NoChainExtension . into ()) } let mut chain_extension = ctx . chain_extension . take () . expect ("Constructor initializes with `Some`. This is the only place where it is set to `None`.\
			It is always reset to `Some` afterwards. qed") ; let env = Environment :: new (ctx , memory , id , input_ptr , input_len , output_ptr , output_len_ptr) ; let ret = match chain_extension . call (env) ? { RetVal :: Converging (val) => Ok (val) , RetVal :: Diverging { flags , data } => Err (TrapReason :: Return (ReturnData { flags : flags . bits () , data , })) , } ; ctx . chain_extension = Some (chain_extension) ; ret } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_debug_message" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , str_ptr : u32 , str_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { let str_len = str_len . min (DebugBufferVec :: < E :: T > :: bound () as u32) ; ctx . charge_gas (RuntimeCosts :: DebugMessage (str_len)) ? ; if ctx . ext . append_debug_buffer ("") { let data = ctx . read_sandbox_memory (memory , str_ptr , str_len) ? ; if let Some (msg) = core :: str :: from_utf8 (& data) . ok () { ctx . ext . append_debug_buffer (msg) ; } } Ok (ReturnCode :: Success) } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_debug_message(str_ptr: {0:?}, str_len: {1:?}) = {2:?}\n" , str_ptr , str_len , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { let str_len = str_len . min (DebugBufferVec :: < E :: T > :: bound () as u32) ; ctx . charge_gas (RuntimeCosts :: DebugMessage (str_len)) ? ; if ctx . ext . append_debug_buffer ("") { let data = ctx . read_sandbox_memory (memory , str_ptr , str_len) ? ; if let Some (msg) = core :: str :: from_utf8 (& data) . ok () { ctx . ext . append_debug_buffer (msg) ; } } Ok (ReturnCode :: Success) } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_ecdsa_recover" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , signature_ptr : u32 , message_hash_ptr : u32 , output_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: EcdsaRecovery) ? ; let mut signature : [u8 ; 65] = [0 ; 65] ; ctx . read_sandbox_memory_into_buf (memory , signature_ptr , & mut signature) ? ; let mut message_hash : [u8 ; 32] = [0 ; 32] ; ctx . read_sandbox_memory_into_buf (memory , message_hash_ptr , & mut message_hash) ? ; let result = ctx . ext . ecdsa_recover (& signature , & message_hash) ; match result { Ok (pub_key) => { ctx . write_sandbox_memory (memory , output_ptr , pub_key . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_ecdsa_recover(signature_ptr: {0:?}, message_hash_ptr: {1:?}, output_ptr: {2:?}) = {3:?}\n" , signature_ptr , message_hash_ptr , output_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: EcdsaRecovery) ? ; let mut signature : [u8 ; 65] = [0 ; 65] ; ctx . read_sandbox_memory_into_buf (memory , signature_ptr , & mut signature) ? ; let mut message_hash : [u8 ; 32] = [0 ; 32] ; ctx . read_sandbox_memory_into_buf (memory , message_hash_ptr , & mut message_hash) ? ; let result = ctx . ext . ecdsa_recover (& signature , & message_hash) ; match result { Ok (pub_key) => { ctx . write_sandbox_memory (memory , output_ptr , pub_key . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_set_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , code_hash_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: SetCodeHash) ? ; let code_hash : CodeHash < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , code_hash_ptr) ? ; match ctx . ext . set_code_hash (code_hash) { Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } Ok (()) => Ok (ReturnCode :: Success) , } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_set_code_hash(code_hash_ptr: {0:?}) = {1:?}\n" , code_hash_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: SetCodeHash) ? ; let code_hash : CodeHash < < E as Ext > :: T > = ctx . read_sandbox_memory_as (memory , code_hash_ptr) ? ; match ctx . ext . set_code_hash (code_hash) { Err (err) => { let code = Runtime :: < E > :: err_into_return_code (err) ? ; Ok (code) } Ok (()) => Ok (ReturnCode :: Success) , } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    linker . define ("seal0" , "seal_ecdsa_to_eth_address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < crate :: wasm :: Runtime < E > > , key_ptr : u32 , out_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> Result < ReturnCode , TrapReason > { let (memory , ctx) = __caller__ . data () . memory () . expect ("Memory must be set when setting up host data; qed") . data_and_store_mut (& mut __caller__) ; if { let lvl = :: log :: Level :: Trace ; lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () && :: log :: __private_api_enabled (lvl , "runtime::contracts::strace") } { let result = { ctx . charge_gas (RuntimeCosts :: EcdsaToEthAddress) ? ; let mut compressed_key : [u8 ; 33] = [0 ; 33] ; ctx . read_sandbox_memory_into_buf (memory , key_ptr , & mut compressed_key) ? ; let result = ctx . ext . ecdsa_to_eth_address (& compressed_key) ; match result { Ok (eth_address) => { ctx . write_sandbox_memory (memory , out_ptr , eth_address . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } ; { use sp_std :: fmt :: Write ; let mut w = sp_std :: Writer :: default () ; let _ = (& mut w) . write_fmt (format_args ! ("seal0::seal_ecdsa_to_eth_address(key_ptr: {0:?}, out_ptr: {1:?}) = {2:?}\n" , key_ptr , out_ptr , result)) ; let msg = core :: str :: from_utf8 (& w . inner ()) . unwrap_or_default () ; ctx . ext () . append_debug_buffer (msg) ; } result } else { { ctx . charge_gas (RuntimeCosts :: EcdsaToEthAddress) ? ; let mut compressed_key : [u8 ; 33] = [0 ; 33] ; ctx . read_sandbox_memory_into_buf (memory , key_ptr , & mut compressed_key) ? ; let result = ctx . ext . ecdsa_to_eth_address (& compressed_key) ; match result { Ok (eth_address) => { ctx . write_sandbox_memory (memory , out_ptr , eth_address . as_ref ()) ? ; Ok (ReturnCode :: Success) } Err (_) => Ok (ReturnCode :: EcdsaRecoverFailed) , } } } } ; func () . map_err (| reason | { :: wasmi :: core :: Trap :: from (reason) }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                Ok(())
            }
        }
        impl crate::wasm::Environment<()> for Env {
            fn define(
                store: &mut ::wasmi::Store<()>,
                linker: &mut ::wasmi::Linker<()>,
                allow_unstable: AllowUnstableInterface,
                allow_deprecated: AllowDeprecatedInterface,
            ) -> Result<(), ::wasmi::errors::LinkerError> {
                let __allow_unstable__ = match allow_unstable {
                    AllowUnstableInterface::Yes => true,
                    _ => false,
                };
                let __allow_deprecated__ = match allow_deprecated {
                    AllowDeprecatedInterface::Yes => true,
                    _ => false,
                };
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "gas" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , amount : u64 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal2" , "set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "take_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "transfer" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 , _account_len : u32 , value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , callee_ptr : u32 , _callee_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , flags : u32 , callee_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal2" , "call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , flags : u32 , callee_ptr : u32 , ref_time_limit : u64 , proof_size_limit : u64 , deposit_ptr : u32 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "delegate_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , flags : u32 , code_hash_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 , _code_hash_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal2" , "instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 , ref_time_limit : u64 , proof_size_limit : u64 , deposit_ptr : u32 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , beneficiary_ptr : u32 , _beneficiary_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , beneficiary_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "input" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_return" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , flags : u32 , data_ptr : u32 , data_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "caller" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "is_contract" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "own_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "caller_is_origin" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "caller_is_root" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "weight_to_fee" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , gas : u64 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "weight_to_fee" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , ref_time_limit : u64 , proof_size_limit : u64 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "gas_left" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "gas_left" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "value_transferred" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "now" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "minimum_balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "tombstone_deposit" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _dest_ptr : u32 , _dest_len : u32 , _code_hash_ptr : u32 , _code_hash_len : u32 , _rent_allowance_ptr : u32 , _rent_allowance_len : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _dest_ptr : u32 , _code_hash_ptr : u32 , _rent_allowance_ptr : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _value_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "deposit_event" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , topics_ptr : u32 , topics_len : u32 , data_ptr : u32 , data_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "block_number" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "hash_sha2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "hash_keccak_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "hash_blake2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "hash_blake2_128" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "call_chain_extension" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , id : u32 , input_ptr : u32 , input_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "debug_message" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , str_ptr : u32 , str_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "call_runtime" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , call_ptr : u32 , call_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "ecdsa_recover" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , signature_ptr : u32 , message_hash_ptr : u32 , output_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "sr25519_verify" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , signature_ptr : u32 , pub_key_ptr : u32 , message_len : u32 , message_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "set_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "ecdsa_to_eth_address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , out_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "reentrance_count" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "account_reentrance_count" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((false || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "instantiation_nonce" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > | -> :: core :: result :: Result < :: core :: primitive :: u64 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u64 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal2" , "seal_set_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 , value_ptr : u32 , value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_clear_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_get_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_contains_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_take_storage" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , key_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_transfer" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 , _account_len : u32 , value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , callee_ptr : u32 , _callee_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , flags : u32 , callee_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_delegate_call" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , flags : u32 , code_hash_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 , _code_hash_len : u32 , gas : u64 , value_ptr : u32 , _value_len : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_instantiate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 , gas : u64 , value_ptr : u32 , input_data_ptr : u32 , input_data_len : u32 , address_ptr : u32 , address_len_ptr : u32 , output_ptr : u32 , output_len_ptr : u32 , salt_ptr : u32 , salt_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , beneficiary_ptr : u32 , _beneficiary_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_terminate" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , beneficiary_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_input" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_caller" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_is_contract" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , account_ptr : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_own_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_caller_is_origin" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_weight_to_fee" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , gas : u64 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_gas_left" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_value_transferred" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_random" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , subject_ptr : u32 , subject_len : u32 , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_now" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_minimum_balance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_tombstone_deposit" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _dest_ptr : u32 , _dest_len : u32 , _code_hash_ptr : u32 , _code_hash_len : u32 , _rent_allowance_ptr : u32 , _rent_allowance_len : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_restore_to" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _dest_ptr : u32 , _code_hash_ptr : u32 , _rent_allowance_ptr : u32 , _delta_ptr : u32 , _delta_count : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _value_ptr : u32 , _value_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal1" , "seal_set_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , _value_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (false || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_rent_allowance" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_deposit_event" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , topics_ptr : u32 , topics_len : u32 , data_ptr : u32 , data_len : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_block_number" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , out_ptr : u32 , out_len_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_hash_sha2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_hash_keccak_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_hash_blake2_256" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_hash_blake2_128" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , input_ptr : u32 , input_len : u32 , output_ptr : u32 | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < () , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_call_chain_extension" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , id : u32 , input_ptr : u32 , input_len : u32 , output_ptr : u32 , output_len_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_debug_message" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , str_ptr : u32 , str_len : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_ecdsa_recover" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , signature_ptr : u32 , message_hash_ptr : u32 , output_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_set_code_hash" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , code_hash_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                if false || ((true || __allow_unstable__) && (true || __allow_deprecated__)) {
                    # [allow (unused_variables)] linker . define ("seal0" , "seal_ecdsa_to_eth_address" , :: wasmi :: Func :: wrap (& mut * store , | mut __caller__ : :: wasmi :: Caller < () > , key_ptr : u32 , out_ptr : u32 | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { let mut func = | | -> :: core :: result :: Result < :: core :: primitive :: u32 , :: wasmi :: core :: Trap > { :: core :: panicking :: panic ("internal error: entered unreachable code") } ; func () . map_err (| reason | { reason }) . map (:: core :: convert :: Into :: into) })) ? ;
                }
                Ok(())
            }
        }
    }
    pub use crate::wasm::{
        prepare::TryInstantiate,
        runtime::{
            AllowDeprecatedInterface, AllowUnstableInterface, CallFlags, Environment, ReturnCode,
            Runtime, RuntimeCosts,
        },
    };
    use crate::{
        exec::{ExecResult, Executable, ExportedFunction, Ext},
        gas::GasMeter,
        AccountIdOf, BalanceOf, CodeHash, CodeVec, Config, Error, OwnerInfoOf, RelaxedCodeVec,
        Schedule, LOG_TARGET,
    };
    use codec::{Decode, Encode, MaxEncodedLen};
    use frame_support::dispatch::{DispatchError, DispatchResult};
    use sp_core::Get;
    use sp_runtime::RuntimeDebug;
    use sp_std::prelude::*;
    use wasmi::{
        Config as WasmiConfig, Engine, Instance, Linker, Memory, MemoryType, Module, StackLimits,
        Store,
    };
    /// A prepared wasm module ready for execution.
    ///
    /// # Note
    ///
    /// This data structure is mostly immutable once created and stored. The exceptions that
    /// can be changed by calling a contract are `instruction_weights_version` and `code`.
    /// `instruction_weights_version` and `code` change when a contract with an outdated instrumentation
    /// is called. Therefore one must be careful when holding any in-memory representation of this
    /// type while calling into a contract as those fields can get out of date.
    ///
    ///
    /// 准备好执行的wasm模块。
    /// 注意
    /// 此数据结构在创建和存储后大多是不可变的。可以通过调用协定来更改的例外是 instruction_weights_version 和 code。
    /// 和code在调用具有过时检测的协定时更改。
    /// instruction_weights_version因此，在调用合约时，在保存这种类型的任何内存中表示时必须小心，因为这些字段可能会过时。
    #[codec(mel_bound())]
    #[scale_info(skip_type_params(T))]
    pub struct PrefabWasmModule<T: Config> {
        /// Version of the instruction weights with which the code was instrumented.
        #[codec(compact)]
        instruction_weights_version: u32,
        /// Initial memory size of a contract's sandbox.
        #[codec(compact)]
        initial: u32,
        /// The maximum memory size of a contract's sandbox.
        #[codec(compact)]
        maximum: u32,
        /// Code instrumented with the latest schedule.
        code: RelaxedCodeVec<T>,
        /// A code that might contain non deterministic features and is therefore never allowed
        /// to be run on chain. Specifically this code can never be instantiated into a contract
        /// and can just be used through a delegate call.
        determinism: Determinism,
        /// The uninstrumented, pristine version of the code.
        ///
        /// It is not stored because the pristine code has its own storage item. The value
        /// is only `Some` when this module was created from an `original_code` and `None` if
        /// it was loaded from storage.
        #[codec(skip)]
        original_code: Option<CodeVec<T>>,
        /// The code hash of the stored code which is defined as the hash over the `original_code`.
        ///
        /// As the map key there is no need to store the hash in the value, too. It is set manually
        /// when loading the module from storage.
        #[codec(skip)]
        code_hash: CodeHash<T>,
        #[codec(skip)]
        owner_info: Option<OwnerInfo<T>>,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for PrefabWasmModule<T> {
        #[inline]
        fn clone(&self) -> PrefabWasmModule<T> {
            PrefabWasmModule {
                instruction_weights_version: ::core::clone::Clone::clone(
                    &self.instruction_weights_version,
                ),
                initial: ::core::clone::Clone::clone(&self.initial),
                maximum: ::core::clone::Clone::clone(&self.maximum),
                code: ::core::clone::Clone::clone(&self.code),
                determinism: ::core::clone::Clone::clone(&self.determinism),
                original_code: ::core::clone::Clone::clone(&self.original_code),
                code_hash: ::core::clone::Clone::clone(&self.code_hash),
                owner_info: ::core::clone::Clone::clone(&self.owner_info),
            }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for PrefabWasmModule<T>
        where
            RelaxedCodeVec<T>: ::codec::Encode,
            RelaxedCodeVec<T>: ::codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                {
                    :: codec :: Encode :: encode_to (& < < u32 as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , u32 > > :: RefType :: from (& self . instruction_weights_version) , __codec_dest_edqy) ;
                }
                {
                    :: codec :: Encode :: encode_to (& < < u32 as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , u32 > > :: RefType :: from (& self . initial) , __codec_dest_edqy) ;
                }
                {
                    :: codec :: Encode :: encode_to (& < < u32 as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , u32 > > :: RefType :: from (& self . maximum) , __codec_dest_edqy) ;
                }
                ::codec::Encode::encode_to(&self.code, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.determinism, __codec_dest_edqy);
                let _ = &self.original_code;
                let _ = &self.code_hash;
                let _ = &self.owner_info;
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for PrefabWasmModule<T>
        where
            RelaxedCodeVec<T>: ::codec::Encode,
            RelaxedCodeVec<T>: ::codec::Encode,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for PrefabWasmModule<T>
        where
            RelaxedCodeVec<T>: ::codec::Decode,
            RelaxedCodeVec<T>: ::codec::Decode,
            Option<CodeVec<T>>: Default,
            CodeHash<T>: Default,
            Option<OwnerInfo<T>>: Default,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(PrefabWasmModule::<T> {
                    instruction_weights_version: {
                        let __codec_res_edqy =
                            <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `PrefabWasmModule::instruction_weights_version`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                    },
                    initial: {
                        let __codec_res_edqy =
                            <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `PrefabWasmModule::initial`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy.into(),
                        }
                    },
                    maximum: {
                        let __codec_res_edqy =
                            <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `PrefabWasmModule::maximum`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy.into(),
                        }
                    },
                    code: {
                        let __codec_res_edqy =
                            <RelaxedCodeVec<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `PrefabWasmModule::code`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    determinism: {
                        let __codec_res_edqy =
                            <Determinism as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `PrefabWasmModule::determinism`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    original_code: ::core::default::Default::default(),
                    code_hash: ::core::default::Default::default(),
                    owner_info: ::core::default::Default::default(),
                })
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for PrefabWasmModule<T>
        where
            RelaxedCodeVec<T>: ::scale_info::TypeInfo + 'static,
            Option<CodeVec<T>>: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            Option<OwnerInfo<T>>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PrefabWasmModule" , "pallet_contracts::wasm")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["A prepared wasm module ready for execution." , "" , "# Note" , "" , "This data structure is mostly immutable once created and stored. The exceptions that" , "can be changed by calling a contract are `instruction_weights_version` and `code`." , "`instruction_weights_version` and `code` change when a contract with an outdated instrumentation" , "is called. Therefore one must be careful when holding any in-memory representation of this" , "type while calling into a contract as those fields can get out of date." , "" , "" , "准备好执行的wasm模块。" , "注意" , "此数据结构在创建和存储后大多是不可变的。可以通过调用协定来更改的例外是 instruction_weights_version 和 code。" , "和code在调用具有过时检测的协定时更改。" , "instruction_weights_version因此，在调用合约时，在保存这种类型的任何内存中表示时必须小心，因为这些字段可能会过时。"]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . compact :: < u32 > () . name ("instruction_weights_version") . type_name ("u32") . docs (& ["Version of the instruction weights with which the code was instrumented."])) . field (| f | f . compact :: < u32 > () . name ("initial") . type_name ("u32") . docs (& ["Initial memory size of a contract's sandbox."])) . field (| f | f . compact :: < u32 > () . name ("maximum") . type_name ("u32") . docs (& ["The maximum memory size of a contract's sandbox."])) . field (| f | f . ty :: < RelaxedCodeVec < T > > () . name ("code") . type_name ("RelaxedCodeVec<T>") . docs (& ["Code instrumented with the latest schedule."])) . field (| f | f . ty :: < Determinism > () . name ("determinism") . type_name ("Determinism") . docs (& ["A code that might contain non deterministic features and is therefore never allowed" , "to be run on chain. Specifically this code can never be instantiated into a contract" , "and can just be used through a delegate call."])))
            }
        };
    };
    const _: () = {
        impl<T: Config> ::codec::MaxEncodedLen for PrefabWasmModule<T> {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<u32>::max_encoded_len())
                    .saturating_add(<RelaxedCodeVec<T>>::max_encoded_len())
                    .saturating_add(<Determinism>::max_encoded_len())
            }
        }
    };
    /// Information that belongs to a [`PrefabWasmModule`] but is stored separately.
    ///
    /// It is stored in a separate storage entry to avoid loading the code when not necessary.
    #[codec(mel_bound())]
    #[scale_info(skip_type_params(T))]
    pub struct OwnerInfo<T: Config> {
        /// The account that has deployed the contract and hence is allowed to remove it.
        owner: AccountIdOf<T>,
        /// The amount of balance that was deposited by the owner in order to deploy it.
        #[codec(compact)]
        deposit: BalanceOf<T>,
        /// The number of contracts that use this as their code.
        #[codec(compact)]
        refcount: u64,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for OwnerInfo<T> {
        #[inline]
        fn clone(&self) -> OwnerInfo<T> {
            OwnerInfo {
                owner: ::core::clone::Clone::clone(&self.owner),
                deposit: ::core::clone::Clone::clone(&self.deposit),
                refcount: ::core::clone::Clone::clone(&self.refcount),
            }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for OwnerInfo<T>
        where
            AccountIdOf<T>: ::codec::Encode,
            AccountIdOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::HasCompact,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.owner, __codec_dest_edqy);
                {
                    ::codec::Encode::encode_to(
                        &<<BalanceOf<T> as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                            '_,
                            BalanceOf<T>,
                        >>::RefType::from(&self.deposit),
                        __codec_dest_edqy,
                    );
                }
                {
                    :: codec :: Encode :: encode_to (& < < u64 as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , u64 > > :: RefType :: from (& self . refcount) , __codec_dest_edqy) ;
                }
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for OwnerInfo<T>
        where
            AccountIdOf<T>: ::codec::Encode,
            AccountIdOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::HasCompact,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for OwnerInfo<T>
        where
            AccountIdOf<T>: ::codec::Decode,
            AccountIdOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::HasCompact,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(OwnerInfo::<T> {
                    owner: {
                        let __codec_res_edqy =
                            <AccountIdOf<T> as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `OwnerInfo::owner`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    deposit: {
                        let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `OwnerInfo::deposit`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy.into(),
                        }
                    },
                    refcount: {
                        let __codec_res_edqy =
                            <<u64 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `OwnerInfo::refcount`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy.into(),
                        }
                    },
                })
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for OwnerInfo<T>
        where
            AccountIdOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("OwnerInfo" , "pallet_contracts::wasm")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs (& ["Information that belongs to a [`PrefabWasmModule`] but is stored separately." , "" , "It is stored in a separate storage entry to avoid loading the code when not necessary."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < AccountIdOf < T > > () . name ("owner") . type_name ("AccountIdOf<T>") . docs (& ["The account that has deployed the contract and hence is allowed to remove it."])) . field (| f | f . compact :: < BalanceOf < T > > () . name ("deposit") . type_name ("BalanceOf<T>") . docs (& ["The amount of balance that was deposited by the owner in order to deploy it."])) . field (| f | f . compact :: < u64 > () . name ("refcount") . type_name ("u64") . docs (& ["The number of contracts that use this as their code."])))
            }
        };
    };
    const _: () = {
        impl<T: Config> ::codec::MaxEncodedLen for OwnerInfo<T> {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize
                    .saturating_add(<AccountIdOf<T>>::max_encoded_len())
                    .saturating_add(<BalanceOf<T>>::max_encoded_len())
                    .saturating_add(<u64>::max_encoded_len())
            }
        }
    };
    /// Defines the required determinism level of a wasm blob when either running or uploading code.
    pub enum Determinism {
        /// The execution should be deterministic and hence no indeterministic instructions are
        /// allowed.
        ///
        /// Dispatchables always use this mode in order to make on-chain execution deterministic.
        Enforced,
        /// Allow calling or uploading an indeterministic code.
        ///
        /// This is only possible when calling into `pallet-contracts` directly via
        /// [`crate::Pallet::bare_call`].
        ///
        /// # Note
        ///
        /// **Never** use this mode for on-chain execution.
        Relaxed,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Determinism {
        #[inline]
        fn clone(&self) -> Determinism {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Determinism {}
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Encode for Determinism {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Determinism::Enforced => {
                        __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                    }
                    Determinism::Relaxed => {
                        __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for Determinism {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Decode for Determinism {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e| {
                    e.chain("Could not decode `Determinism`, failed to read variant byte")
                })? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Determinism::Enforced)
                    }
                    __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Determinism::Relaxed)
                    }
                    _ => ::core::result::Result::Err(<_ as ::core::convert::Into<_>>::into(
                        "Could not decode `Determinism`, variant doesn't exist",
                    )),
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for Determinism {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Determinism" , "pallet_contracts::wasm")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["Defines the required determinism level of a wasm blob when either running or uploading code."]) . variant (:: scale_info :: build :: Variants :: new () . variant ("Enforced" , | v | v . index (0usize as :: core :: primitive :: u8) . docs (& ["The execution should be deterministic and hence no indeterministic instructions are" , "allowed." , "" , "Dispatchables always use this mode in order to make on-chain execution deterministic."])) . variant ("Relaxed" , | v | v . index (1usize as :: core :: primitive :: u8) . docs (& ["Allow calling or uploading an indeterministic code." , "" , "This is only possible when calling into `pallet-contracts` directly via" , "[`crate::Pallet::bare_call`]." , "" , "# Note" , "" , "**Never** use this mode for on-chain execution."])))
            }
        };
    };
    const _: () = {
        impl ::codec::MaxEncodedLen for Determinism {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.max(0_usize).max(0_usize).saturating_add(1)
            }
        }
    };
    impl core::fmt::Debug for Determinism {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::Enforced => fmt.debug_tuple("Determinism::Enforced").finish(),
                Self::Relaxed => fmt.debug_tuple("Determinism::Relaxed").finish(),
                _ => Ok(()),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Determinism {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Determinism {
        #[inline]
        fn eq(&self, other: &Determinism) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Determinism {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Determinism {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl ExportedFunction {
        /// The wasm export name for the function.
        fn identifier(&self) -> &str {
            match self {
                Self::Constructor => "deploy",
                Self::Call => "call",
            }
        }
    }
    impl<T: Config> PrefabWasmModule<T> {
        /// Create the module by checking and instrumenting `original_code`.
        ///
        /// This does **not** store the module. For this one need to either call [`Self::store`]
        /// or [`<Self as Executable>::execute`][`Executable::execute`].
        pub fn from_code(
            original_code: Vec<u8>,
            schedule: &Schedule<T>,
            owner: AccountIdOf<T>,
            determinism: Determinism,
            try_instantiate: TryInstantiate,
        ) -> Result<Self, (DispatchError, &'static str)> {
            let module = prepare::prepare::<runtime::Env, T>(
                original_code
                    .try_into()
                    .map_err(|_| (<Error<T>>::CodeTooLarge.into(), ""))?,
                schedule,
                owner,
                determinism,
                try_instantiate,
            )?;
            Ok(module)
        }
        /// Store the code without instantiating it.
        ///
        /// Otherwise the code is stored when [`<Self as Executable>::execute`][`Executable::execute`]
        /// is called.
        pub fn store(self) -> DispatchResult {
            code_cache::store(self, false)
        }
        /// Remove the code from storage and refund the deposit to its owner.
        ///
        /// Applies all necessary checks before removing the code.
        pub fn remove(origin: &T::AccountId, code_hash: CodeHash<T>) -> DispatchResult {
            code_cache::try_remove::<T>(origin, code_hash)
        }
        /// Returns whether there is a deposit to be paid for this module.
        ///
        /// Returns `0` if the module is already in storage and hence no deposit will
        /// be charged when storing it.
        pub fn open_deposit(&self) -> BalanceOf<T> {
            if <OwnerInfoOf<T>>::contains_key(&self.code_hash) {
                0u32.into()
            } else {
                self.owner_info
                    .as_ref()
                    .map(|i| i.deposit)
                    .unwrap_or_default()
            }
        }
        /// Creates and returns an instance of the supplied code.
        ///
        /// This is either used for later executing a contract or for validation of a contract.
        /// When validating we pass `()` as `host_state`. Please note that such a dummy instance must
        /// **never** be called/executed since it will panic the executor.
        pub fn instantiate<E, H>(
            code: &[u8],
            host_state: H,
            memory: (u32, u32),
            stack_limits: StackLimits,
            allow_deprecated: AllowDeprecatedInterface,
        ) -> Result<(Store<H>, Memory, Instance), wasmi::Error>
        where
            E: Environment<H>,
        {
            let mut config = WasmiConfig::default();
            config
                .set_stack_limits(stack_limits)
                .wasm_multi_value(false)
                .wasm_mutable_global(false)
                .wasm_sign_extension(false)
                .wasm_saturating_float_to_int(false);
            let engine = Engine::new(&config);
            let module = Module::new(&engine, code)?;
            let mut store = Store::new(&engine, host_state);
            let mut linker = Linker::new(&engine);
            E::define(
                &mut store,
                &mut linker,
                if T::UnsafeUnstableInterface::get() {
                    AllowUnstableInterface::Yes
                } else {
                    AllowUnstableInterface::No
                },
                allow_deprecated,
            )?;
            let memory = Memory :: new (& mut store , MemoryType :: new (memory . 0 , Some (memory . 1)) ?) . expect ("The limits defined in our `Schedule` limit the amount of memory well below u32::MAX; qed") ;
            linker.define("env", "memory", memory).expect(
                "We just created the linker. It has no define with this name attached; qed",
            );
            let instance = linker
                .instantiate(&mut store, &module)?
                .ensure_no_start(&mut store)?;
            Ok((store, memory, instance))
        }
    }
    impl<T: Config> OwnerInfo<T> {}
    impl<T: Config> Executable<T> for PrefabWasmModule<T> {
        fn from_storage(
            code_hash: CodeHash<T>,
            schedule: &Schedule<T>,
            gas_meter: &mut GasMeter<T>,
        ) -> Result<Self, DispatchError> {
            code_cache::load(code_hash, schedule, gas_meter)
        }
        fn add_user(code_hash: CodeHash<T>) -> Result<(), DispatchError> {
            code_cache::increment_refcount::<T>(code_hash)
        }
        fn remove_user(code_hash: CodeHash<T>) {
            code_cache::decrement_refcount::<T>(code_hash)
        }
        fn execute<E: Ext<T = T>>(
            self,
            ext: &mut E,
            function: &ExportedFunction,
            input_data: Vec<u8>,
        ) -> ExecResult {
            let runtime = Runtime::new(ext, input_data);
            let (mut store, memory, instance) = Self::instantiate::<crate::wasm::runtime::Env, _>(
                self.code.as_slice(),
                runtime,
                (self.initial, self.maximum),
                StackLimits::default(),
                match function {
                    ExportedFunction::Constructor => AllowDeprecatedInterface::No,
                    ExportedFunction::Call => AllowDeprecatedInterface::Yes,
                },
            )
            .map_err(|msg| {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            format_args!("failed to instantiate code: {0}", msg),
                            lvl,
                            &(
                                LOG_TARGET,
                                "pallet_contracts::wasm",
                                "frame/contracts/src/wasm/mod.rs",
                                336u32,
                            ),
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                Error::<T>::CodeRejected
            })?;
            store.data_mut().set_memory(memory);
            let exported_func = instance
                .get_export(&store, function.identifier())
                .and_then(|export| export.into_func())
                .ok_or_else(|| {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                format_args!("failed to find entry point"),
                                lvl,
                                &(
                                    LOG_TARGET,
                                    "pallet_contracts::wasm",
                                    "frame/contracts/src/wasm/mod.rs",
                                    345u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    Error::<T>::CodeRejected
                })?;
            if let &ExportedFunction::Constructor = function {
                code_cache::store(self, true)?;
            }
            let result = exported_func.call(&mut store, &[], &mut []);
            store.into_data().to_execution_result(result)
        }
        fn code_hash(&self) -> &CodeHash<T> {
            &self.code_hash
        }
        fn code_len(&self) -> u32 {
            self.code.len() as u32
        }
        fn is_deterministic(&self) -> bool {
            match self.determinism {
                Determinism::Enforced => true,
                _ => false,
            }
        }
    }
}
pub mod chain_extension {
    //! A mechanism for runtime authors to augment the functionality of contracts.
    //!
    //! The runtime is able to call into any contract and retrieve the result using
    //! [`bare_call`](crate::Pallet::bare_call). This already allows customization of runtime
    //! behaviour by user generated code (contracts). However, often it is more straightforward
    //! to allow the reverse behaviour: The contract calls into the runtime. We call the latter
    //! one a "chain extension" because it allows the chain to extend the set of functions that are
    //! callable by a contract.
    //!
    //! In order to create a chain extension the runtime author implements the [`ChainExtension`]
    //! trait and declares it in this pallet's [configuration Trait](crate::Config). All types
    //! required for this endeavour are defined or re-exported in this module. There is an
    //! implementation on `()` which can be used to signal that no chain extension is available.
    //!
    //! # Using multiple chain extensions
    //!
    //! Often there is a need for having multiple chain extensions. This is often the case when
    //! some generally useful off-the-shelf extensions should be included. To have multiple chain
    //! extensions they can be put into a tuple which is then passed to [`Config::ChainExtension`] like
    //! this `type Extensions = (ExtensionA, ExtensionB)`.
    //!
    //! However, only extensions implementing [`RegisteredChainExtension`] can be put into a tuple.
    //! This is because the [`RegisteredChainExtension::ID`] is used to decide which of those extensions
    //! should be used when the contract calls a chain extensions. Extensions which are generally
    //! useful should claim their `ID` with [the registry](https://github.com/paritytech/chainextension-registry)
    //! so that no collisions with other vendors will occur.
    //!
    //! **Chain specific extensions must use the reserved `ID = 0` so that they can't be registered with
    //! the registry.**
    //!
    //! # Security
    //!
    //! The chain author alone is responsible for the security of the chain extension.
    //! This includes avoiding the exposure of exploitable functions and charging the
    //! appropriate amount of weight. In order to do so benchmarks must be written and the
    //! [`charge_weight`](Environment::charge_weight) function must be called **before**
    //! carrying out any action that causes the consumption of the chargeable weight.
    //! It cannot be overstated how delicate of a process the creation of a chain extension
    //! is. Check whether using [`bare_call`](crate::Pallet::bare_call) suffices for the
    //! use case at hand.
    //!
    //! # Benchmarking
    //!
    //! The builtin contract callable functions that pallet-contracts provides all have
    //! benchmarks that determine the correct weight that an invocation of these functions
    //! induces. In order to be able to charge the correct weight for the functions defined
    //! by a chain extension benchmarks must be written, too. In the near future this crate
    //! will provide the means for easier creation of those specialized benchmarks.
    //!
    //! # Example
    //!
    //! The ink-examples repository maintains an
    //! [end-to-end example](https://github.com/paritytech/ink-examples/tree/main/rand-extension)
    //! on how to use a chain extension in order to provide new features to ink! contracts.
    use crate::{
        wasm::{Runtime, RuntimeCosts},
        Error,
    };
    use codec::{Decode, MaxEncodedLen};
    use frame_support::weights::Weight;
    use sp_runtime::DispatchError;
    use sp_std::{marker::PhantomData, vec::Vec};
    pub use crate::{exec::Ext, gas::ChargedAmount, Config};
    pub use frame_system::Config as SysConfig;
    pub use pallet_contracts_primitives::ReturnFlags;
    /// Result that returns a [`DispatchError`] on error.
    pub type Result<T> = sp_std::result::Result<T, DispatchError>;
    /// A trait used to extend the set of contract callable functions.
    ///
    /// In order to create a custom chain extension this trait must be implemented and supplied
    /// to the pallet contracts configuration trait as the associated type of the same name.
    /// Consult the [module documentation](self) for a general explanation of chain extensions.
    ///
    /// # Lifetime
    ///
    /// The extension will be [`Default`] initialized at the beginning of each call
    /// (**not** per call stack) and dropped afterwards. Hence any value held inside the extension
    /// can be used as a per-call scratch buffer.
    ///
    ///
    /// 用于扩展协定可调用函数集的特征。
    /// 为了创建自定义链扩展，必须实现此特征并将其作为同名的关联类型提供给托盘合同配置特征。
    /// 有关链扩展的一般说明，请参阅 模块文档 。
    /// LifeTime
    /// 扩展将在 Default 每次调用开始时初始化（而不是 每个调用堆栈），然后删除。
    /// 因此，扩展中保存的任何值都可以用作每次调用的暂存缓冲区。
    pub trait ChainExtension<C: Config> {
        /// Call the chain extension logic.
        ///
        /// This is the only function that needs to be implemented in order to write a
        /// chain extensions. It is called whenever a contract calls the `seal_call_chain_extension`
        /// imported wasm function.
        ///
        /// # Parameters
        /// - `env`: Access to the remaining arguments and the execution environment.
        ///
        /// # Return
        ///
        /// In case of `Err` the contract execution is immediately suspended and the passed error
        /// is returned to the caller. Otherwise the value of [`RetVal`] determines the exit
        /// behaviour.
        fn call<E: Ext<T = C>>(&mut self, env: Environment<E, InitState>) -> Result<RetVal>;
        /// Determines whether chain extensions are enabled for this chain.
        ///
        /// The default implementation returns `true`. Therefore it is not necessary to overwrite
        /// this function when implementing a chain extension. In case of `false` the deployment of
        /// a contract that references `seal_call_chain_extension` will be denied and calling this
        /// function will return [`NoChainExtension`](Error::NoChainExtension) without first calling
        /// into [`call`](Self::call).
        fn enabled() -> bool {
            true
        }
    }
    /// A [`ChainExtension`] that can be composed with other extensions using a tuple.
    ///
    /// An extension that implements this trait can be put in a tuple in order to have multiple
    /// extensions available. The tuple implementation routes requests based on the first two
    /// most significant bytes of the `id` passed to `call`.
    ///
    /// If this extensions is to be used by multiple runtimes consider
    /// [registering it](https://github.com/paritytech/chainextension-registry) to ensure that there
    /// are no collisions with other vendors.
    ///
    /// # Note
    ///
    /// Currently, we support tuples of up to ten registered chain extensions. If more chain extensions
    /// are needed consider opening an issue.
    pub trait RegisteredChainExtension<C: Config>: ChainExtension<C> {
        /// The extensions globally unique identifier.
        const ID: u16;
    }
    #[allow(unused)]
    impl<C: Config> ChainExtension<C> for () {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            false
        }
    }
    #[allow(unused)]
    impl<C: Config, TupleElement0: RegisteredChainExtension<C>> ChainExtension<C> for (TupleElement0,) {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
        > ChainExtension<C> for (TupleElement0, TupleElement1)
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
        > ChainExtension<C> for (TupleElement0, TupleElement1, TupleElement2)
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
        > ChainExtension<C> for (TupleElement0, TupleElement1, TupleElement2, TupleElement3)
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
            TupleElement4: RegisteredChainExtension<C>,
        > ChainExtension<C>
        for (
            TupleElement0,
            TupleElement1,
            TupleElement2,
            TupleElement3,
            TupleElement4,
        )
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            if (TupleElement4::ID == env.ext_id()) && TupleElement4::enabled() {
                return self.4.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            if TupleElement4::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
            TupleElement4: RegisteredChainExtension<C>,
            TupleElement5: RegisteredChainExtension<C>,
        > ChainExtension<C>
        for (
            TupleElement0,
            TupleElement1,
            TupleElement2,
            TupleElement3,
            TupleElement4,
            TupleElement5,
        )
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            if (TupleElement4::ID == env.ext_id()) && TupleElement4::enabled() {
                return self.4.call(env);
            }
            if (TupleElement5::ID == env.ext_id()) && TupleElement5::enabled() {
                return self.5.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            if TupleElement4::enabled() {
                return true;
            }
            if TupleElement5::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
            TupleElement4: RegisteredChainExtension<C>,
            TupleElement5: RegisteredChainExtension<C>,
            TupleElement6: RegisteredChainExtension<C>,
        > ChainExtension<C>
        for (
            TupleElement0,
            TupleElement1,
            TupleElement2,
            TupleElement3,
            TupleElement4,
            TupleElement5,
            TupleElement6,
        )
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            if (TupleElement4::ID == env.ext_id()) && TupleElement4::enabled() {
                return self.4.call(env);
            }
            if (TupleElement5::ID == env.ext_id()) && TupleElement5::enabled() {
                return self.5.call(env);
            }
            if (TupleElement6::ID == env.ext_id()) && TupleElement6::enabled() {
                return self.6.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            if TupleElement4::enabled() {
                return true;
            }
            if TupleElement5::enabled() {
                return true;
            }
            if TupleElement6::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
            TupleElement4: RegisteredChainExtension<C>,
            TupleElement5: RegisteredChainExtension<C>,
            TupleElement6: RegisteredChainExtension<C>,
            TupleElement7: RegisteredChainExtension<C>,
        > ChainExtension<C>
        for (
            TupleElement0,
            TupleElement1,
            TupleElement2,
            TupleElement3,
            TupleElement4,
            TupleElement5,
            TupleElement6,
            TupleElement7,
        )
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            if (TupleElement4::ID == env.ext_id()) && TupleElement4::enabled() {
                return self.4.call(env);
            }
            if (TupleElement5::ID == env.ext_id()) && TupleElement5::enabled() {
                return self.5.call(env);
            }
            if (TupleElement6::ID == env.ext_id()) && TupleElement6::enabled() {
                return self.6.call(env);
            }
            if (TupleElement7::ID == env.ext_id()) && TupleElement7::enabled() {
                return self.7.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            if TupleElement4::enabled() {
                return true;
            }
            if TupleElement5::enabled() {
                return true;
            }
            if TupleElement6::enabled() {
                return true;
            }
            if TupleElement7::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
            TupleElement4: RegisteredChainExtension<C>,
            TupleElement5: RegisteredChainExtension<C>,
            TupleElement6: RegisteredChainExtension<C>,
            TupleElement7: RegisteredChainExtension<C>,
            TupleElement8: RegisteredChainExtension<C>,
        > ChainExtension<C>
        for (
            TupleElement0,
            TupleElement1,
            TupleElement2,
            TupleElement3,
            TupleElement4,
            TupleElement5,
            TupleElement6,
            TupleElement7,
            TupleElement8,
        )
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            if (TupleElement4::ID == env.ext_id()) && TupleElement4::enabled() {
                return self.4.call(env);
            }
            if (TupleElement5::ID == env.ext_id()) && TupleElement5::enabled() {
                return self.5.call(env);
            }
            if (TupleElement6::ID == env.ext_id()) && TupleElement6::enabled() {
                return self.6.call(env);
            }
            if (TupleElement7::ID == env.ext_id()) && TupleElement7::enabled() {
                return self.7.call(env);
            }
            if (TupleElement8::ID == env.ext_id()) && TupleElement8::enabled() {
                return self.8.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            if TupleElement4::enabled() {
                return true;
            }
            if TupleElement5::enabled() {
                return true;
            }
            if TupleElement6::enabled() {
                return true;
            }
            if TupleElement7::enabled() {
                return true;
            }
            if TupleElement8::enabled() {
                return true;
            }
            false
        }
    }
    #[allow(unused)]
    impl<
            C: Config,
            TupleElement0: RegisteredChainExtension<C>,
            TupleElement1: RegisteredChainExtension<C>,
            TupleElement2: RegisteredChainExtension<C>,
            TupleElement3: RegisteredChainExtension<C>,
            TupleElement4: RegisteredChainExtension<C>,
            TupleElement5: RegisteredChainExtension<C>,
            TupleElement6: RegisteredChainExtension<C>,
            TupleElement7: RegisteredChainExtension<C>,
            TupleElement8: RegisteredChainExtension<C>,
            TupleElement9: RegisteredChainExtension<C>,
        > ChainExtension<C>
        for (
            TupleElement0,
            TupleElement1,
            TupleElement2,
            TupleElement3,
            TupleElement4,
            TupleElement5,
            TupleElement6,
            TupleElement7,
            TupleElement8,
            TupleElement9,
        )
    {
        fn call<E: Ext<T = C>>(&mut self, mut env: Environment<E, InitState>) -> Result<RetVal> {
            if (TupleElement0::ID == env.ext_id()) && TupleElement0::enabled() {
                return self.0.call(env);
            }
            if (TupleElement1::ID == env.ext_id()) && TupleElement1::enabled() {
                return self.1.call(env);
            }
            if (TupleElement2::ID == env.ext_id()) && TupleElement2::enabled() {
                return self.2.call(env);
            }
            if (TupleElement3::ID == env.ext_id()) && TupleElement3::enabled() {
                return self.3.call(env);
            }
            if (TupleElement4::ID == env.ext_id()) && TupleElement4::enabled() {
                return self.4.call(env);
            }
            if (TupleElement5::ID == env.ext_id()) && TupleElement5::enabled() {
                return self.5.call(env);
            }
            if (TupleElement6::ID == env.ext_id()) && TupleElement6::enabled() {
                return self.6.call(env);
            }
            if (TupleElement7::ID == env.ext_id()) && TupleElement7::enabled() {
                return self.7.call(env);
            }
            if (TupleElement8::ID == env.ext_id()) && TupleElement8::enabled() {
                return self.8.call(env);
            }
            if (TupleElement9::ID == env.ext_id()) && TupleElement9::enabled() {
                return self.9.call(env);
            }
            Err(Error::<E::T>::NoChainExtension.into())
        }
        fn enabled() -> bool {
            if TupleElement0::enabled() {
                return true;
            }
            if TupleElement1::enabled() {
                return true;
            }
            if TupleElement2::enabled() {
                return true;
            }
            if TupleElement3::enabled() {
                return true;
            }
            if TupleElement4::enabled() {
                return true;
            }
            if TupleElement5::enabled() {
                return true;
            }
            if TupleElement6::enabled() {
                return true;
            }
            if TupleElement7::enabled() {
                return true;
            }
            if TupleElement8::enabled() {
                return true;
            }
            if TupleElement9::enabled() {
                return true;
            }
            false
        }
    }
    /// Determines the exit behaviour and return value of a chain extension.
    pub enum RetVal {
        /// The chain extensions returns the supplied value to its calling contract.
        Converging(u32),
        /// The control does **not** return to the calling contract.
        ///
        /// Use this to stop the execution of the contract when the chain extension returns.
        /// The semantic is the same as for calling `seal_return`: The control returns to
        /// the caller of the currently executing contract yielding the supplied buffer and
        /// flags.
        Diverging { flags: ReturnFlags, data: Vec<u8> },
    }
    /// Grants the chain extension access to its parameters and execution environment.
    ///
    /// It uses [typestate programming](https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.html)
    /// to enforce the correct usage of the parameters passed to the chain extension.
    pub struct Environment<'a, 'b, E: Ext, S: State> {
        /// The actual data of this type.
        inner: Inner<'a, 'b, E>,
        /// `S` is only used in the type system but never as value.
        phantom: PhantomData<S>,
    }
    /// Functions that are available in every state of this type.
    impl<'a, 'b, E: Ext, S: State> Environment<'a, 'b, E, S> {
        /// The function id within the `id` passed by a contract.
        ///
        /// It returns the two least significant bytes of the `id` passed by a contract as the other
        /// two bytes represent the chain extension itself (the code which is calling this function).
        pub fn func_id(&self) -> u16 {
            (self.inner.id & 0x0000FFFF) as u16
        }
        /// The chain extension id within the `id` passed by a contract.
        ///
        /// It returns the two most significant bytes of the `id` passed by a contract which represent
        /// the chain extension itself (the code which is calling this function).
        pub fn ext_id(&self) -> u16 {
            (self.inner.id >> 16) as u16
        }
        /// Charge the passed `amount` of weight from the overall limit.
        ///
        /// It returns `Ok` when there the remaining weight budget is larger than the passed
        /// `weight`. It returns `Err` otherwise. In this case the chain extension should
        /// abort the execution and pass through the error.
        ///
        /// The returned value can be used to with [`Self::adjust_weight`]. Other than that
        /// it has no purpose.
        ///
        /// # Note
        ///
        /// Weight is synonymous with gas in substrate.
        pub fn charge_weight(&mut self, amount: Weight) -> Result<ChargedAmount> {
            self.inner
                .runtime
                .charge_gas(RuntimeCosts::ChainExtension(amount))
        }
        /// Adjust a previously charged amount down to its actual amount.
        ///
        /// This is when a maximum a priori amount was charged and then should be partially
        /// refunded to match the actual amount.
        pub fn adjust_weight(&mut self, charged: ChargedAmount, actual_weight: Weight) {
            self.inner
                .runtime
                .adjust_gas(charged, RuntimeCosts::ChainExtension(actual_weight))
        }
        /// Grants access to the execution environment of the current contract call.
        ///
        /// Consult the functions on the returned type before re-implementing those functions.
        pub fn ext(&mut self) -> &mut E {
            self.inner.runtime.ext()
        }
    }
    /// Functions that are only available in the initial state of this type.
    ///
    /// Those are the functions that determine how the arguments to the chain extensions
    /// should be consumed.
    impl<'a, 'b, E: Ext> Environment<'a, 'b, E, InitState> {
        /// Creates a new environment for consumption by a chain extension.
        ///
        /// It is only available to this crate because only the wasm runtime module needs to
        /// ever create this type. Chain extensions merely consume it.
        pub(crate) fn new(
            runtime: &'a mut Runtime<'b, E>,
            memory: &'a mut [u8],
            id: u32,
            input_ptr: u32,
            input_len: u32,
            output_ptr: u32,
            output_len_ptr: u32,
        ) -> Self {
            Environment {
                inner: Inner {
                    runtime,
                    memory,
                    id,
                    input_ptr,
                    input_len,
                    output_ptr,
                    output_len_ptr,
                },
                phantom: PhantomData,
            }
        }
        /// Use all arguments as integer values.
        pub fn only_in(self) -> Environment<'a, 'b, E, OnlyInState> {
            Environment {
                inner: self.inner,
                phantom: PhantomData,
            }
        }
        /// Use input arguments as integer and output arguments as pointer to a buffer.
        pub fn prim_in_buf_out(self) -> Environment<'a, 'b, E, PrimInBufOutState> {
            Environment {
                inner: self.inner,
                phantom: PhantomData,
            }
        }
        /// Use input and output arguments as pointers to a buffer.
        pub fn buf_in_buf_out(self) -> Environment<'a, 'b, E, BufInBufOutState> {
            Environment {
                inner: self.inner,
                phantom: PhantomData,
            }
        }
    }
    /// Functions to use the input arguments as integers.
    impl<'a, 'b, E: Ext, S: PrimIn> Environment<'a, 'b, E, S> {
        /// The `input_ptr` argument.
        pub fn val0(&self) -> u32 {
            self.inner.input_ptr
        }
        /// The `input_len` argument.
        pub fn val1(&self) -> u32 {
            self.inner.input_len
        }
    }
    /// Functions to use the output arguments as integers.
    impl<'a, 'b, E: Ext, S: PrimOut> Environment<'a, 'b, E, S> {
        /// The `output_ptr` argument.
        pub fn val2(&self) -> u32 {
            self.inner.output_ptr
        }
        /// The `output_len_ptr` argument.
        pub fn val3(&self) -> u32 {
            self.inner.output_len_ptr
        }
    }
    /// Functions to use the input arguments as pointer to a buffer.
    impl<'a, 'b, E: Ext, S: BufIn> Environment<'a, 'b, E, S> {
        /// Reads `min(max_len, in_len)` from contract memory.
        ///
        /// This does **not** charge any weight. The caller must make sure that the an
        /// appropriate amount of weight is charged **before** reading from contract memory.
        /// The reason for that is that usually the costs for reading data and processing
        /// said data cannot be separated in a benchmark. Therefore a chain extension would
        /// charge the overall costs either using `max_len` (worst case approximation) or using
        /// [`in_len()`](Self::in_len).
        pub fn read(&self, max_len: u32) -> Result<Vec<u8>> {
            self.inner.runtime.read_sandbox_memory(
                self.inner.memory,
                self.inner.input_ptr,
                self.inner.input_len.min(max_len),
            )
        }
        /// Reads `min(buffer.len(), in_len) from contract memory.
        ///
        /// This takes a mutable pointer to a buffer fills it with data and shrinks it to
        /// the size of the actual data. Apart from supporting pre-allocated buffers it is
        /// equivalent to to [`read()`](Self::read).
        pub fn read_into(&self, buffer: &mut &mut [u8]) -> Result<()> {
            let len = buffer.len();
            let sliced = {
                let buffer = core::mem::take(buffer);
                &mut buffer[..len.min(self.inner.input_len as usize)]
            };
            self.inner.runtime.read_sandbox_memory_into_buf(
                self.inner.memory,
                self.inner.input_ptr,
                sliced,
            )?;
            *buffer = sliced;
            Ok(())
        }
        /// Reads and decodes a type with a size fixed at compile time from contract memory.
        ///
        /// This function is secure and recommended for all input types of fixed size
        /// as long as the cost of reading the memory is included in the overall already charged
        /// weight of the chain extension. This should usually be the case when fixed input types
        /// are used.
        pub fn read_as<T: Decode + MaxEncodedLen>(&mut self) -> Result<T> {
            self.inner
                .runtime
                .read_sandbox_memory_as(self.inner.memory, self.inner.input_ptr)
        }
        /// Reads and decodes a type with a dynamic size from contract memory.
        ///
        /// Make sure to include `len` in your weight calculations.
        pub fn read_as_unbounded<T: Decode>(&mut self, len: u32) -> Result<T> {
            self.inner.runtime.read_sandbox_memory_as_unbounded(
                self.inner.memory,
                self.inner.input_ptr,
                len,
            )
        }
        /// The length of the input as passed in as `input_len`.
        ///
        /// A chain extension would use this value to calculate the dynamic part of its
        /// weight. For example a chain extension that calculates the hash of some passed in
        /// bytes would use `in_len` to charge the costs of hashing that amount of bytes.
        /// This also subsumes the act of copying those bytes as a benchmarks measures both.
        pub fn in_len(&self) -> u32 {
            self.inner.input_len
        }
    }
    /// Functions to use the output arguments as pointer to a buffer.
    impl<'a, 'b, E: Ext, S: BufOut> Environment<'a, 'b, E, S> {
        /// Write the supplied buffer to contract memory.
        ///
        /// If the contract supplied buffer is smaller than the passed `buffer` an `Err` is returned.
        /// If `allow_skip` is set to true the contract is allowed to skip the copying of the buffer
        /// by supplying the guard value of `pallet-contracts::SENTINEL` as `out_ptr`. The
        /// `weight_per_byte` is only charged when the write actually happens and is not skipped or
        /// failed due to a too small output buffer.
        pub fn write(
            &mut self,
            buffer: &[u8],
            allow_skip: bool,
            weight_per_byte: Option<Weight>,
        ) -> Result<()> {
            self.inner.runtime.write_sandbox_output(
                self.inner.memory,
                self.inner.output_ptr,
                self.inner.output_len_ptr,
                buffer,
                allow_skip,
                |len| {
                    weight_per_byte
                        .map(|w| RuntimeCosts::ChainExtension(w.saturating_mul(len.into())))
                },
            )
        }
    }
    /// The actual data of an `Environment`.
    ///
    /// All data is put into this struct to easily pass it around as part of the typestate
    /// pattern. Also it creates the opportunity to box this struct in the future in case it
    /// gets too large.
    ///
    /// 实际的 Environment数据。
    /// 所有数据都放入此结构中，以便将其作为类型状态模式的一部分轻松传递。
    /// 此外，它还创造了将来将此结构框起来的机会，以防它变得太大
    struct Inner<'a, 'b, E: Ext> {
        /// The runtime contains all necessary functions to interact with the running contract.
        runtime: &'a mut Runtime<'b, E>,
        /// Reference to the contracts memory.
        memory: &'a mut [u8],
        /// Verbatim argument passed to `seal_call_chain_extension`.
        id: u32,
        /// Verbatim argument passed to `seal_call_chain_extension`.
        input_ptr: u32,
        /// Verbatim argument passed to `seal_call_chain_extension`.
        input_len: u32,
        /// Verbatim argument passed to `seal_call_chain_extension`.
        output_ptr: u32,
        /// Verbatim argument passed to `seal_call_chain_extension`.
        output_len_ptr: u32,
    }
    /// Any state of an [`Environment`] implements this trait.
    /// See [typestate programming](https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.html).
    pub trait State: sealed::Sealed {}
    /// A state that uses primitive inputs.
    pub trait PrimIn: State {}
    /// A state that uses primitive outputs.
    pub trait PrimOut: State {}
    /// A state that uses a buffer as input.
    pub trait BufIn: State {}
    /// A state that uses a buffer as output.
    pub trait BufOut: State {}
    /// The initial state of an [`Environment`].
    pub enum InitState {}
    /// A state that uses all arguments as primitive inputs.
    pub enum OnlyInState {}
    /// A state that uses two arguments as primitive inputs and the other two as buffer output.
    pub enum PrimInBufOutState {}
    /// Uses a buffer for input and a buffer for output.
    pub enum BufInBufOutState {}
    mod sealed {
        use super::*;
        /// Trait to prevent users from implementing `State` for anything else.
        pub trait Sealed {}
        impl Sealed for InitState {}
        impl Sealed for OnlyInState {}
        impl Sealed for PrimInBufOutState {}
        impl Sealed for BufInBufOutState {}
        impl State for InitState {}
        impl State for OnlyInState {}
        impl State for PrimInBufOutState {}
        impl State for BufInBufOutState {}
        impl PrimIn for OnlyInState {}
        impl PrimOut for OnlyInState {}
        impl PrimIn for PrimInBufOutState {}
        impl BufOut for PrimInBufOutState {}
        impl BufIn for BufInBufOutState {}
        impl BufOut for BufInBufOutState {}
    }
}
pub mod weights {
    //! Autogenerated weights for pallet_contracts
    //!
    //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
    //! DATE: 2023-04-27, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
    //! WORST CASE MAP SIZE: `1000000`
    //! HOSTNAME: `bm3`, CPU: `Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz`
    //! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some("dev"), DB CACHE: 1024
    #![allow(unused_parens)]
    #![allow(unused_imports)]
    #![allow(missing_docs)]
    use frame_support::{
        traits::Get,
        weights::{Weight, constants::RocksDbWeight},
    };
    use core::marker::PhantomData;
    /// Weight functions needed for pallet_contracts.
    pub trait WeightInfo {
        fn on_process_deletion_queue_batch() -> Weight;
        fn on_initialize_per_trie_key(k: u32) -> Weight;
        fn reinstrument(c: u32) -> Weight;
        fn call_with_code_per_byte(c: u32) -> Weight;
        fn instantiate_with_code(c: u32, i: u32, s: u32) -> Weight;
        fn instantiate(i: u32, s: u32) -> Weight;
        fn call() -> Weight;
        fn upload_code(c: u32) -> Weight;
        fn remove_code() -> Weight;
        fn set_code() -> Weight;
        fn seal_caller(r: u32) -> Weight;
        fn seal_is_contract(r: u32) -> Weight;
        fn seal_code_hash(r: u32) -> Weight;
        fn seal_own_code_hash(r: u32) -> Weight;
        fn seal_caller_is_origin(r: u32) -> Weight;
        fn seal_caller_is_root(r: u32) -> Weight;
        fn seal_address(r: u32) -> Weight;
        fn seal_gas_left(r: u32) -> Weight;
        fn seal_balance(r: u32) -> Weight;
        fn seal_value_transferred(r: u32) -> Weight;
        fn seal_minimum_balance(r: u32) -> Weight;
        fn seal_block_number(r: u32) -> Weight;
        fn seal_now(r: u32) -> Weight;
        fn seal_weight_to_fee(r: u32) -> Weight;
        fn seal_gas(r: u32) -> Weight;
        fn seal_input(r: u32) -> Weight;
        fn seal_input_per_byte(n: u32) -> Weight;
        fn seal_return(r: u32) -> Weight;
        fn seal_return_per_byte(n: u32) -> Weight;
        fn seal_terminate(r: u32) -> Weight;
        fn seal_random(r: u32) -> Weight;
        fn seal_deposit_event(r: u32) -> Weight;
        fn seal_deposit_event_per_topic_and_byte(t: u32, n: u32) -> Weight;
        fn seal_debug_message(r: u32) -> Weight;
        fn seal_debug_message_per_byte(i: u32) -> Weight;
        fn seal_set_storage(r: u32) -> Weight;
        fn seal_set_storage_per_new_byte(n: u32) -> Weight;
        fn seal_set_storage_per_old_byte(n: u32) -> Weight;
        fn seal_clear_storage(r: u32) -> Weight;
        fn seal_clear_storage_per_byte(n: u32) -> Weight;
        fn seal_get_storage(r: u32) -> Weight;
        fn seal_get_storage_per_byte(n: u32) -> Weight;
        fn seal_contains_storage(r: u32) -> Weight;
        fn seal_contains_storage_per_byte(n: u32) -> Weight;
        fn seal_take_storage(r: u32) -> Weight;
        fn seal_take_storage_per_byte(n: u32) -> Weight;
        fn seal_transfer(r: u32) -> Weight;
        fn seal_call(r: u32) -> Weight;
        fn seal_delegate_call(r: u32) -> Weight;
        fn seal_call_per_transfer_clone_byte(t: u32, c: u32) -> Weight;
        fn seal_instantiate(r: u32) -> Weight;
        fn seal_instantiate_per_transfer_input_salt_byte(t: u32, i: u32, s: u32) -> Weight;
        fn seal_hash_sha2_256(r: u32) -> Weight;
        fn seal_hash_sha2_256_per_byte(n: u32) -> Weight;
        fn seal_hash_keccak_256(r: u32) -> Weight;
        fn seal_hash_keccak_256_per_byte(n: u32) -> Weight;
        fn seal_hash_blake2_256(r: u32) -> Weight;
        fn seal_hash_blake2_256_per_byte(n: u32) -> Weight;
        fn seal_hash_blake2_128(r: u32) -> Weight;
        fn seal_hash_blake2_128_per_byte(n: u32) -> Weight;
        fn seal_sr25519_verify_per_byte(n: u32) -> Weight;
        fn seal_sr25519_verify(r: u32) -> Weight;
        fn seal_ecdsa_recover(r: u32) -> Weight;
        fn seal_ecdsa_to_eth_address(r: u32) -> Weight;
        fn seal_set_code_hash(r: u32) -> Weight;
        fn seal_reentrance_count(r: u32) -> Weight;
        fn seal_account_reentrance_count(r: u32) -> Weight;
        fn seal_instantiation_nonce(r: u32) -> Weight;
        fn instr_i64const(r: u32) -> Weight;
        fn instr_i64load(r: u32) -> Weight;
        fn instr_i64store(r: u32) -> Weight;
        fn instr_select(r: u32) -> Weight;
        fn instr_if(r: u32) -> Weight;
        fn instr_br(r: u32) -> Weight;
        fn instr_br_if(r: u32) -> Weight;
        fn instr_br_table(r: u32) -> Weight;
        fn instr_br_table_per_entry(e: u32) -> Weight;
        fn instr_call(r: u32) -> Weight;
        fn instr_call_indirect(r: u32) -> Weight;
        fn instr_call_per_local(l: u32) -> Weight;
        fn instr_local_get(r: u32) -> Weight;
        fn instr_local_set(r: u32) -> Weight;
        fn instr_local_tee(r: u32) -> Weight;
        fn instr_global_get(r: u32) -> Weight;
        fn instr_global_set(r: u32) -> Weight;
        fn instr_memory_current(r: u32) -> Weight;
        fn instr_memory_grow(r: u32) -> Weight;
        fn instr_i64clz(r: u32) -> Weight;
        fn instr_i64ctz(r: u32) -> Weight;
        fn instr_i64popcnt(r: u32) -> Weight;
        fn instr_i64eqz(r: u32) -> Weight;
        fn instr_i64extendsi32(r: u32) -> Weight;
        fn instr_i64extendui32(r: u32) -> Weight;
        fn instr_i32wrapi64(r: u32) -> Weight;
        fn instr_i64eq(r: u32) -> Weight;
        fn instr_i64ne(r: u32) -> Weight;
        fn instr_i64lts(r: u32) -> Weight;
        fn instr_i64ltu(r: u32) -> Weight;
        fn instr_i64gts(r: u32) -> Weight;
        fn instr_i64gtu(r: u32) -> Weight;
        fn instr_i64les(r: u32) -> Weight;
        fn instr_i64leu(r: u32) -> Weight;
        fn instr_i64ges(r: u32) -> Weight;
        fn instr_i64geu(r: u32) -> Weight;
        fn instr_i64add(r: u32) -> Weight;
        fn instr_i64sub(r: u32) -> Weight;
        fn instr_i64mul(r: u32) -> Weight;
        fn instr_i64divs(r: u32) -> Weight;
        fn instr_i64divu(r: u32) -> Weight;
        fn instr_i64rems(r: u32) -> Weight;
        fn instr_i64remu(r: u32) -> Weight;
        fn instr_i64and(r: u32) -> Weight;
        fn instr_i64or(r: u32) -> Weight;
        fn instr_i64xor(r: u32) -> Weight;
        fn instr_i64shl(r: u32) -> Weight;
        fn instr_i64shrs(r: u32) -> Weight;
        fn instr_i64shru(r: u32) -> Weight;
        fn instr_i64rotl(r: u32) -> Weight;
        fn instr_i64rotr(r: u32) -> Weight;
    }
    /// Weights for pallet_contracts using the Substrate node and recommended hardware.
    pub struct SubstrateWeight<T>(PhantomData<T>);
    impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
        /// Storage: Contracts DeletionQueueCounter (r:1 w:0)
        /// Proof: Contracts DeletionQueueCounter (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        fn on_process_deletion_queue_batch() -> Weight {
            Weight::from_parts(2_748_000, 1594).saturating_add(T::DbWeight::get().reads(1_u64))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `k` is `[0, 1024]`.
        fn on_initialize_per_trie_key(k: u32) -> Weight {
            Weight::from_parts(8_026_118, 478)
                .saturating_add(Weight::from_parts(980_583, 0).saturating_mul(k.into()))
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(k.into())))
                .saturating_add(T::DbWeight::get().writes(2_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(k.into())))
                .saturating_add(Weight::from_parts(0, 70).saturating_mul(k.into()))
        }
        /// Storage: Contracts PristineCode (r:1 w:0)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// The range of component `c` is `[0, 61717]`.
        fn reinstrument(c: u32) -> Weight {
            Weight::from_parts(22_292_544, 3708)
                .saturating_add(Weight::from_parts(54_541, 0).saturating_mul(c.into()))
                .saturating_add(T::DbWeight::get().reads(1_u64))
                .saturating_add(T::DbWeight::get().writes(1_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(c.into()))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:1 w:1)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `c` is `[0, 125952]`.
        fn call_with_code_per_byte(c: u32) -> Weight {
            Weight::from_parts(277_799_331, 6656)
                .saturating_add(Weight::from_parts(37_876, 0).saturating_mul(c.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(c.into()))
        }
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:2 w:2)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts PristineCode (r:0 w:1)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        /// The range of component `c` is `[0, 61717]`.
        /// The range of component `i` is `[0, 1048576]`.
        /// The range of component `s` is `[0, 1048576]`.
        fn instantiate_with_code(c: u32, i: u32, s: u32) -> Weight {
            Weight::from_parts(594_826_134, 8659)
                .saturating_add(Weight::from_parts(106_471, 0).saturating_mul(c.into()))
                .saturating_add(Weight::from_parts(1_160, 0).saturating_mul(i.into()))
                .saturating_add(Weight::from_parts(1_417, 0).saturating_mul(s.into()))
                .saturating_add(T::DbWeight::get().reads(9_u64))
                .saturating_add(T::DbWeight::get().writes(10_u64))
        }
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:2 w:2)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `i` is `[0, 1048576]`.
        /// The range of component `s` is `[0, 1048576]`.
        fn instantiate(i: u32, s: u32) -> Weight {
            Weight::from_parts(296_038_081, 6408)
                .saturating_add(Weight::from_parts(1_461, 0).saturating_mul(i.into()))
                .saturating_add(Weight::from_parts(1_430, 0).saturating_mul(s.into()))
                .saturating_add(T::DbWeight::get().reads(9_u64))
                .saturating_add(T::DbWeight::get().writes(7_u64))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:1 w:1)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        fn call() -> Weight {
            Weight::from_parts(196_706_000, 6699)
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
        }
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:1 w:1)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts PristineCode (r:0 w:1)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        /// The range of component `c` is `[0, 61717]`.
        fn upload_code(c: u32) -> Weight {
            Weight::from_parts(252_985_435, 3574)
                .saturating_add(Weight::from_parts(108_141, 0).saturating_mul(c.into()))
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
        }
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:1 w:1)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts PristineCode (r:0 w:1)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        fn remove_code() -> Weight {
            Weight::from_parts(34_039_000, 3720)
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:2 w:2)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        fn set_code() -> Weight {
            Weight::from_parts(33_890_000, 8985)
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(6_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_caller(r: u32) -> Weight {
            Weight::from_parts(246_017_099, 6722)
                .saturating_add(Weight::from_parts(323_826, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1601 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_is_contract(r: u32) -> Weight {
            Weight::from_parts(87_361_934, 6743)
                .saturating_add(Weight::from_parts(3_329_840, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 2715).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1601 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_code_hash(r: u32) -> Weight {
            Weight::from_parts(76_953_007, 6747)
                .saturating_add(Weight::from_parts(4_132_521, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 2719).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_own_code_hash(r: u32) -> Weight {
            Weight::from_parts(243_136_007, 6730)
                .saturating_add(Weight::from_parts(414_717, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_caller_is_origin(r: u32) -> Weight {
            Weight::from_parts(244_517_187, 6723)
                .saturating_add(Weight::from_parts(167_431, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_caller_is_root(r: u32) -> Weight {
            Weight::from_parts(232_385_198, 6608)
                .saturating_add(Weight::from_parts(145_143, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(5_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_address(r: u32) -> Weight {
            Weight::from_parts(240_268_824, 6724)
                .saturating_add(Weight::from_parts(329_577, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_gas_left(r: u32) -> Weight {
            Weight::from_parts(242_389_500, 6719)
                .saturating_add(Weight::from_parts(518_380, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:2 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_balance(r: u32) -> Weight {
            Weight::from_parts(253_511_314, 6846)
                .saturating_add(Weight::from_parts(1_454_089, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_value_transferred(r: u32) -> Weight {
            Weight::from_parts(240_061_456, 6741)
                .saturating_add(Weight::from_parts(326_813, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_minimum_balance(r: u32) -> Weight {
            Weight::from_parts(240_875_314, 6739)
                .saturating_add(Weight::from_parts(324_519, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_block_number(r: u32) -> Weight {
            Weight::from_parts(242_269_896, 6737)
                .saturating_add(Weight::from_parts(317_998, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_now(r: u32) -> Weight {
            Weight::from_parts(242_938_271, 6723)
                .saturating_add(Weight::from_parts(316_782, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: TransactionPayment NextFeeMultiplier (r:1 w:0)
        /// Proof: TransactionPayment NextFeeMultiplier (max_values: Some(1), max_size: Some(16), added: 511, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_weight_to_fee(r: u32) -> Weight {
            Weight::from_parts(241_386_730, 6785)
                .saturating_add(Weight::from_parts(1_387_202, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 14).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_gas(r: u32) -> Weight {
            Weight::from_parts(170_794_127, 6687)
                .saturating_add(Weight::from_parts(127_931, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_input(r: u32) -> Weight {
            Weight::from_parts(237_110_694, 6724)
                .saturating_add(Weight::from_parts(280_610, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_input_per_byte(n: u32) -> Weight {
            Weight::from_parts(242_162_279, 6724)
                .saturating_add(Weight::from_parts(595, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1]`.
        fn seal_return(r: u32) -> Weight {
            Weight::from_parts(238_883_828, 6708)
                .saturating_add(Weight::from_parts(926_671, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 45).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_return_per_byte(n: u32) -> Weight {
            Weight::from_parts(240_382_910, 6731)
                .saturating_add(Weight::from_parts(181, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:4 w:4)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts DeletionQueueCounter (r:1 w:1)
        /// Proof: Contracts DeletionQueueCounter (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts DeletionQueue (r:0 w:1)
        /// Proof: Contracts DeletionQueue (max_values: None, max_size: Some(142), added: 2617, mode: Measured)
        /// The range of component `r` is `[0, 1]`.
        fn seal_terminate(r: u32) -> Weight {
            Weight::from_parts(241_041_330, 6750)
                .saturating_add(Weight::from_parts(115_332_869, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((6_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((8_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 7781).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: RandomnessCollectiveFlip RandomMaterial (r:1 w:0)
        /// Proof: RandomnessCollectiveFlip RandomMaterial (max_values: Some(1), max_size: Some(2594), added: 3089, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_random(r: u32) -> Weight {
            Weight::from_parts(259_901_113, 6769)
                .saturating_add(Weight::from_parts(1_764_269, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 10).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_deposit_event(r: u32) -> Weight {
            Weight::from_parts(264_915_436, 6723)
                .saturating_add(Weight::from_parts(3_452_918, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 10).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:6 w:6)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `t` is `[0, 4]`.
        /// The range of component `n` is `[0, 16384]`.
        fn seal_deposit_event_per_topic_and_byte(t: u32, n: u32) -> Weight {
            Weight::from_parts(247_945_758, 6744)
                .saturating_add(Weight::from_parts(2_483_239, 0).saturating_mul(t.into()))
                .saturating_add(Weight::from_parts(756, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(t.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(t.into())))
                .saturating_add(Weight::from_parts(0, 2508).saturating_mul(t.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_debug_message(r: u32) -> Weight {
            Weight::from_parts(177_306_567, 6721)
                .saturating_add(Weight::from_parts(230_558, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 7).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: MaxEncodedLen)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: MaxEncodedLen)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: MaxEncodedLen)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `i` is `[0, 1048576]`.
        fn seal_debug_message_per_byte(i: u32) -> Weight {
            Weight::from_parts(360_649_854, 131670)
                .saturating_add(Weight::from_parts(737, 0).saturating_mul(i.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_set_storage(r: u32) -> Weight {
            Weight::from_parts(136_431_436, 843)
                .saturating_add(Weight::from_parts(6_070_221, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 293).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_set_storage_per_new_byte(n: u32) -> Weight {
            Weight::from_parts(289_972_802, 1280)
                .saturating_add(Weight::from_parts(438, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(8_u64))
                .saturating_add(T::DbWeight::get().writes(6_u64))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_set_storage_per_old_byte(n: u32) -> Weight {
            Weight::from_parts(257_668_217, 1167)
                .saturating_add(Weight::from_parts(105, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_clear_storage(r: u32) -> Weight {
            Weight::from_parts(131_630_528, 845)
                .saturating_add(Weight::from_parts(5_910_066, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 289).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_clear_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(261_213_399, 1163)
                .saturating_add(Weight::from_parts(125, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_get_storage(r: u32) -> Weight {
            Weight::from_parts(151_326_508, 840)
                .saturating_add(Weight::from_parts(4_937_728, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 297).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_get_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(256_728_817, 1179)
                .saturating_add(Weight::from_parts(706, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_contains_storage(r: u32) -> Weight {
            Weight::from_parts(154_476_561, 857)
                .saturating_add(Weight::from_parts(4_805_043, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 289).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_contains_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(257_288_586, 1166)
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_take_storage(r: u32) -> Weight {
            Weight::from_parts(135_258_204, 836)
                .saturating_add(Weight::from_parts(6_144_770, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 297).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_take_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(260_068_186, 1180)
                .saturating_add(Weight::from_parts(744, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: System Account (r:1602 w:1601)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_transfer(r: u32) -> Weight {
            Weight::from_parts(243_465_000, 7270)
                .saturating_add(Weight::from_parts(35_376_623, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 2520).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:801 w:801)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:2 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:803 w:803)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_call(r: u32) -> Weight {
            Weight::from_parts(244_221_000, 9332)
                .saturating_add(Weight::from_parts(216_905_619, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(8_u64))
                .saturating_add(T::DbWeight::get().reads((2_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(T::DbWeight::get().writes((2_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 2752).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:736 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:737 w:737)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_delegate_call(r: u32) -> Weight {
            Weight::from_parts(243_068_000, 6727)
                .saturating_add(Weight::from_parts(213_096_291, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((2_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 2572).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:3 w:2)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:2 w:2)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:2 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:4 w:4)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `t` is `[0, 1]`.
        /// The range of component `c` is `[0, 1048576]`.
        fn seal_call_per_transfer_clone_byte(t: u32, c: u32) -> Weight {
            Weight::from_parts(394_587_369, 12044)
                .saturating_add(Weight::from_parts(30_461_758, 0).saturating_mul(t.into()))
                .saturating_add(Weight::from_parts(601, 0).saturating_mul(c.into()))
                .saturating_add(T::DbWeight::get().reads(10_u64))
                .saturating_add(T::DbWeight::get().reads((2_u64).saturating_mul(t.into())))
                .saturating_add(T::DbWeight::get().writes(6_u64))
                .saturating_add(T::DbWeight::get().writes((2_u64).saturating_mul(t.into())))
                .saturating_add(Weight::from_parts(0, 5154).saturating_mul(t.into()))
        }
        /// Storage: System Account (r:1602 w:1602)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:801 w:801)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:801 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:800 w:800)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:802 w:802)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[1, 800]`.
        fn seal_instantiate(r: u32) -> Weight {
            Weight::from_parts(582_275_000, 7146)
                .saturating_add(Weight::from_parts(349_770_967, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(8_u64))
                .saturating_add(T::DbWeight::get().reads((6_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(6_u64))
                .saturating_add(T::DbWeight::get().writes((5_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 5205).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:4 w:4)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:2 w:2)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:2 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `t` is `[0, 1]`.
        /// The range of component `i` is `[0, 983040]`.
        /// The range of component `s` is `[0, 983040]`.
        fn seal_instantiate_per_transfer_input_salt_byte(t: u32, i: u32, s: u32) -> Weight {
            Weight::from_parts(317_076_173, 9492)
                .saturating_add(Weight::from_parts(125_360_446, 0).saturating_mul(t.into()))
                .saturating_add(Weight::from_parts(1_183, 0).saturating_mul(i.into()))
                .saturating_add(Weight::from_parts(1_352, 0).saturating_mul(s.into()))
                .saturating_add(T::DbWeight::get().reads(13_u64))
                .saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(t.into())))
                .saturating_add(T::DbWeight::get().writes(10_u64))
                .saturating_add(T::DbWeight::get().writes((1_u64).saturating_mul(t.into())))
                .saturating_add(Weight::from_parts(0, 2634).saturating_mul(t.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_sha2_256(r: u32) -> Weight {
            Weight::from_parts(243_093_288, 6718)
                .saturating_add(Weight::from_parts(573_939, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_sha2_256_per_byte(n: u32) -> Weight {
            Weight::from_parts(242_849_333, 6725)
                .saturating_add(Weight::from_parts(3_949, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_keccak_256(r: u32) -> Weight {
            Weight::from_parts(242_510_631, 6721)
                .saturating_add(Weight::from_parts(742_726, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_keccak_256_per_byte(n: u32) -> Weight {
            Weight::from_parts(233_802_510, 6729)
                .saturating_add(Weight::from_parts(3_161, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_blake2_256(r: u32) -> Weight {
            Weight::from_parts(243_087_565, 6724)
                .saturating_add(Weight::from_parts(417_850, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_blake2_256_per_byte(n: u32) -> Weight {
            Weight::from_parts(233_528_258, 6733)
                .saturating_add(Weight::from_parts(913, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_blake2_128(r: u32) -> Weight {
            Weight::from_parts(240_476_401, 6725)
                .saturating_add(Weight::from_parts(416_869, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_blake2_128_per_byte(n: u32) -> Weight {
            Weight::from_parts(234_043_271, 6727)
                .saturating_add(Weight::from_parts(919, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 125697]`.
        fn seal_sr25519_verify_per_byte(n: u32) -> Weight {
            Weight::from_parts(301_523_608, 6849)
                .saturating_add(Weight::from_parts(4_676, 0).saturating_mul(n.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 160]`.
        fn seal_sr25519_verify(r: u32) -> Weight {
            Weight::from_parts(248_796_458, 6666)
                .saturating_add(Weight::from_parts(48_091_265, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 112).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 160]`.
        fn seal_ecdsa_recover(r: u32) -> Weight {
            Weight::from_parts(261_355_525, 6717)
                .saturating_add(Weight::from_parts(37_603_073, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 77).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 160]`.
        fn seal_ecdsa_to_eth_address(r: u32) -> Weight {
            Weight::from_parts(245_135_291, 6731)
                .saturating_add(Weight::from_parts(9_344_876, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 42).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1536 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1536 w:1536)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:1538 w:1538)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_set_code_hash(r: u32) -> Weight {
            Weight::from_parts(241_653_000, 8190)
                .saturating_add(Weight::from_parts(22_107_816, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().reads((3_u64).saturating_mul(r.into())))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(T::DbWeight::get().writes((2_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 3090).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_reentrance_count(r: u32) -> Weight {
            Weight::from_parts(245_471_045, 6723)
                .saturating_add(Weight::from_parts(159_577, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_account_reentrance_count(r: u32) -> Weight {
            Weight::from_parts(274_518_595, 7805)
                .saturating_add(Weight::from_parts(256_973, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 40).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_instantiation_nonce(r: u32) -> Weight {
            Weight::from_parts(245_990_810, 6723)
                .saturating_add(Weight::from_parts(143_408, 0).saturating_mul(r.into()))
                .saturating_add(T::DbWeight::get().reads(7_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64const(r: u32) -> Weight {
            Weight::from_parts(1_900_268, 0)
                .saturating_add(Weight::from_parts(2_950, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64load(r: u32) -> Weight {
            Weight::from_parts(2_109_373, 0)
                .saturating_add(Weight::from_parts(6_586, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64store(r: u32) -> Weight {
            Weight::from_parts(2_268_507, 0)
                .saturating_add(Weight::from_parts(6_022, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_select(r: u32) -> Weight {
            Weight::from_parts(2_042_521, 0)
                .saturating_add(Weight::from_parts(7_935, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_if(r: u32) -> Weight {
            Weight::from_parts(1_902_691, 0)
                .saturating_add(Weight::from_parts(10_572, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_br(r: u32) -> Weight {
            Weight::from_parts(1_891_843, 0)
                .saturating_add(Weight::from_parts(4_612, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_br_if(r: u32) -> Weight {
            Weight::from_parts(1_139_823, 0)
                .saturating_add(Weight::from_parts(8_008, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_br_table(r: u32) -> Weight {
            Weight::from_parts(1_258_400, 0)
                .saturating_add(Weight::from_parts(9_706, 0).saturating_mul(r.into()))
        }
        /// The range of component `e` is `[1, 256]`.
        fn instr_br_table_per_entry(e: u32) -> Weight {
            Weight::from_parts(1_876_118, 0)
                .saturating_add(Weight::from_parts(4, 0).saturating_mul(e.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_call(r: u32) -> Weight {
            Weight::from_parts(1_565_613, 0)
                .saturating_add(Weight::from_parts(19_575, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_call_indirect(r: u32) -> Weight {
            Weight::from_parts(4_549_584, 0)
                .saturating_add(Weight::from_parts(24_336, 0).saturating_mul(r.into()))
        }
        /// The range of component `l` is `[0, 1024]`.
        fn instr_call_per_local(l: u32) -> Weight {
            Weight::from_parts(2_087_387, 0)
                .saturating_add(Weight::from_parts(1_041, 0).saturating_mul(l.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_local_get(r: u32) -> Weight {
            Weight::from_parts(3_552_428, 0)
                .saturating_add(Weight::from_parts(2_339, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_local_set(r: u32) -> Weight {
            Weight::from_parts(3_151_948, 0)
                .saturating_add(Weight::from_parts(3_667, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_local_tee(r: u32) -> Weight {
            Weight::from_parts(3_214_587, 0)
                .saturating_add(Weight::from_parts(3_867, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_global_get(r: u32) -> Weight {
            Weight::from_parts(1_815_683, 0)
                .saturating_add(Weight::from_parts(8_733, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_global_set(r: u32) -> Weight {
            Weight::from_parts(2_437_152, 0)
                .saturating_add(Weight::from_parts(8_839, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_memory_current(r: u32) -> Weight {
            Weight::from_parts(2_018_078, 0)
                .saturating_add(Weight::from_parts(3_756, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 16]`.
        fn instr_memory_grow(r: u32) -> Weight {
            Weight::from_parts(648_059, 0)
                .saturating_add(Weight::from_parts(13_313_060, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64clz(r: u32) -> Weight {
            Weight::from_parts(1_953_179, 0)
                .saturating_add(Weight::from_parts(3_828, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ctz(r: u32) -> Weight {
            Weight::from_parts(1_924_759, 0)
                .saturating_add(Weight::from_parts(3_762, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64popcnt(r: u32) -> Weight {
            Weight::from_parts(1_959_683, 0)
                .saturating_add(Weight::from_parts(3_754, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64eqz(r: u32) -> Weight {
            Weight::from_parts(1_975_838, 0)
                .saturating_add(Weight::from_parts(3_681, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64extendsi32(r: u32) -> Weight {
            Weight::from_parts(1_980_109, 0)
                .saturating_add(Weight::from_parts(3_880, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64extendui32(r: u32) -> Weight {
            Weight::from_parts(1_912_089, 0)
                .saturating_add(Weight::from_parts(3_896, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i32wrapi64(r: u32) -> Weight {
            Weight::from_parts(1_951_485, 0)
                .saturating_add(Weight::from_parts(3_725, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64eq(r: u32) -> Weight {
            Weight::from_parts(1_937_598, 0)
                .saturating_add(Weight::from_parts(6_045, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ne(r: u32) -> Weight {
            Weight::from_parts(2_202_977, 0)
                .saturating_add(Weight::from_parts(6_299, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64lts(r: u32) -> Weight {
            Weight::from_parts(1_946_304, 0)
                .saturating_add(Weight::from_parts(6_019, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ltu(r: u32) -> Weight {
            Weight::from_parts(1_933_375, 0)
                .saturating_add(Weight::from_parts(6_020, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64gts(r: u32) -> Weight {
            Weight::from_parts(2_003_850, 0)
                .saturating_add(Weight::from_parts(5_816, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64gtu(r: u32) -> Weight {
            Weight::from_parts(1_971_321, 0)
                .saturating_add(Weight::from_parts(6_114, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64les(r: u32) -> Weight {
            Weight::from_parts(2_017_232, 0)
                .saturating_add(Weight::from_parts(5_990, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64leu(r: u32) -> Weight {
            Weight::from_parts(3_232_848, 0)
                .saturating_add(Weight::from_parts(5_816, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ges(r: u32) -> Weight {
            Weight::from_parts(1_996_165, 0)
                .saturating_add(Weight::from_parts(5_964, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64geu(r: u32) -> Weight {
            Weight::from_parts(1_973_238, 0)
                .saturating_add(Weight::from_parts(6_021, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64add(r: u32) -> Weight {
            Weight::from_parts(1_981_762, 0)
                .saturating_add(Weight::from_parts(5_898, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64sub(r: u32) -> Weight {
            Weight::from_parts(1_935_700, 0)
                .saturating_add(Weight::from_parts(6_154, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64mul(r: u32) -> Weight {
            Weight::from_parts(1_942_734, 0)
                .saturating_add(Weight::from_parts(5_797, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64divs(r: u32) -> Weight {
            Weight::from_parts(2_960_454, 0)
                .saturating_add(Weight::from_parts(11_666, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64divu(r: u32) -> Weight {
            Weight::from_parts(2_104_200, 0)
                .saturating_add(Weight::from_parts(10_540, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64rems(r: u32) -> Weight {
            Weight::from_parts(2_602_908, 0)
                .saturating_add(Weight::from_parts(11_900, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64remu(r: u32) -> Weight {
            Weight::from_parts(2_056_817, 0)
                .saturating_add(Weight::from_parts(10_722, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64and(r: u32) -> Weight {
            Weight::from_parts(1_988_892, 0)
                .saturating_add(Weight::from_parts(5_683, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64or(r: u32) -> Weight {
            Weight::from_parts(2_148_537, 0)
                .saturating_add(Weight::from_parts(5_756, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64xor(r: u32) -> Weight {
            Weight::from_parts(1_955_010, 0)
                .saturating_add(Weight::from_parts(5_931, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64shl(r: u32) -> Weight {
            Weight::from_parts(1_982_403, 0)
                .saturating_add(Weight::from_parts(5_867, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64shrs(r: u32) -> Weight {
            Weight::from_parts(1_989_920, 0)
                .saturating_add(Weight::from_parts(6_137, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64shru(r: u32) -> Weight {
            Weight::from_parts(2_020_935, 0)
                .saturating_add(Weight::from_parts(5_863, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64rotl(r: u32) -> Weight {
            Weight::from_parts(2_320_710, 0)
                .saturating_add(Weight::from_parts(5_922, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64rotr(r: u32) -> Weight {
            Weight::from_parts(2_044_188, 0)
                .saturating_add(Weight::from_parts(5_855, 0).saturating_mul(r.into()))
        }
    }
    impl WeightInfo for () {
        /// Storage: Contracts DeletionQueueCounter (r:1 w:0)
        /// Proof: Contracts DeletionQueueCounter (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        fn on_process_deletion_queue_batch() -> Weight {
            Weight::from_parts(2_748_000, 1594).saturating_add(RocksDbWeight::get().reads(1_u64))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `k` is `[0, 1024]`.
        fn on_initialize_per_trie_key(k: u32) -> Weight {
            Weight::from_parts(8_026_118, 478)
                .saturating_add(Weight::from_parts(980_583, 0).saturating_mul(k.into()))
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(k.into())))
                .saturating_add(RocksDbWeight::get().writes(2_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(k.into())))
                .saturating_add(Weight::from_parts(0, 70).saturating_mul(k.into()))
        }
        /// Storage: Contracts PristineCode (r:1 w:0)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// The range of component `c` is `[0, 61717]`.
        fn reinstrument(c: u32) -> Weight {
            Weight::from_parts(22_292_544, 3708)
                .saturating_add(Weight::from_parts(54_541, 0).saturating_mul(c.into()))
                .saturating_add(RocksDbWeight::get().reads(1_u64))
                .saturating_add(RocksDbWeight::get().writes(1_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(c.into()))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:1 w:1)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `c` is `[0, 125952]`.
        fn call_with_code_per_byte(c: u32) -> Weight {
            Weight::from_parts(277_799_331, 6656)
                .saturating_add(Weight::from_parts(37_876, 0).saturating_mul(c.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(c.into()))
        }
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:2 w:2)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts PristineCode (r:0 w:1)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        /// The range of component `c` is `[0, 61717]`.
        /// The range of component `i` is `[0, 1048576]`.
        /// The range of component `s` is `[0, 1048576]`.
        fn instantiate_with_code(c: u32, i: u32, s: u32) -> Weight {
            Weight::from_parts(594_826_134, 8659)
                .saturating_add(Weight::from_parts(106_471, 0).saturating_mul(c.into()))
                .saturating_add(Weight::from_parts(1_160, 0).saturating_mul(i.into()))
                .saturating_add(Weight::from_parts(1_417, 0).saturating_mul(s.into()))
                .saturating_add(RocksDbWeight::get().reads(9_u64))
                .saturating_add(RocksDbWeight::get().writes(10_u64))
        }
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:2 w:2)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `i` is `[0, 1048576]`.
        /// The range of component `s` is `[0, 1048576]`.
        fn instantiate(i: u32, s: u32) -> Weight {
            Weight::from_parts(296_038_081, 6408)
                .saturating_add(Weight::from_parts(1_461, 0).saturating_mul(i.into()))
                .saturating_add(Weight::from_parts(1_430, 0).saturating_mul(s.into()))
                .saturating_add(RocksDbWeight::get().reads(9_u64))
                .saturating_add(RocksDbWeight::get().writes(7_u64))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System Account (r:1 w:1)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        fn call() -> Weight {
            Weight::from_parts(196_706_000, 6699)
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
        }
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:1 w:1)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts PristineCode (r:0 w:1)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        /// The range of component `c` is `[0, 61717]`.
        fn upload_code(c: u32) -> Weight {
            Weight::from_parts(252_985_435, 3574)
                .saturating_add(Weight::from_parts(108_141, 0).saturating_mul(c.into()))
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
        }
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:1 w:1)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts CodeStorage (r:0 w:1)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Contracts PristineCode (r:0 w:1)
        /// Proof: Contracts PristineCode (max_values: None, max_size: Some(125988), added: 128463, mode: Measured)
        fn remove_code() -> Weight {
            Weight::from_parts(34_039_000, 3720)
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:2 w:2)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        fn set_code() -> Weight {
            Weight::from_parts(33_890_000, 8985)
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(6_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_caller(r: u32) -> Weight {
            Weight::from_parts(246_017_099, 6722)
                .saturating_add(Weight::from_parts(323_826, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1601 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_is_contract(r: u32) -> Weight {
            Weight::from_parts(87_361_934, 6743)
                .saturating_add(Weight::from_parts(3_329_840, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 2715).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1601 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_code_hash(r: u32) -> Weight {
            Weight::from_parts(76_953_007, 6747)
                .saturating_add(Weight::from_parts(4_132_521, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 2719).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_own_code_hash(r: u32) -> Weight {
            Weight::from_parts(243_136_007, 6730)
                .saturating_add(Weight::from_parts(414_717, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_caller_is_origin(r: u32) -> Weight {
            Weight::from_parts(244_517_187, 6723)
                .saturating_add(Weight::from_parts(167_431, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_caller_is_root(r: u32) -> Weight {
            Weight::from_parts(232_385_198, 6608)
                .saturating_add(Weight::from_parts(145_143, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(5_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_address(r: u32) -> Weight {
            Weight::from_parts(240_268_824, 6724)
                .saturating_add(Weight::from_parts(329_577, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_gas_left(r: u32) -> Weight {
            Weight::from_parts(242_389_500, 6719)
                .saturating_add(Weight::from_parts(518_380, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:2 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_balance(r: u32) -> Weight {
            Weight::from_parts(253_511_314, 6846)
                .saturating_add(Weight::from_parts(1_454_089, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_value_transferred(r: u32) -> Weight {
            Weight::from_parts(240_061_456, 6741)
                .saturating_add(Weight::from_parts(326_813, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_minimum_balance(r: u32) -> Weight {
            Weight::from_parts(240_875_314, 6739)
                .saturating_add(Weight::from_parts(324_519, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_block_number(r: u32) -> Weight {
            Weight::from_parts(242_269_896, 6737)
                .saturating_add(Weight::from_parts(317_998, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_now(r: u32) -> Weight {
            Weight::from_parts(242_938_271, 6723)
                .saturating_add(Weight::from_parts(316_782, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: TransactionPayment NextFeeMultiplier (r:1 w:0)
        /// Proof: TransactionPayment NextFeeMultiplier (max_values: Some(1), max_size: Some(16), added: 511, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_weight_to_fee(r: u32) -> Weight {
            Weight::from_parts(241_386_730, 6785)
                .saturating_add(Weight::from_parts(1_387_202, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 14).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_gas(r: u32) -> Weight {
            Weight::from_parts(170_794_127, 6687)
                .saturating_add(Weight::from_parts(127_931, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_input(r: u32) -> Weight {
            Weight::from_parts(237_110_694, 6724)
                .saturating_add(Weight::from_parts(280_610, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 6).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_input_per_byte(n: u32) -> Weight {
            Weight::from_parts(242_162_279, 6724)
                .saturating_add(Weight::from_parts(595, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1]`.
        fn seal_return(r: u32) -> Weight {
            Weight::from_parts(238_883_828, 6708)
                .saturating_add(Weight::from_parts(926_671, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 45).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_return_per_byte(n: u32) -> Weight {
            Weight::from_parts(240_382_910, 6731)
                .saturating_add(Weight::from_parts(181, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:4 w:4)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts DeletionQueueCounter (r:1 w:1)
        /// Proof: Contracts DeletionQueueCounter (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// Storage: Contracts DeletionQueue (r:0 w:1)
        /// Proof: Contracts DeletionQueue (max_values: None, max_size: Some(142), added: 2617, mode: Measured)
        /// The range of component `r` is `[0, 1]`.
        fn seal_terminate(r: u32) -> Weight {
            Weight::from_parts(241_041_330, 6750)
                .saturating_add(Weight::from_parts(115_332_869, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((6_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((8_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 7781).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: RandomnessCollectiveFlip RandomMaterial (r:1 w:0)
        /// Proof: RandomnessCollectiveFlip RandomMaterial (max_values: Some(1), max_size: Some(2594), added: 3089, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_random(r: u32) -> Weight {
            Weight::from_parts(259_901_113, 6769)
                .saturating_add(Weight::from_parts(1_764_269, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 10).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_deposit_event(r: u32) -> Weight {
            Weight::from_parts(264_915_436, 6723)
                .saturating_add(Weight::from_parts(3_452_918, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 10).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:6 w:6)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `t` is `[0, 4]`.
        /// The range of component `n` is `[0, 16384]`.
        fn seal_deposit_event_per_topic_and_byte(t: u32, n: u32) -> Weight {
            Weight::from_parts(247_945_758, 6744)
                .saturating_add(Weight::from_parts(2_483_239, 0).saturating_mul(t.into()))
                .saturating_add(Weight::from_parts(756, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(t.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(t.into())))
                .saturating_add(Weight::from_parts(0, 2508).saturating_mul(t.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_debug_message(r: u32) -> Weight {
            Weight::from_parts(177_306_567, 6721)
                .saturating_add(Weight::from_parts(230_558, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 7).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: MaxEncodedLen)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: MaxEncodedLen)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: MaxEncodedLen)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `i` is `[0, 1048576]`.
        fn seal_debug_message_per_byte(i: u32) -> Weight {
            Weight::from_parts(360_649_854, 131670)
                .saturating_add(Weight::from_parts(737, 0).saturating_mul(i.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_set_storage(r: u32) -> Weight {
            Weight::from_parts(136_431_436, 843)
                .saturating_add(Weight::from_parts(6_070_221, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 293).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_set_storage_per_new_byte(n: u32) -> Weight {
            Weight::from_parts(289_972_802, 1280)
                .saturating_add(Weight::from_parts(438, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(8_u64))
                .saturating_add(RocksDbWeight::get().writes(6_u64))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_set_storage_per_old_byte(n: u32) -> Weight {
            Weight::from_parts(257_668_217, 1167)
                .saturating_add(Weight::from_parts(105, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_clear_storage(r: u32) -> Weight {
            Weight::from_parts(131_630_528, 845)
                .saturating_add(Weight::from_parts(5_910_066, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 289).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_clear_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(261_213_399, 1163)
                .saturating_add(Weight::from_parts(125, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_get_storage(r: u32) -> Weight {
            Weight::from_parts(151_326_508, 840)
                .saturating_add(Weight::from_parts(4_937_728, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 297).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_get_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(256_728_817, 1179)
                .saturating_add(Weight::from_parts(706, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_contains_storage(r: u32) -> Weight {
            Weight::from_parts(154_476_561, 857)
                .saturating_add(Weight::from_parts(4_805_043, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 289).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_contains_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(257_288_586, 1166)
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_take_storage(r: u32) -> Weight {
            Weight::from_parts(135_258_204, 836)
                .saturating_add(Weight::from_parts(6_144_770, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 297).saturating_mul(r.into()))
        }
        /// Storage: Skipped Metadata (r:0 w:0)
        /// Proof Skipped: Skipped Metadata (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 16384]`.
        fn seal_take_storage_per_byte(n: u32) -> Weight {
            Weight::from_parts(260_068_186, 1180)
                .saturating_add(Weight::from_parts(744, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: System Account (r:1602 w:1601)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_transfer(r: u32) -> Weight {
            Weight::from_parts(243_465_000, 7270)
                .saturating_add(Weight::from_parts(35_376_623, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 2520).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:801 w:801)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:2 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:803 w:803)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_call(r: u32) -> Weight {
            Weight::from_parts(244_221_000, 9332)
                .saturating_add(Weight::from_parts(216_905_619, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(8_u64))
                .saturating_add(RocksDbWeight::get().reads((2_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(RocksDbWeight::get().writes((2_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 2752).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:736 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:737 w:737)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 800]`.
        fn seal_delegate_call(r: u32) -> Weight {
            Weight::from_parts(243_068_000, 6727)
                .saturating_add(Weight::from_parts(213_096_291, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((2_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 2572).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:3 w:2)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:2 w:2)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:2 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:4 w:4)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `t` is `[0, 1]`.
        /// The range of component `c` is `[0, 1048576]`.
        fn seal_call_per_transfer_clone_byte(t: u32, c: u32) -> Weight {
            Weight::from_parts(394_587_369, 12044)
                .saturating_add(Weight::from_parts(30_461_758, 0).saturating_mul(t.into()))
                .saturating_add(Weight::from_parts(601, 0).saturating_mul(c.into()))
                .saturating_add(RocksDbWeight::get().reads(10_u64))
                .saturating_add(RocksDbWeight::get().reads((2_u64).saturating_mul(t.into())))
                .saturating_add(RocksDbWeight::get().writes(6_u64))
                .saturating_add(RocksDbWeight::get().writes((2_u64).saturating_mul(t.into())))
                .saturating_add(Weight::from_parts(0, 5154).saturating_mul(t.into()))
        }
        /// Storage: System Account (r:1602 w:1602)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:801 w:801)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:801 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:800 w:800)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:802 w:802)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[1, 800]`.
        fn seal_instantiate(r: u32) -> Weight {
            Weight::from_parts(582_275_000, 7146)
                .saturating_add(Weight::from_parts(349_770_967, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(8_u64))
                .saturating_add(RocksDbWeight::get().reads((6_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(6_u64))
                .saturating_add(RocksDbWeight::get().writes((5_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 5205).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:4 w:4)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:2 w:2)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:2 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1 w:1)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:3 w:3)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `t` is `[0, 1]`.
        /// The range of component `i` is `[0, 983040]`.
        /// The range of component `s` is `[0, 983040]`.
        fn seal_instantiate_per_transfer_input_salt_byte(t: u32, i: u32, s: u32) -> Weight {
            Weight::from_parts(317_076_173, 9492)
                .saturating_add(Weight::from_parts(125_360_446, 0).saturating_mul(t.into()))
                .saturating_add(Weight::from_parts(1_183, 0).saturating_mul(i.into()))
                .saturating_add(Weight::from_parts(1_352, 0).saturating_mul(s.into()))
                .saturating_add(RocksDbWeight::get().reads(13_u64))
                .saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(t.into())))
                .saturating_add(RocksDbWeight::get().writes(10_u64))
                .saturating_add(RocksDbWeight::get().writes((1_u64).saturating_mul(t.into())))
                .saturating_add(Weight::from_parts(0, 2634).saturating_mul(t.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_sha2_256(r: u32) -> Weight {
            Weight::from_parts(243_093_288, 6718)
                .saturating_add(Weight::from_parts(573_939, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_sha2_256_per_byte(n: u32) -> Weight {
            Weight::from_parts(242_849_333, 6725)
                .saturating_add(Weight::from_parts(3_949, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_keccak_256(r: u32) -> Weight {
            Weight::from_parts(242_510_631, 6721)
                .saturating_add(Weight::from_parts(742_726, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_keccak_256_per_byte(n: u32) -> Weight {
            Weight::from_parts(233_802_510, 6729)
                .saturating_add(Weight::from_parts(3_161, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_blake2_256(r: u32) -> Weight {
            Weight::from_parts(243_087_565, 6724)
                .saturating_add(Weight::from_parts(417_850, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_blake2_256_per_byte(n: u32) -> Weight {
            Weight::from_parts(233_528_258, 6733)
                .saturating_add(Weight::from_parts(913, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_hash_blake2_128(r: u32) -> Weight {
            Weight::from_parts(240_476_401, 6725)
                .saturating_add(Weight::from_parts(416_869, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 8).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 1048576]`.
        fn seal_hash_blake2_128_per_byte(n: u32) -> Weight {
            Weight::from_parts(234_043_271, 6727)
                .saturating_add(Weight::from_parts(919, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `n` is `[0, 125697]`.
        fn seal_sr25519_verify_per_byte(n: u32) -> Weight {
            Weight::from_parts(301_523_608, 6849)
                .saturating_add(Weight::from_parts(4_676, 0).saturating_mul(n.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 1).saturating_mul(n.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 160]`.
        fn seal_sr25519_verify(r: u32) -> Weight {
            Weight::from_parts(248_796_458, 6666)
                .saturating_add(Weight::from_parts(48_091_265, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 112).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 160]`.
        fn seal_ecdsa_recover(r: u32) -> Weight {
            Weight::from_parts(261_355_525, 6717)
                .saturating_add(Weight::from_parts(37_603_073, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 77).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 160]`.
        fn seal_ecdsa_to_eth_address(r: u32) -> Weight {
            Weight::from_parts(245_135_291, 6731)
                .saturating_add(Weight::from_parts(9_344_876, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 42).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1536 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts OwnerInfoOf (r:1536 w:1536)
        /// Proof: Contracts OwnerInfoOf (max_values: None, max_size: Some(88), added: 2563, mode: Measured)
        /// Storage: System EventTopics (r:1538 w:1538)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_set_code_hash(r: u32) -> Weight {
            Weight::from_parts(241_653_000, 8190)
                .saturating_add(Weight::from_parts(22_107_816, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().reads((3_u64).saturating_mul(r.into())))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(RocksDbWeight::get().writes((2_u64).saturating_mul(r.into())))
                .saturating_add(Weight::from_parts(0, 3090).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_reentrance_count(r: u32) -> Weight {
            Weight::from_parts(245_471_045, 6723)
                .saturating_add(Weight::from_parts(159_577, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_account_reentrance_count(r: u32) -> Weight {
            Weight::from_parts(274_518_595, 7805)
                .saturating_add(Weight::from_parts(256_973, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(Weight::from_parts(0, 40).saturating_mul(r.into()))
        }
        /// Storage: System Account (r:1 w:0)
        /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: Measured)
        /// Storage: Contracts ContractInfoOf (r:1 w:1)
        /// Proof: Contracts ContractInfoOf (max_values: None, max_size: Some(290), added: 2765, mode: Measured)
        /// Storage: Contracts CodeStorage (r:1 w:0)
        /// Proof: Contracts CodeStorage (max_values: None, max_size: Some(126001), added: 128476, mode: Measured)
        /// Storage: Timestamp Now (r:1 w:0)
        /// Proof: Timestamp Now (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: Contracts Nonce (r:1 w:1)
        /// Proof: Contracts Nonce (max_values: Some(1), max_size: Some(8), added: 503, mode: Measured)
        /// Storage: System EventTopics (r:2 w:2)
        /// Proof Skipped: System EventTopics (max_values: None, max_size: None, mode: Measured)
        /// The range of component `r` is `[0, 1600]`.
        fn seal_instantiation_nonce(r: u32) -> Weight {
            Weight::from_parts(245_990_810, 6723)
                .saturating_add(Weight::from_parts(143_408, 0).saturating_mul(r.into()))
                .saturating_add(RocksDbWeight::get().reads(7_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(Weight::from_parts(0, 3).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64const(r: u32) -> Weight {
            Weight::from_parts(1_900_268, 0)
                .saturating_add(Weight::from_parts(2_950, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64load(r: u32) -> Weight {
            Weight::from_parts(2_109_373, 0)
                .saturating_add(Weight::from_parts(6_586, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64store(r: u32) -> Weight {
            Weight::from_parts(2_268_507, 0)
                .saturating_add(Weight::from_parts(6_022, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_select(r: u32) -> Weight {
            Weight::from_parts(2_042_521, 0)
                .saturating_add(Weight::from_parts(7_935, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_if(r: u32) -> Weight {
            Weight::from_parts(1_902_691, 0)
                .saturating_add(Weight::from_parts(10_572, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_br(r: u32) -> Weight {
            Weight::from_parts(1_891_843, 0)
                .saturating_add(Weight::from_parts(4_612, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_br_if(r: u32) -> Weight {
            Weight::from_parts(1_139_823, 0)
                .saturating_add(Weight::from_parts(8_008, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_br_table(r: u32) -> Weight {
            Weight::from_parts(1_258_400, 0)
                .saturating_add(Weight::from_parts(9_706, 0).saturating_mul(r.into()))
        }
        /// The range of component `e` is `[1, 256]`.
        fn instr_br_table_per_entry(e: u32) -> Weight {
            Weight::from_parts(1_876_118, 0)
                .saturating_add(Weight::from_parts(4, 0).saturating_mul(e.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_call(r: u32) -> Weight {
            Weight::from_parts(1_565_613, 0)
                .saturating_add(Weight::from_parts(19_575, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_call_indirect(r: u32) -> Weight {
            Weight::from_parts(4_549_584, 0)
                .saturating_add(Weight::from_parts(24_336, 0).saturating_mul(r.into()))
        }
        /// The range of component `l` is `[0, 1024]`.
        fn instr_call_per_local(l: u32) -> Weight {
            Weight::from_parts(2_087_387, 0)
                .saturating_add(Weight::from_parts(1_041, 0).saturating_mul(l.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_local_get(r: u32) -> Weight {
            Weight::from_parts(3_552_428, 0)
                .saturating_add(Weight::from_parts(2_339, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_local_set(r: u32) -> Weight {
            Weight::from_parts(3_151_948, 0)
                .saturating_add(Weight::from_parts(3_667, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_local_tee(r: u32) -> Weight {
            Weight::from_parts(3_214_587, 0)
                .saturating_add(Weight::from_parts(3_867, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_global_get(r: u32) -> Weight {
            Weight::from_parts(1_815_683, 0)
                .saturating_add(Weight::from_parts(8_733, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_global_set(r: u32) -> Weight {
            Weight::from_parts(2_437_152, 0)
                .saturating_add(Weight::from_parts(8_839, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_memory_current(r: u32) -> Weight {
            Weight::from_parts(2_018_078, 0)
                .saturating_add(Weight::from_parts(3_756, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 16]`.
        fn instr_memory_grow(r: u32) -> Weight {
            Weight::from_parts(648_059, 0)
                .saturating_add(Weight::from_parts(13_313_060, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64clz(r: u32) -> Weight {
            Weight::from_parts(1_953_179, 0)
                .saturating_add(Weight::from_parts(3_828, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ctz(r: u32) -> Weight {
            Weight::from_parts(1_924_759, 0)
                .saturating_add(Weight::from_parts(3_762, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64popcnt(r: u32) -> Weight {
            Weight::from_parts(1_959_683, 0)
                .saturating_add(Weight::from_parts(3_754, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64eqz(r: u32) -> Weight {
            Weight::from_parts(1_975_838, 0)
                .saturating_add(Weight::from_parts(3_681, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64extendsi32(r: u32) -> Weight {
            Weight::from_parts(1_980_109, 0)
                .saturating_add(Weight::from_parts(3_880, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64extendui32(r: u32) -> Weight {
            Weight::from_parts(1_912_089, 0)
                .saturating_add(Weight::from_parts(3_896, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i32wrapi64(r: u32) -> Weight {
            Weight::from_parts(1_951_485, 0)
                .saturating_add(Weight::from_parts(3_725, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64eq(r: u32) -> Weight {
            Weight::from_parts(1_937_598, 0)
                .saturating_add(Weight::from_parts(6_045, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ne(r: u32) -> Weight {
            Weight::from_parts(2_202_977, 0)
                .saturating_add(Weight::from_parts(6_299, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64lts(r: u32) -> Weight {
            Weight::from_parts(1_946_304, 0)
                .saturating_add(Weight::from_parts(6_019, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ltu(r: u32) -> Weight {
            Weight::from_parts(1_933_375, 0)
                .saturating_add(Weight::from_parts(6_020, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64gts(r: u32) -> Weight {
            Weight::from_parts(2_003_850, 0)
                .saturating_add(Weight::from_parts(5_816, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64gtu(r: u32) -> Weight {
            Weight::from_parts(1_971_321, 0)
                .saturating_add(Weight::from_parts(6_114, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64les(r: u32) -> Weight {
            Weight::from_parts(2_017_232, 0)
                .saturating_add(Weight::from_parts(5_990, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64leu(r: u32) -> Weight {
            Weight::from_parts(3_232_848, 0)
                .saturating_add(Weight::from_parts(5_816, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64ges(r: u32) -> Weight {
            Weight::from_parts(1_996_165, 0)
                .saturating_add(Weight::from_parts(5_964, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64geu(r: u32) -> Weight {
            Weight::from_parts(1_973_238, 0)
                .saturating_add(Weight::from_parts(6_021, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64add(r: u32) -> Weight {
            Weight::from_parts(1_981_762, 0)
                .saturating_add(Weight::from_parts(5_898, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64sub(r: u32) -> Weight {
            Weight::from_parts(1_935_700, 0)
                .saturating_add(Weight::from_parts(6_154, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64mul(r: u32) -> Weight {
            Weight::from_parts(1_942_734, 0)
                .saturating_add(Weight::from_parts(5_797, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64divs(r: u32) -> Weight {
            Weight::from_parts(2_960_454, 0)
                .saturating_add(Weight::from_parts(11_666, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64divu(r: u32) -> Weight {
            Weight::from_parts(2_104_200, 0)
                .saturating_add(Weight::from_parts(10_540, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64rems(r: u32) -> Weight {
            Weight::from_parts(2_602_908, 0)
                .saturating_add(Weight::from_parts(11_900, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64remu(r: u32) -> Weight {
            Weight::from_parts(2_056_817, 0)
                .saturating_add(Weight::from_parts(10_722, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64and(r: u32) -> Weight {
            Weight::from_parts(1_988_892, 0)
                .saturating_add(Weight::from_parts(5_683, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64or(r: u32) -> Weight {
            Weight::from_parts(2_148_537, 0)
                .saturating_add(Weight::from_parts(5_756, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64xor(r: u32) -> Weight {
            Weight::from_parts(1_955_010, 0)
                .saturating_add(Weight::from_parts(5_931, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64shl(r: u32) -> Weight {
            Weight::from_parts(1_982_403, 0)
                .saturating_add(Weight::from_parts(5_867, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64shrs(r: u32) -> Weight {
            Weight::from_parts(1_989_920, 0)
                .saturating_add(Weight::from_parts(6_137, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64shru(r: u32) -> Weight {
            Weight::from_parts(2_020_935, 0)
                .saturating_add(Weight::from_parts(5_863, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64rotl(r: u32) -> Weight {
            Weight::from_parts(2_320_710, 0)
                .saturating_add(Weight::from_parts(5_922, 0).saturating_mul(r.into()))
        }
        /// The range of component `r` is `[0, 5000]`.
        fn instr_i64rotr(r: u32) -> Weight {
            Weight::from_parts(2_044_188, 0)
                .saturating_add(Weight::from_parts(5_855, 0).saturating_mul(r.into()))
        }
    }
}
use crate::{
    exec::{AccountIdOf, ErrorOrigin, ExecError, Executable, Key, Stack as ExecStack},
    gas::GasMeter,
    storage::{meter::Meter as StorageMeter, ContractInfo, DeletionQueueManager},
    wasm::{OwnerInfo, PrefabWasmModule, TryInstantiate},
    weights::WeightInfo,
};
use codec::{Codec, Decode, Encode, HasCompact};
use environmental::*;
use frame_support::{
    dispatch::{DispatchError, Dispatchable, GetDispatchInfo, Pays, PostDispatchInfo, RawOrigin},
    ensure,
    error::BadOrigin,
    traits::{
        tokens::fungible::Inspect, ConstU32, Contains, Currency, Get, Randomness,
        ReservableCurrency, Time,
    },
    weights::Weight,
    BoundedVec, RuntimeDebugNoBound, WeakBoundedVec,
};
use frame_system::{ensure_signed, pallet_prelude::OriginFor, EventRecord, Pallet as System};
use pallet_contracts_primitives::{
    Code, CodeUploadResult, CodeUploadReturnValue, ContractAccessError, ContractExecResult,
    ContractInstantiateResult, ExecReturnValue, GetStorageResult, InstantiateReturnValue,
    StorageDeposit,
};
use scale_info::TypeInfo;
use smallvec::Array;
use sp_runtime::traits::{Convert, Hash, Saturating, StaticLookup};
use sp_std::{fmt::Debug, marker::PhantomData, prelude::*};
pub use crate::{
    address::{AddressGenerator, DefaultAddressGenerator},
    exec::Frame,
    migration::Migration,
    pallet::*,
    schedule::{HostFnWeights, InstructionWeights, Limits, Schedule},
    wasm::Determinism,
};
type CodeHash<T> = <T as frame_system::Config>::Hash;
type TrieId = BoundedVec<u8, ConstU32<128>>;
type BalanceOf<T> =
    <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;
type CodeVec<T> = BoundedVec<u8, <T as Config>::MaxCodeLen>;
type RelaxedCodeVec<T> = WeakBoundedVec<u8, <T as Config>::MaxCodeLen>;
type AccountIdLookupOf<T> = <<T as frame_system::Config>::Lookup as StaticLookup>::Source;
type DebugBufferVec<T> = BoundedVec<u8, <T as Config>::MaxDebugBufferLen>;
type EventRecordOf<T> =
    EventRecord<<T as frame_system::Config>::RuntimeEvent, <T as frame_system::Config>::Hash>;
/// The old weight type.
///
/// This is a copy of the [`frame_support::weights::OldWeight`] type since the contracts pallet
/// needs to support it indefinitely.
type OldWeight = u64;
/// Used as a sentinel value when reading and writing contract memory.
///
/// It is usually used to signal `None` to a contract when only a primitive is allowed
/// and we don't want to go through encoding a full Rust type. Using `u32::Max` is a safe
/// sentinel because contracts are never allowed to use such a large amount of resources
/// that this value makes sense for a memory location or length.
const SENTINEL: u32 = u32::MAX;
/// The target that is used for the log output emitted by this crate.
///
/// Hence you can use this target to selectively increase the log level for this crate.
///
/// Example: `RUST_LOG=runtime::contracts=debug my_code --dev`
const LOG_TARGET: &str = "runtime::contracts";
///
///			The module that hosts all the
///			[FRAME](https://docs.substrate.io/main-docs/build/events-errors/)
///			types needed to add this pallet to a
///			runtime.
///
pub mod pallet {
    use super::*;
    use frame_support::pallet_prelude::*;
    use frame_system::pallet_prelude::*;
    /// The current storage version.
    const STORAGE_VERSION: StorageVersion = StorageVersion::new(9);
    ///
    ///			The [pallet](https://docs.substrate.io/reference/frame-pallets/#pallets) implementing
    ///			the on-chain logic.
    ///
    pub struct Pallet<T>(PhantomData<T>);
    const _: () = {
        impl<T> core::clone::Clone for Pallet<T> {
            fn clone(&self) -> Self {
                Self(core::clone::Clone::clone(&self.0))
            }
        }
    };
    const _: () = {
        impl<T> core::cmp::Eq for Pallet<T> {}
    };
    const _: () = {
        impl<T> core::cmp::PartialEq for Pallet<T> {
            fn eq(&self, other: &Self) -> bool {
                true && self.0 == other.0
            }
        }
    };
    const _: () = {
        impl<T> core::fmt::Debug for Pallet<T> {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                fmt.debug_tuple("Pallet").field(&self.0).finish()
            }
        }
    };
    ///
    ///			Configuration trait of this pallet.
    ///
    ///			Implement this type for a runtime in order to customize this pallet.
    ///
    pub trait Config: frame_system::Config {
        /// The time implementation used to supply timestamps to contracts through `seal_now`.
        type Time: Time;
        /// The generator used to supply randomness to contracts through `seal_random`.
        ///
        /// # Deprecated
        ///
        /// Codes using the randomness functionality cannot be uploaded. Neither can contracts
        /// be instantiated from existing codes that use this deprecated functionality. It will
        /// be removed eventually. Hence for new `pallet-contracts` deployments it is okay
        /// to supply a dummy implementation for this type (because it is never used).
        type Randomness: Randomness<Self::Hash, Self::BlockNumber>;
        /// The currency in which fees are paid and contract balances are held.
        type Currency: ReservableCurrency<Self::AccountId>
            + Inspect<Self::AccountId, Balance = BalanceOf<Self>>;
        /// The overarching event type.
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
        /// The overarching call type.
        type RuntimeCall: Dispatchable<RuntimeOrigin = Self::RuntimeOrigin, PostInfo = PostDispatchInfo>
            + GetDispatchInfo
            + codec::Decode
            + IsType<<Self as frame_system::Config>::RuntimeCall>;
        /// Filter that is applied to calls dispatched by contracts.
        ///
        /// Use this filter to control which dispatchables are callable by contracts.
        /// This is applied in **addition** to [`frame_system::Config::BaseCallFilter`].
        /// It is recommended to treat this as a whitelist.
        ///
        /// # Stability
        ///
        /// The runtime **must** make sure that all dispatchables that are callable by
        /// contracts remain stable. In addition [`Self::RuntimeCall`] itself must remain stable.
        /// This means that no existing variants are allowed to switch their positions.
        ///
        /// # Note
        ///
        /// Note that dispatchables that are called via contracts do not spawn their
        /// own wasm instance for each call (as opposed to when called via a transaction).
        /// Therefore please make sure to be restrictive about which dispatchables are allowed
        /// in order to not introduce a new DoS vector like memory allocation patterns that can
        /// be exploited to drive the runtime into a panic.
        type CallFilter: Contains<<Self as frame_system::Config>::RuntimeCall>;
        /// Used to answer contracts' queries regarding the current weight price. This is **not**
        /// used to calculate the actual fee and is only for informational purposes.
        type WeightPrice: Convert<Weight, BalanceOf<Self>>;
        /// Describes the weights of the dispatchables of this module and is also used to
        /// construct a default cost schedule.
        type WeightInfo: WeightInfo;
        /// Type that allows the runtime authors to add new host functions for a contract to call.
        type ChainExtension: chain_extension::ChainExtension<Self> + Default;
        /// Cost schedule and limits.
        type Schedule: Get<Schedule<Self>>;
        /// The type of the call stack determines the maximum nesting depth of contract calls.
        ///
        /// The allowed depth is `CallStack::size() + 1`.
        /// Therefore a size of `0` means that a contract cannot use call or instantiate.
        /// In other words only the origin called "root contract" is allowed to execute then.
        ///
        /// This setting along with [`MaxCodeLen`](#associatedtype.MaxCodeLen) directly affects
        /// memory usage of your runtime.
        type CallStack: Array<Item = Frame<Self>>;
        /// The amount of balance a caller has to pay for each byte of storage.
        ///
        /// # Note
        ///
        /// Changing this value for an existing chain might need a storage migration.
        type DepositPerByte: Get<BalanceOf<Self>>;
        /// Fallback value to limit the storage deposit if it's not being set by the caller.
        type DefaultDepositLimit: Get<BalanceOf<Self>>;
        /// The amount of balance a caller has to pay for each storage item.
        ///
        /// # Note
        ///
        /// Changing this value for an existing chain might need a storage migration.
        type DepositPerItem: Get<BalanceOf<Self>>;
        /// The address generator used to generate the addresses of contracts.
        type AddressGenerator: AddressGenerator<Self>;
        /// The maximum length of a contract code in bytes. This limit applies to the instrumented
        /// version of the code. Therefore `instantiate_with_code` can fail even when supplying
        /// a wasm binary below this maximum size.
        ///
        /// The value should be chosen carefully taking into the account the overall memory limit
        /// your runtime has, as well as the [maximum allowed callstack
        /// depth](#associatedtype.CallStack). Look into the `integrity_test()` for some insights.
        type MaxCodeLen: Get<u32>;
        /// The maximum allowable length in bytes for storage keys.
        type MaxStorageKeyLen: Get<u32>;
        /// Make contract callable functions marked as `#[unstable]` available.
        ///
        /// Contracts that use `#[unstable]` functions won't be able to be uploaded unless
        /// this is set to `true`. This is only meant for testnets and dev nodes in order to
        /// experiment with new features.
        ///
        /// # Warning
        ///
        /// Do **not** set to `true` on productions chains.
        type UnsafeUnstableInterface: Get<bool>;
        /// The maximum length of the debug buffer in bytes.
        type MaxDebugBufferLen: Get<u32>;
    }
    impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        fn on_idle(_block: T::BlockNumber, remaining_weight: Weight) -> Weight {
            ContractInfo::<T>::process_deletion_queue_batch(remaining_weight)
                .saturating_add(T::WeightInfo::on_process_deletion_queue_batch())
        }
        fn integrity_test() {
            let max_runtime_mem: u32 = T::Schedule::get().limits.runtime_memory;
            const MAX_STACK_SIZE: u32 = 1024 * 1024;
            let max_heap_size = T::Schedule::get().limits.max_memory_size();
            let max_call_depth = u32::try_from(T::CallStack::size().saturating_add(1))
                .expect("CallStack size is too big");
            let code_len_limit = max_runtime_mem
                .saturating_div(2)
                .saturating_div(max_call_depth)
                .saturating_sub(max_heap_size)
                .saturating_sub(MAX_STACK_SIZE)
                .saturating_div(18 * 4);
            if !(T::MaxCodeLen::get() < code_len_limit) {
                :: core :: panicking :: panic_fmt (format_args ! ("Given `CallStack` height {0:?}, `MaxCodeLen` should be set less than {1:?} (current value is {2:?}), to avoid possible runtime oom issues." , max_call_depth , code_len_limit , T :: MaxCodeLen :: get ()))
            };
            const MIN_DEBUG_BUF_SIZE: u32 = 256;
            if !(T::MaxDebugBufferLen::get() > MIN_DEBUG_BUF_SIZE) {
                ::core::panicking::panic_fmt(format_args!(
                    "Debug buffer should have minimum size of {0} (current setting is {1})",
                    MIN_DEBUG_BUF_SIZE,
                    T::MaxDebugBufferLen::get()
                ))
            }
        }
    }
    impl<T: Config> Pallet<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        /// Deprecated version if [`Self::call`] for use in an in-storage `Call`.
        #[allow(deprecated)]
        #[deprecated(note = "1D weight is used in this extrinsic, please migrate to `call`")]
        pub fn call_old_weight(
            origin: OriginFor<T>,
            dest: AccountIdLookupOf<T>,
            value: BalanceOf<T>,
            gas_limit: OldWeight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            data: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                Self::call(
                    origin,
                    dest,
                    value,
                    <Pallet<T>>::compat_weight_limit(gas_limit),
                    storage_deposit_limit,
                    data,
                )
            })
        }
        /// Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
        #[allow(deprecated)]
        #[deprecated(
            note = "1D weight is used in this extrinsic, please migrate to `instantiate_with_code`"
        )]
        pub fn instantiate_with_code_old_weight(
            origin: OriginFor<T>,
            value: BalanceOf<T>,
            gas_limit: OldWeight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code: Vec<u8>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                Self::instantiate_with_code(
                    origin,
                    value,
                    <Pallet<T>>::compat_weight_limit(gas_limit),
                    storage_deposit_limit,
                    code,
                    data,
                    salt,
                )
            })
        }
        /// Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
        #[allow(deprecated)]
        #[deprecated(note = "1D weight is used in this extrinsic, please migrate to `instantiate`")]
        pub fn instantiate_old_weight(
            origin: OriginFor<T>,
            value: BalanceOf<T>,
            gas_limit: OldWeight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code_hash: CodeHash<T>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                Self::instantiate(
                    origin,
                    value,
                    <Pallet<T>>::compat_weight_limit(gas_limit),
                    storage_deposit_limit,
                    code_hash,
                    data,
                    salt,
                )
            })
        }
        /// Upload new `code` without instantiating a contract from it.
        ///
        /// If the code does not already exist a deposit is reserved from the caller
        /// and unreserved only when [`Self::remove_code`] is called. The size of the reserve
        /// depends on the instrumented size of the the supplied `code`.
        ///
        /// If the code already exists in storage it will still return `Ok` and upgrades
        /// the in storage version to the current
        /// [`InstructionWeights::version`](InstructionWeights).
        ///
        /// - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
        ///   the only way to use this code is to delegate call into it from an offchain execution.
        ///   Set to [`Determinism::Enforced`] if in doubt.
        ///
        /// # Note
        ///
        /// Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
        /// To avoid this situation a constructor could employ access control so that it can
        /// only be instantiated by permissioned entities. The same is true when uploading
        /// through [`Self::instantiate_with_code`].
        pub fn upload_code(
            origin: OriginFor<T>,
            code: Vec<u8>,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            determinism: Determinism,
        ) -> DispatchResult {
            frame_support::storage::with_storage_layer(|| {
                let origin = ensure_signed(origin)?;
                Self::bare_upload_code(
                    origin,
                    code,
                    storage_deposit_limit.map(Into::into),
                    determinism,
                )
                .map(|_| ())
            })
        }
        /// Remove the code stored under `code_hash` and refund the deposit to its owner.
        ///
        /// A code can only be removed by its original uploader (its owner) and only if it is
        /// not used by any contract.
        pub fn remove_code(
            origin: OriginFor<T>,
            code_hash: CodeHash<T>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                let origin = ensure_signed(origin)?;
                <PrefabWasmModule<T>>::remove(&origin, code_hash)?;
                Ok(Pays::No.into())
            })
        }
        /// Privileged function that changes the code of an existing contract.
        ///
        /// This takes care of updating refcounts and all other necessary operations. Returns
        /// an error if either the `code_hash` or `dest` do not exist.
        ///
        /// # Note
        ///
        /// This does **not** change the address of the contract in question. This means
        /// that the contract address is no longer derived from its code hash after calling
        /// this dispatchable.
        pub fn set_code(
            origin: OriginFor<T>,
            dest: AccountIdLookupOf<T>,
            code_hash: CodeHash<T>,
        ) -> DispatchResult {
            frame_support::storage::with_storage_layer(|| {
                ensure_root(origin)?;
                let dest = T::Lookup::lookup(dest)?;
                <ContractInfoOf<T>>::try_mutate(&dest, |contract| {
                    let contract = if let Some(contract) = contract {
                        contract
                    } else {
                        return Err(<Error<T>>::ContractNotFound.into());
                    };
                    <PrefabWasmModule<T>>::add_user(code_hash)?;
                    <PrefabWasmModule<T>>::remove_user(contract.code_hash);
                    Self::deposit_event(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                T::Hashing::hash_of(&dest),
                                code_hash,
                                contract.code_hash,
                            ]),
                        ),
                        Event::ContractCodeUpdated {
                            contract: dest.clone(),
                            new_code_hash: code_hash,
                            old_code_hash: contract.code_hash,
                        },
                    );
                    contract.code_hash = code_hash;
                    Ok(())
                })
            })
        }
        /// Makes a call to an account, optionally transferring some balance.
        ///
        /// # Parameters
        ///
        /// * `dest`: Address of the contract to call.
        /// * `value`: The balance to transfer from the `origin` to `dest`.
        /// * `gas_limit`: The gas limit enforced when executing the constructor.
        /// * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
        ///   caller to pay for the storage consumed.
        /// * `data`: The input data to pass to the contract.
        ///
        /// * If the account is a smart-contract account, the associated code will be
        /// executed and any value will be transferred.
        /// * If the account is a regular account, any value will be transferred.
        /// * If no account exists and the call value is not less than `existential_deposit`,
        /// a regular account will be created and any value will be transferred.
        pub fn call(
            origin: OriginFor<T>,
            dest: AccountIdLookupOf<T>,
            value: BalanceOf<T>,
            gas_limit: Weight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            data: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                let common = CommonInput {
                    origin: Origin::from_runtime_origin(origin)?,
                    value,
                    data,
                    gas_limit: gas_limit.into(),
                    storage_deposit_limit: storage_deposit_limit.map(Into::into),
                    debug_message: None,
                };
                let dest = T::Lookup::lookup(dest)?;
                let mut output = CallInput::<T> {
                    dest,
                    determinism: Determinism::Enforced,
                }
                .run_guarded(common);
                if let Ok(retval) = &output.result {
                    if retval.did_revert() {
                        output.result = Err(<Error<T>>::ContractReverted.into());
                    }
                }
                output
                    .gas_meter
                    .into_dispatch_result(output.result, T::WeightInfo::call())
            })
        }
        /// Instantiates a new contract from the supplied `code` optionally transferring
        /// some balance.
        ///
        /// This dispatchable has the same effect as calling [`Self::upload_code`] +
        /// [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
        /// also check the documentation of [`Self::upload_code`].
        ///
        /// # Parameters
        ///
        /// * `value`: The balance to transfer from the `origin` to the newly created contract.
        /// * `gas_limit`: The gas limit enforced when executing the constructor.
        /// * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
        ///   from the caller to pay for the storage consumed.
        /// * `code`: The contract code to deploy in raw bytes.
        /// * `data`: The input data to pass to the contract constructor.
        /// * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
        ///
        /// Instantiation is executed as follows:
        ///
        /// - The supplied `code` is instrumented, deployed, and a `code_hash` is created for that
        ///   code.
        /// - If the `code_hash` already exists on the chain the underlying `code` will be shared.
        /// - The destination address is computed based on the sender, code_hash and the salt.
        /// - The smart-contract account is created at the computed address.
        /// - The `value` is transferred to the new account.
        /// - The `deploy` function is executed in the context of the newly-created account.
        pub fn instantiate_with_code(
            origin: OriginFor<T>,
            value: BalanceOf<T>,
            gas_limit: Weight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code: Vec<u8>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                let code_len = code.len() as u32;
                let data_len = data.len() as u32;
                let salt_len = salt.len() as u32;
                let common = CommonInput {
                    origin: Origin::from_runtime_origin(origin)?,
                    value,
                    data,
                    gas_limit,
                    storage_deposit_limit: storage_deposit_limit.map(Into::into),
                    debug_message: None,
                };
                let mut output = InstantiateInput::<T> {
                    code: Code::Upload(code),
                    salt,
                }
                .run_guarded(common);
                if let Ok(retval) = &output.result {
                    if retval.1.did_revert() {
                        output.result = Err(<Error<T>>::ContractReverted.into());
                    }
                }
                output.gas_meter.into_dispatch_result(
                    output.result.map(|(_address, result)| result),
                    T::WeightInfo::instantiate_with_code(code_len, data_len, salt_len),
                )
            })
        }
        /// Instantiates a contract from a previously deployed wasm binary.
        ///
        /// This function is identical to [`Self::instantiate_with_code`] but without the
        /// code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
        /// must be supplied.
        pub fn instantiate(
            origin: OriginFor<T>,
            value: BalanceOf<T>,
            gas_limit: Weight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code_hash: CodeHash<T>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(|| {
                let data_len = data.len() as u32;
                let salt_len = salt.len() as u32;
                let common = CommonInput {
                    origin: Origin::from_runtime_origin(origin)?,
                    value,
                    data,
                    gas_limit,
                    storage_deposit_limit: storage_deposit_limit.map(Into::into),
                    debug_message: None,
                };
                let mut output = InstantiateInput::<T> {
                    code: Code::Existing(code_hash),
                    salt,
                }
                .run_guarded(common);
                if let Ok(retval) = &output.result {
                    if retval.1.did_revert() {
                        output.result = Err(<Error<T>>::ContractReverted.into());
                    }
                }
                output.gas_meter.into_dispatch_result(
                    output.result.map(|(_address, output)| output),
                    T::WeightInfo::instantiate(data_len, salt_len),
                )
            })
        }
    }
    ///
    ///			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
    ///			by this pallet.
    ///
    #[scale_info(skip_type_params(T), capture_docs = "always")]
    pub enum Event<T: Config> {
        /// Contract deployed by address at the specified address.
        Instantiated {
            deployer: T::AccountId,
            contract: T::AccountId,
        },
        /// Contract has been removed.
        ///
        /// # Note
        ///
        /// The only way for a contract to be removed and emitting this event is by calling
        /// `seal_terminate`.
        Terminated {
            /// The contract that was terminated.
            contract: T::AccountId,
            /// The account that received the contracts remaining balance
            beneficiary: T::AccountId,
        },
        /// Code with the specified hash has been stored.
        CodeStored { code_hash: T::Hash },
        /// A custom event emitted by the contract.
        ContractEmitted {
            /// The contract that emitted the event.
            contract: T::AccountId,
            /// Data supplied by the contract. Metadata generated during contract compilation
            /// is needed to decode it.
            data: Vec<u8>,
        },
        /// A code with the specified hash was removed.
        CodeRemoved { code_hash: T::Hash },
        /// A contract's code was updated.
        ContractCodeUpdated {
            /// The contract that has been updated.
            contract: T::AccountId,
            /// New code hash that was set for the contract.
            new_code_hash: T::Hash,
            /// Previous code hash of the contract.
            old_code_hash: T::Hash,
        },
        /// A contract was called either by a plain account or another contract.
        ///
        /// # Note
        ///
        /// Please keep in mind that like all events this is only emitted for successful
        /// calls. This is because on failure all storage changes including events are
        /// rolled back.
        Called {
            /// The caller of the `contract`.
            caller: Origin<T>,
            /// The contract that was called.
            contract: T::AccountId,
        },
        /// A contract delegate called a code hash.
        ///
        /// # Note
        ///
        /// Please keep in mind that like all events this is only emitted for successful
        /// calls. This is because on failure all storage changes including events are
        /// rolled back.
        DelegateCalled {
            /// The contract that performed the delegate call and hence in whose context
            /// the `code_hash` is executed.
            contract: T::AccountId,
            /// The code hash that was delegate called.
            code_hash: CodeHash<T>,
        },
        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(
            frame_support::sp_std::marker::PhantomData<(T)>,
            frame_support::Never,
        ),
    }
    const _: () = {
        impl<T: Config> core::clone::Clone for Event<T> {
            fn clone(&self) -> Self {
                match self {
                    Self::Instantiated {
                        ref deployer,
                        ref contract,
                    } => Self::Instantiated {
                        deployer: core::clone::Clone::clone(deployer),
                        contract: core::clone::Clone::clone(contract),
                    },
                    Self::Terminated {
                        ref contract,
                        ref beneficiary,
                    } => Self::Terminated {
                        contract: core::clone::Clone::clone(contract),
                        beneficiary: core::clone::Clone::clone(beneficiary),
                    },
                    Self::CodeStored { ref code_hash } => Self::CodeStored {
                        code_hash: core::clone::Clone::clone(code_hash),
                    },
                    Self::ContractEmitted {
                        ref contract,
                        ref data,
                    } => Self::ContractEmitted {
                        contract: core::clone::Clone::clone(contract),
                        data: core::clone::Clone::clone(data),
                    },
                    Self::CodeRemoved { ref code_hash } => Self::CodeRemoved {
                        code_hash: core::clone::Clone::clone(code_hash),
                    },
                    Self::ContractCodeUpdated {
                        ref contract,
                        ref new_code_hash,
                        ref old_code_hash,
                    } => Self::ContractCodeUpdated {
                        contract: core::clone::Clone::clone(contract),
                        new_code_hash: core::clone::Clone::clone(new_code_hash),
                        old_code_hash: core::clone::Clone::clone(old_code_hash),
                    },
                    Self::Called {
                        ref caller,
                        ref contract,
                    } => Self::Called {
                        caller: core::clone::Clone::clone(caller),
                        contract: core::clone::Clone::clone(contract),
                    },
                    Self::DelegateCalled {
                        ref contract,
                        ref code_hash,
                    } => Self::DelegateCalled {
                        contract: core::clone::Clone::clone(contract),
                        code_hash: core::clone::Clone::clone(code_hash),
                    },
                    Self::__Ignore(ref _0, ref _1) => {
                        Self::__Ignore(core::clone::Clone::clone(_0), core::clone::Clone::clone(_1))
                    }
                }
            }
        }
    };
    const _: () = {
        impl<T: Config> core::cmp::Eq for Event<T> {}
    };
    const _: () = {
        impl<T: Config> core::cmp::PartialEq for Event<T> {
            fn eq(&self, other: &Self) -> bool {
                match (self, other) {
                    (
                        Self::Instantiated { deployer, contract },
                        Self::Instantiated {
                            deployer: _0,
                            contract: _1,
                        },
                    ) => true && deployer == _0 && contract == _1,
                    (
                        Self::Terminated {
                            contract,
                            beneficiary,
                        },
                        Self::Terminated {
                            contract: _0,
                            beneficiary: _1,
                        },
                    ) => true && contract == _0 && beneficiary == _1,
                    (Self::CodeStored { code_hash }, Self::CodeStored { code_hash: _0 }) => {
                        true && code_hash == _0
                    }
                    (
                        Self::ContractEmitted { contract, data },
                        Self::ContractEmitted {
                            contract: _0,
                            data: _1,
                        },
                    ) => true && contract == _0 && data == _1,
                    (Self::CodeRemoved { code_hash }, Self::CodeRemoved { code_hash: _0 }) => {
                        true && code_hash == _0
                    }
                    (
                        Self::ContractCodeUpdated {
                            contract,
                            new_code_hash,
                            old_code_hash,
                        },
                        Self::ContractCodeUpdated {
                            contract: _0,
                            new_code_hash: _1,
                            old_code_hash: _2,
                        },
                    ) => true && contract == _0 && new_code_hash == _1 && old_code_hash == _2,
                    (
                        Self::Called { caller, contract },
                        Self::Called {
                            caller: _0,
                            contract: _1,
                        },
                    ) => true && caller == _0 && contract == _1,
                    (
                        Self::DelegateCalled {
                            contract,
                            code_hash,
                        },
                        Self::DelegateCalled {
                            contract: _0,
                            code_hash: _1,
                        },
                    ) => true && contract == _0 && code_hash == _1,
                    (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other)) => {
                        true && _0 == _0_other && _1 == _1_other
                    }
                    (Self::Instantiated { .. }, Self::Terminated { .. }) => false,
                    (Self::Instantiated { .. }, Self::CodeStored { .. }) => false,
                    (Self::Instantiated { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::Instantiated { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::Instantiated { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::Instantiated { .. }, Self::Called { .. }) => false,
                    (Self::Instantiated { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::Instantiated { .. }, Self::__Ignore { .. }) => false,
                    (Self::Terminated { .. }, Self::Instantiated { .. }) => false,
                    (Self::Terminated { .. }, Self::CodeStored { .. }) => false,
                    (Self::Terminated { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::Terminated { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::Terminated { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::Terminated { .. }, Self::Called { .. }) => false,
                    (Self::Terminated { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::Terminated { .. }, Self::__Ignore { .. }) => false,
                    (Self::CodeStored { .. }, Self::Instantiated { .. }) => false,
                    (Self::CodeStored { .. }, Self::Terminated { .. }) => false,
                    (Self::CodeStored { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::CodeStored { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::CodeStored { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::CodeStored { .. }, Self::Called { .. }) => false,
                    (Self::CodeStored { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::CodeStored { .. }, Self::__Ignore { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::Instantiated { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::Terminated { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::CodeStored { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::Called { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::ContractEmitted { .. }, Self::__Ignore { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::Instantiated { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::Terminated { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::CodeStored { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::Called { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::CodeRemoved { .. }, Self::__Ignore { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::Instantiated { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::Terminated { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::CodeStored { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::Called { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::ContractCodeUpdated { .. }, Self::__Ignore { .. }) => false,
                    (Self::Called { .. }, Self::Instantiated { .. }) => false,
                    (Self::Called { .. }, Self::Terminated { .. }) => false,
                    (Self::Called { .. }, Self::CodeStored { .. }) => false,
                    (Self::Called { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::Called { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::Called { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::Called { .. }, Self::DelegateCalled { .. }) => false,
                    (Self::Called { .. }, Self::__Ignore { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::Instantiated { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::Terminated { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::CodeStored { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::Called { .. }) => false,
                    (Self::DelegateCalled { .. }, Self::__Ignore { .. }) => false,
                    (Self::__Ignore { .. }, Self::Instantiated { .. }) => false,
                    (Self::__Ignore { .. }, Self::Terminated { .. }) => false,
                    (Self::__Ignore { .. }, Self::CodeStored { .. }) => false,
                    (Self::__Ignore { .. }, Self::ContractEmitted { .. }) => false,
                    (Self::__Ignore { .. }, Self::CodeRemoved { .. }) => false,
                    (Self::__Ignore { .. }, Self::ContractCodeUpdated { .. }) => false,
                    (Self::__Ignore { .. }, Self::Called { .. }) => false,
                    (Self::__Ignore { .. }, Self::DelegateCalled { .. }) => false,
                }
            }
        }
    };
    const _: () = {
        impl<T: Config> core::fmt::Debug for Event<T> {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                match *self {
                    Self::Instantiated {
                        ref deployer,
                        ref contract,
                    } => fmt
                        .debug_struct("Event::Instantiated")
                        .field("deployer", &deployer)
                        .field("contract", &contract)
                        .finish(),
                    Self::Terminated {
                        ref contract,
                        ref beneficiary,
                    } => fmt
                        .debug_struct("Event::Terminated")
                        .field("contract", &contract)
                        .field("beneficiary", &beneficiary)
                        .finish(),
                    Self::CodeStored { ref code_hash } => fmt
                        .debug_struct("Event::CodeStored")
                        .field("code_hash", &code_hash)
                        .finish(),
                    Self::ContractEmitted {
                        ref contract,
                        ref data,
                    } => fmt
                        .debug_struct("Event::ContractEmitted")
                        .field("contract", &contract)
                        .field("data", &data)
                        .finish(),
                    Self::CodeRemoved { ref code_hash } => fmt
                        .debug_struct("Event::CodeRemoved")
                        .field("code_hash", &code_hash)
                        .finish(),
                    Self::ContractCodeUpdated {
                        ref contract,
                        ref new_code_hash,
                        ref old_code_hash,
                    } => fmt
                        .debug_struct("Event::ContractCodeUpdated")
                        .field("contract", &contract)
                        .field("new_code_hash", &new_code_hash)
                        .field("old_code_hash", &old_code_hash)
                        .finish(),
                    Self::Called {
                        ref caller,
                        ref contract,
                    } => fmt
                        .debug_struct("Event::Called")
                        .field("caller", &caller)
                        .field("contract", &contract)
                        .finish(),
                    Self::DelegateCalled {
                        ref contract,
                        ref code_hash,
                    } => fmt
                        .debug_struct("Event::DelegateCalled")
                        .field("contract", &contract)
                        .field("code_hash", &code_hash)
                        .finish(),
                    Self::__Ignore(ref _0, ref _1) => fmt
                        .debug_tuple("Event::__Ignore")
                        .field(&_0)
                        .field(&_1)
                        .finish(),
                }
            }
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for Event<T>
        where
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            Origin<T>: ::codec::Encode,
            Origin<T>: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Event::Instantiated {
                        ref deployer,
                        ref contract,
                    } => {
                        __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(deployer, __codec_dest_edqy);
                        ::codec::Encode::encode_to(contract, __codec_dest_edqy);
                    }
                    Event::Terminated {
                        ref contract,
                        ref beneficiary,
                    } => {
                        __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(contract, __codec_dest_edqy);
                        ::codec::Encode::encode_to(beneficiary, __codec_dest_edqy);
                    }
                    Event::CodeStored { ref code_hash } => {
                        __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                    }
                    Event::ContractEmitted {
                        ref contract,
                        ref data,
                    } => {
                        __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(contract, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                    }
                    Event::CodeRemoved { ref code_hash } => {
                        __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                    }
                    Event::ContractCodeUpdated {
                        ref contract,
                        ref new_code_hash,
                        ref old_code_hash,
                    } => {
                        __codec_dest_edqy.push_byte(5usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(contract, __codec_dest_edqy);
                        ::codec::Encode::encode_to(new_code_hash, __codec_dest_edqy);
                        ::codec::Encode::encode_to(old_code_hash, __codec_dest_edqy);
                    }
                    Event::Called {
                        ref caller,
                        ref contract,
                    } => {
                        __codec_dest_edqy.push_byte(6usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(caller, __codec_dest_edqy);
                        ::codec::Encode::encode_to(contract, __codec_dest_edqy);
                    }
                    Event::DelegateCalled {
                        ref contract,
                        ref code_hash,
                    } => {
                        __codec_dest_edqy.push_byte(7usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(contract, __codec_dest_edqy);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for Event<T>
        where
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            T::Hash: ::codec::Encode,
            Origin<T>: ::codec::Encode,
            Origin<T>: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            T::AccountId: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
            CodeHash<T>: ::codec::Encode,
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for Event<T>
        where
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::Hash: ::codec::Decode,
            T::Hash: ::codec::Decode,
            Origin<T>: ::codec::Decode,
            Origin<T>: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            T::AccountId: ::codec::Decode,
            CodeHash<T>: ::codec::Decode,
            CodeHash<T>: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| e.chain("Could not decode `Event`, failed to read variant byte"))?
                {
                    __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::Instantiated {
                            deployer: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::Instantiated::deployer`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            contract: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::Instantiated::contract`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::Terminated {
                            contract: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::Terminated::contract`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            beneficiary: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::Terminated::beneficiary`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 2usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::CodeStored {
                            code_hash: {
                                let __codec_res_edqy =
                                    <T::Hash as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::CodeStored::code_hash`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 3usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::ContractEmitted {
                            contract: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::ContractEmitted::contract`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::ContractEmitted::data`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 4usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::CodeRemoved {
                            code_hash: {
                                let __codec_res_edqy =
                                    <T::Hash as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::CodeRemoved::code_hash`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 5usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::ContractCodeUpdated {
                            contract: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Event::ContractCodeUpdated::contract`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            new_code_hash: {
                                let __codec_res_edqy =
                                    <T::Hash as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Event::ContractCodeUpdated::new_code_hash`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            old_code_hash: {
                                let __codec_res_edqy =
                                    <T::Hash as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Event::ContractCodeUpdated::old_code_hash`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 6usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::Called {
                            caller: {
                                let __codec_res_edqy =
                                    <Origin<T> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Event::Called::caller`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            contract: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Event::Called::contract`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 7usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Event::<T>::DelegateCalled {
                            contract: {
                                let __codec_res_edqy =
                                    <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::DelegateCalled::contract`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            code_hash: {
                                let __codec_res_edqy =
                                    <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Event::DelegateCalled::code_hash`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    _ => ::core::result::Result::Err(<_ as ::core::convert::Into<_>>::into(
                        "Could not decode `Event`, variant doesn't exist",
                    )),
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for Event<T>
        where
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::Hash: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::Hash: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::Hash: ::scale_info::TypeInfo + 'static,
            T::Hash: ::scale_info::TypeInfo + 'static,
            Origin<T>: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            T::AccountId: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            frame_support::sp_std::marker::PhantomData<(T)>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Event" , "pallet_contracts::pallet")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs_always (& ["\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]) . variant (:: scale_info :: build :: Variants :: new () . variant ("Instantiated" , | v | v . index (0usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: AccountId > () . name ("deployer") . type_name ("T::AccountId")) . field (| f | f . ty :: < T :: AccountId > () . name ("contract") . type_name ("T::AccountId"))) . docs_always (& ["Contract deployed by address at the specified address."])) . variant ("Terminated" , | v | v . index (1usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: AccountId > () . name ("contract") . type_name ("T::AccountId") . docs_always (& ["The contract that was terminated."])) . field (| f | f . ty :: < T :: AccountId > () . name ("beneficiary") . type_name ("T::AccountId") . docs_always (& ["The account that received the contracts remaining balance"]))) . docs_always (& ["Contract has been removed." , "" , "# Note" , "" , "The only way for a contract to be removed and emitting this event is by calling" , "`seal_terminate`."])) . variant ("CodeStored" , | v | v . index (2usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: Hash > () . name ("code_hash") . type_name ("T::Hash"))) . docs_always (& ["Code with the specified hash has been stored."])) . variant ("ContractEmitted" , | v | v . index (3usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: AccountId > () . name ("contract") . type_name ("T::AccountId") . docs_always (& ["The contract that emitted the event."])) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>") . docs_always (& ["Data supplied by the contract. Metadata generated during contract compilation" , "is needed to decode it."]))) . docs_always (& ["A custom event emitted by the contract."])) . variant ("CodeRemoved" , | v | v . index (4usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: Hash > () . name ("code_hash") . type_name ("T::Hash"))) . docs_always (& ["A code with the specified hash was removed."])) . variant ("ContractCodeUpdated" , | v | v . index (5usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: AccountId > () . name ("contract") . type_name ("T::AccountId") . docs_always (& ["The contract that has been updated."])) . field (| f | f . ty :: < T :: Hash > () . name ("new_code_hash") . type_name ("T::Hash") . docs_always (& ["New code hash that was set for the contract."])) . field (| f | f . ty :: < T :: Hash > () . name ("old_code_hash") . type_name ("T::Hash") . docs_always (& ["Previous code hash of the contract."]))) . docs_always (& ["A contract's code was updated."])) . variant ("Called" , | v | v . index (6usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < Origin < T > > () . name ("caller") . type_name ("Origin<T>") . docs_always (& ["The caller of the `contract`."])) . field (| f | f . ty :: < T :: AccountId > () . name ("contract") . type_name ("T::AccountId") . docs_always (& ["The contract that was called."]))) . docs_always (& ["A contract was called either by a plain account or another contract." , "" , "# Note" , "" , "Please keep in mind that like all events this is only emitted for successful" , "calls. This is because on failure all storage changes including events are" , "rolled back."])) . variant ("DelegateCalled" , | v | v . index (7usize as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < T :: AccountId > () . name ("contract") . type_name ("T::AccountId") . docs_always (& ["The contract that performed the delegate call and hence in whose context" , "the `code_hash` is executed."])) . field (| f | f . ty :: < CodeHash < T > > () . name ("code_hash") . type_name ("CodeHash<T>") . docs_always (& ["The code hash that was delegate called."]))) . docs_always (& ["A contract delegate called a code hash." , "" , "# Note" , "" , "Please keep in mind that like all events this is only emitted for successful" , "calls. This is because on failure all storage changes including events are" , "rolled back."])))
            }
        };
    };
    #[scale_info(skip_type_params(T), capture_docs = "always")]
    ///
    ///			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
    ///			of this pallet.
    ///
    pub enum Error<T> {
        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(
            frame_support::sp_std::marker::PhantomData<(T)>,
            frame_support::Never,
        ),
        /// A new schedule must have a greater version than the current one.
        InvalidScheduleVersion,
        /// Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
        InvalidCallFlags,
        /// The executed contract exhausted its gas limit.
        OutOfGas,
        /// The output buffer supplied to a contract API call was too small.
        OutputBufferTooSmall,
        /// Performing the requested transfer failed. Probably because there isn't enough
        /// free balance in the sender's account.
        TransferFailed,
        /// Performing a call was denied because the calling depth reached the limit
        /// of what is specified in the schedule.
        MaxCallDepthReached,
        /// No contract was found at the specified address.
        ContractNotFound,
        /// The code supplied to `instantiate_with_code` exceeds the limit specified in the
        /// current schedule.
        CodeTooLarge,
        /// No code could be found at the supplied code hash.
        CodeNotFound,
        /// A buffer outside of sandbox memory was passed to a contract API function.
        OutOfBounds,
        /// Input passed to a contract API function failed to decode as expected type.
        DecodingFailed,
        /// Contract trapped during execution.
        ContractTrapped,
        /// The size defined in `T::MaxValueSize` was exceeded.
        ValueTooLarge,
        /// Termination of a contract is not allowed while the contract is already
        /// on the call stack. Can be triggered by `seal_terminate`.
        TerminatedWhileReentrant,
        /// `seal_call` forwarded this contracts input. It therefore is no longer available.
        InputForwarded,
        /// The subject passed to `seal_random` exceeds the limit.
        RandomSubjectTooLong,
        /// The amount of topics passed to `seal_deposit_events` exceeds the limit.
        TooManyTopics,
        /// The chain does not provide a chain extension. Calling the chain extension results
        /// in this error. Note that this usually  shouldn't happen as deploying such contracts
        /// is rejected.
        NoChainExtension,
        /// A contract with the same AccountId already exists.
        DuplicateContract,
        /// A contract self destructed in its constructor.
        ///
        /// This can be triggered by a call to `seal_terminate`.
        TerminatedInConstructor,
        /// A call tried to invoke a contract that is flagged as non-reentrant.
        /// The only other cause is that a call from a contract into the runtime tried to call back
        /// into `pallet-contracts`. This would make the whole pallet reentrant with regard to
        /// contract code execution which is not supported.
        ReentranceDenied,
        /// Origin doesn't have enough balance to pay the required storage deposits.
        StorageDepositNotEnoughFunds,
        /// More storage was created than allowed by the storage deposit limit.
        StorageDepositLimitExhausted,
        /// Code removal was denied because the code is still in use by at least one contract.
        CodeInUse,
        /// The contract ran to completion but decided to revert its storage changes.
        /// Please note that this error is only returned from extrinsics. When called directly
        /// or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
        /// to determine whether a reversion has taken place.
        ContractReverted,
        /// The contract's code was found to be invalid during validation or instrumentation.
        ///
        /// The most likely cause of this is that an API was used which is not supported by the
        /// node. This happens if an older node is used with a new version of ink!. Try updating
        /// your node to the newest available version.
        ///
        /// A more detailed error can be found on the node console if debug messages are enabled
        /// by supplying `-lruntime::contracts=debug`.
        CodeRejected,
        /// An indetermistic code was used in a context where this is not permitted.
        Indeterministic,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T> ::codec::Encode for Error<T> {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Error::InvalidScheduleVersion => {
                        __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                    }
                    Error::InvalidCallFlags => {
                        __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    }
                    Error::OutOfGas => {
                        __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                    }
                    Error::OutputBufferTooSmall => {
                        __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                    }
                    Error::TransferFailed => {
                        __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                    }
                    Error::MaxCallDepthReached => {
                        __codec_dest_edqy.push_byte(5usize as ::core::primitive::u8);
                    }
                    Error::ContractNotFound => {
                        __codec_dest_edqy.push_byte(6usize as ::core::primitive::u8);
                    }
                    Error::CodeTooLarge => {
                        __codec_dest_edqy.push_byte(7usize as ::core::primitive::u8);
                    }
                    Error::CodeNotFound => {
                        __codec_dest_edqy.push_byte(8usize as ::core::primitive::u8);
                    }
                    Error::OutOfBounds => {
                        __codec_dest_edqy.push_byte(9usize as ::core::primitive::u8);
                    }
                    Error::DecodingFailed => {
                        __codec_dest_edqy.push_byte(10usize as ::core::primitive::u8);
                    }
                    Error::ContractTrapped => {
                        __codec_dest_edqy.push_byte(11usize as ::core::primitive::u8);
                    }
                    Error::ValueTooLarge => {
                        __codec_dest_edqy.push_byte(12usize as ::core::primitive::u8);
                    }
                    Error::TerminatedWhileReentrant => {
                        __codec_dest_edqy.push_byte(13usize as ::core::primitive::u8);
                    }
                    Error::InputForwarded => {
                        __codec_dest_edqy.push_byte(14usize as ::core::primitive::u8);
                    }
                    Error::RandomSubjectTooLong => {
                        __codec_dest_edqy.push_byte(15usize as ::core::primitive::u8);
                    }
                    Error::TooManyTopics => {
                        __codec_dest_edqy.push_byte(16usize as ::core::primitive::u8);
                    }
                    Error::NoChainExtension => {
                        __codec_dest_edqy.push_byte(17usize as ::core::primitive::u8);
                    }
                    Error::DuplicateContract => {
                        __codec_dest_edqy.push_byte(18usize as ::core::primitive::u8);
                    }
                    Error::TerminatedInConstructor => {
                        __codec_dest_edqy.push_byte(19usize as ::core::primitive::u8);
                    }
                    Error::ReentranceDenied => {
                        __codec_dest_edqy.push_byte(20usize as ::core::primitive::u8);
                    }
                    Error::StorageDepositNotEnoughFunds => {
                        __codec_dest_edqy.push_byte(21usize as ::core::primitive::u8);
                    }
                    Error::StorageDepositLimitExhausted => {
                        __codec_dest_edqy.push_byte(22usize as ::core::primitive::u8);
                    }
                    Error::CodeInUse => {
                        __codec_dest_edqy.push_byte(23usize as ::core::primitive::u8);
                    }
                    Error::ContractReverted => {
                        __codec_dest_edqy.push_byte(24usize as ::core::primitive::u8);
                    }
                    Error::CodeRejected => {
                        __codec_dest_edqy.push_byte(25usize as ::core::primitive::u8);
                    }
                    Error::Indeterministic => {
                        __codec_dest_edqy.push_byte(26usize as ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl<T> ::codec::EncodeLike for Error<T> {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T> ::codec::Decode for Error<T> {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| e.chain("Could not decode `Error`, failed to read variant byte"))?
                {
                    __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::InvalidScheduleVersion)
                    }
                    __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::InvalidCallFlags)
                    }
                    __codec_x_edqy if __codec_x_edqy == 2usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::OutOfGas)
                    }
                    __codec_x_edqy if __codec_x_edqy == 3usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::OutputBufferTooSmall)
                    }
                    __codec_x_edqy if __codec_x_edqy == 4usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::TransferFailed)
                    }
                    __codec_x_edqy if __codec_x_edqy == 5usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::MaxCallDepthReached)
                    }
                    __codec_x_edqy if __codec_x_edqy == 6usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::ContractNotFound)
                    }
                    __codec_x_edqy if __codec_x_edqy == 7usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::CodeTooLarge)
                    }
                    __codec_x_edqy if __codec_x_edqy == 8usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::CodeNotFound)
                    }
                    __codec_x_edqy if __codec_x_edqy == 9usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::OutOfBounds)
                    }
                    __codec_x_edqy if __codec_x_edqy == 10usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::DecodingFailed)
                    }
                    __codec_x_edqy if __codec_x_edqy == 11usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::ContractTrapped)
                    }
                    __codec_x_edqy if __codec_x_edqy == 12usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::ValueTooLarge)
                    }
                    __codec_x_edqy if __codec_x_edqy == 13usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::TerminatedWhileReentrant)
                    }
                    __codec_x_edqy if __codec_x_edqy == 14usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::InputForwarded)
                    }
                    __codec_x_edqy if __codec_x_edqy == 15usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::RandomSubjectTooLong)
                    }
                    __codec_x_edqy if __codec_x_edqy == 16usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::TooManyTopics)
                    }
                    __codec_x_edqy if __codec_x_edqy == 17usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::NoChainExtension)
                    }
                    __codec_x_edqy if __codec_x_edqy == 18usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::DuplicateContract)
                    }
                    __codec_x_edqy if __codec_x_edqy == 19usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::TerminatedInConstructor)
                    }
                    __codec_x_edqy if __codec_x_edqy == 20usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::ReentranceDenied)
                    }
                    __codec_x_edqy if __codec_x_edqy == 21usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::StorageDepositNotEnoughFunds)
                    }
                    __codec_x_edqy if __codec_x_edqy == 22usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::StorageDepositLimitExhausted)
                    }
                    __codec_x_edqy if __codec_x_edqy == 23usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::CodeInUse)
                    }
                    __codec_x_edqy if __codec_x_edqy == 24usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::ContractReverted)
                    }
                    __codec_x_edqy if __codec_x_edqy == 25usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::CodeRejected)
                    }
                    __codec_x_edqy if __codec_x_edqy == 26usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Error::<T>::Indeterministic)
                    }
                    _ => ::core::result::Result::Err(<_ as ::core::convert::Into<_>>::into(
                        "Could not decode `Error`, variant doesn't exist",
                    )),
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T> ::scale_info::TypeInfo for Error<T>
        where
            frame_support::sp_std::marker::PhantomData<(T)>: ::scale_info::TypeInfo + 'static,
            T: 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Error" , "pallet_contracts::pallet")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs_always (& ["\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]) . variant (:: scale_info :: build :: Variants :: new () . variant ("InvalidScheduleVersion" , | v | v . index (0usize as :: core :: primitive :: u8) . docs_always (& ["A new schedule must have a greater version than the current one."])) . variant ("InvalidCallFlags" , | v | v . index (1usize as :: core :: primitive :: u8) . docs_always (& ["Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`."])) . variant ("OutOfGas" , | v | v . index (2usize as :: core :: primitive :: u8) . docs_always (& ["The executed contract exhausted its gas limit."])) . variant ("OutputBufferTooSmall" , | v | v . index (3usize as :: core :: primitive :: u8) . docs_always (& ["The output buffer supplied to a contract API call was too small."])) . variant ("TransferFailed" , | v | v . index (4usize as :: core :: primitive :: u8) . docs_always (& ["Performing the requested transfer failed. Probably because there isn't enough" , "free balance in the sender's account."])) . variant ("MaxCallDepthReached" , | v | v . index (5usize as :: core :: primitive :: u8) . docs_always (& ["Performing a call was denied because the calling depth reached the limit" , "of what is specified in the schedule."])) . variant ("ContractNotFound" , | v | v . index (6usize as :: core :: primitive :: u8) . docs_always (& ["No contract was found at the specified address."])) . variant ("CodeTooLarge" , | v | v . index (7usize as :: core :: primitive :: u8) . docs_always (& ["The code supplied to `instantiate_with_code` exceeds the limit specified in the" , "current schedule."])) . variant ("CodeNotFound" , | v | v . index (8usize as :: core :: primitive :: u8) . docs_always (& ["No code could be found at the supplied code hash."])) . variant ("OutOfBounds" , | v | v . index (9usize as :: core :: primitive :: u8) . docs_always (& ["A buffer outside of sandbox memory was passed to a contract API function."])) . variant ("DecodingFailed" , | v | v . index (10usize as :: core :: primitive :: u8) . docs_always (& ["Input passed to a contract API function failed to decode as expected type."])) . variant ("ContractTrapped" , | v | v . index (11usize as :: core :: primitive :: u8) . docs_always (& ["Contract trapped during execution."])) . variant ("ValueTooLarge" , | v | v . index (12usize as :: core :: primitive :: u8) . docs_always (& ["The size defined in `T::MaxValueSize` was exceeded."])) . variant ("TerminatedWhileReentrant" , | v | v . index (13usize as :: core :: primitive :: u8) . docs_always (& ["Termination of a contract is not allowed while the contract is already" , "on the call stack. Can be triggered by `seal_terminate`."])) . variant ("InputForwarded" , | v | v . index (14usize as :: core :: primitive :: u8) . docs_always (& ["`seal_call` forwarded this contracts input. It therefore is no longer available."])) . variant ("RandomSubjectTooLong" , | v | v . index (15usize as :: core :: primitive :: u8) . docs_always (& ["The subject passed to `seal_random` exceeds the limit."])) . variant ("TooManyTopics" , | v | v . index (16usize as :: core :: primitive :: u8) . docs_always (& ["The amount of topics passed to `seal_deposit_events` exceeds the limit."])) . variant ("NoChainExtension" , | v | v . index (17usize as :: core :: primitive :: u8) . docs_always (& ["The chain does not provide a chain extension. Calling the chain extension results" , "in this error. Note that this usually  shouldn't happen as deploying such contracts" , "is rejected."])) . variant ("DuplicateContract" , | v | v . index (18usize as :: core :: primitive :: u8) . docs_always (& ["A contract with the same AccountId already exists."])) . variant ("TerminatedInConstructor" , | v | v . index (19usize as :: core :: primitive :: u8) . docs_always (& ["A contract self destructed in its constructor." , "" , "This can be triggered by a call to `seal_terminate`."])) . variant ("ReentranceDenied" , | v | v . index (20usize as :: core :: primitive :: u8) . docs_always (& ["A call tried to invoke a contract that is flagged as non-reentrant." , "The only other cause is that a call from a contract into the runtime tried to call back" , "into `pallet-contracts`. This would make the whole pallet reentrant with regard to" , "contract code execution which is not supported."])) . variant ("StorageDepositNotEnoughFunds" , | v | v . index (21usize as :: core :: primitive :: u8) . docs_always (& ["Origin doesn't have enough balance to pay the required storage deposits."])) . variant ("StorageDepositLimitExhausted" , | v | v . index (22usize as :: core :: primitive :: u8) . docs_always (& ["More storage was created than allowed by the storage deposit limit."])) . variant ("CodeInUse" , | v | v . index (23usize as :: core :: primitive :: u8) . docs_always (& ["Code removal was denied because the code is still in use by at least one contract."])) . variant ("ContractReverted" , | v | v . index (24usize as :: core :: primitive :: u8) . docs_always (& ["The contract ran to completion but decided to revert its storage changes." , "Please note that this error is only returned from extrinsics. When called directly" , "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags" , "to determine whether a reversion has taken place."])) . variant ("CodeRejected" , | v | v . index (25usize as :: core :: primitive :: u8) . docs_always (& ["The contract's code was found to be invalid during validation or instrumentation." , "" , "The most likely cause of this is that an API was used which is not supported by the" , "node. This happens if an older node is used with a new version of ink!. Try updating" , "your node to the newest available version." , "" , "A more detailed error can be found on the node console if debug messages are enabled" , "by supplying `-lruntime::contracts=debug`."])) . variant ("Indeterministic" , | v | v . index (26usize as :: core :: primitive :: u8) . docs_always (& ["An indetermistic code was used in a context where this is not permitted."])))
            }
        };
    };
    const _: () = {
        impl<T> frame_support::traits::PalletError for Error<T> {
            const MAX_ENCODED_SIZE: usize = 1;
        }
    };
    /// A mapping from an original code hash to the original code, untouched by instrumentation.
    #[allow(type_alias_bounds)]
    pub(crate) type PristineCode<T: Config> =
        StorageMap<_GeneratedPrefixForStoragePristineCode<T>, Identity, CodeHash<T>, CodeVec<T>>;
    /// A mapping between an original code hash and instrumented wasm code, ready for execution.
    #[allow(type_alias_bounds)]
    pub(crate) type CodeStorage<T: Config> = StorageMap<
        _GeneratedPrefixForStorageCodeStorage<T>,
        Identity,
        CodeHash<T>,
        PrefabWasmModule<T>,
    >;
    /// A mapping between an original code hash and its owner information.
    #[allow(type_alias_bounds)]
    pub(crate) type OwnerInfoOf<T: Config> =
        StorageMap<_GeneratedPrefixForStorageOwnerInfoOf<T>, Identity, CodeHash<T>, OwnerInfo<T>>;
    /// This is a **monotonic** counter incremented on contract instantiation.
    ///
    /// This is used in order to generate unique trie ids for contracts.
    /// The trie id of a new contract is calculated from hash(account_id, nonce).
    /// The nonce is required because otherwise the following sequence would lead to
    /// a possible collision of storage:
    ///
    /// 1. Create a new contract.
    /// 2. Terminate the contract.
    /// 3. Immediately recreate the contract with the same account_id.
    ///
    /// This is bad because the contents of a trie are deleted lazily and there might be
    /// storage of the old instantiation still in it when the new contract is created. Please
    /// note that we can't replace the counter by the block number because the sequence above
    /// can happen in the same block. We also can't keep the account counter in memory only
    /// because storage is the only way to communicate across different extrinsics in the
    /// same block.
    ///
    /// # Note
    ///
    /// Do not use it to determine the number of contracts. It won't be decremented if
    /// a contract is destroyed.
    #[allow(type_alias_bounds)]
    pub(crate) type Nonce<T: Config> =
        StorageValue<_GeneratedPrefixForStorageNonce<T>, u64, ValueQuery>;
    /// The code associated with a given account.
    ///
    /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
    #[allow(type_alias_bounds)]
    pub(crate) type ContractInfoOf<T: Config> = StorageMap<
        _GeneratedPrefixForStorageContractInfoOf<T>,
        Twox64Concat,
        T::AccountId,
        ContractInfo<T>,
    >;
    /// Evicted contracts that await child trie deletion.
    ///
    /// Child trie deletion is a heavy operation depending on the amount of storage items
    /// stored in said trie. Therefore this operation is performed lazily in `on_idle`.
    #[allow(type_alias_bounds)]
    pub(crate) type DeletionQueue<T: Config> =
        StorageMap<_GeneratedPrefixForStorageDeletionQueue<T>, Twox64Concat, u32, TrieId>;
    /// A pair of monotonic counters used to track the latest contract marked for deletion
    /// and the latest deleted contract in queue.
    #[allow(type_alias_bounds)]
    pub(crate) type DeletionQueueCounter<T: Config> = StorageValue<
        _GeneratedPrefixForStorageDeletionQueueCounter<T>,
        DeletionQueueManager<T>,
        ValueQuery,
    >;
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn pallet_documentation_metadata() -> frame_support::sp_std::vec::Vec<&'static str> {
            ::alloc::vec::Vec::new()
        }
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn pallet_constants_metadata(
        ) -> frame_support::sp_std::vec::Vec<frame_support::metadata_ir::PalletConstantMetadataIR>
        {
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    {
                        frame_support::metadata_ir::PalletConstantMetadataIR {
                            name: "Schedule",
                            ty: frame_support::scale_info::meta_type::<Schedule<T>>(),
                            value: {
                                let value =
                                    <<T as Config>::Schedule as frame_support::traits::Get<
                                        Schedule<T>,
                                    >>::get();
                                frame_support::codec::Encode::encode(&value)
                            },
                            docs: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([" Cost schedule and limits."]),
                            ),
                        }
                    },
                    {
                        frame_support :: metadata_ir :: PalletConstantMetadataIR { name : "DepositPerByte" , ty : frame_support :: scale_info :: meta_type :: < BalanceOf < T > > () , value : { let value = < < T as Config > :: DepositPerByte as frame_support :: traits :: Get < BalanceOf < T > > > :: get () ; frame_support :: codec :: Encode :: encode (& value) } , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" The amount of balance a caller has to pay for each byte of storage." , "" , " # Note" , "" , " Changing this value for an existing chain might need a storage migration."])) , }
                    },
                    {
                        frame_support :: metadata_ir :: PalletConstantMetadataIR { name : "DefaultDepositLimit" , ty : frame_support :: scale_info :: meta_type :: < BalanceOf < T > > () , value : { let value = < < T as Config > :: DefaultDepositLimit as frame_support :: traits :: Get < BalanceOf < T > > > :: get () ; frame_support :: codec :: Encode :: encode (& value) } , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Fallback value to limit the storage deposit if it\'s not being set by the caller."])) , }
                    },
                    {
                        frame_support :: metadata_ir :: PalletConstantMetadataIR { name : "DepositPerItem" , ty : frame_support :: scale_info :: meta_type :: < BalanceOf < T > > () , value : { let value = < < T as Config > :: DepositPerItem as frame_support :: traits :: Get < BalanceOf < T > > > :: get () ; frame_support :: codec :: Encode :: encode (& value) } , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" The amount of balance a caller has to pay for each storage item." , "" , " # Note" , "" , " Changing this value for an existing chain might need a storage migration."])) , }
                    },
                    {
                        frame_support :: metadata_ir :: PalletConstantMetadataIR { name : "MaxCodeLen" , ty : frame_support :: scale_info :: meta_type :: < u32 > () , value : { let value = < < T as Config > :: MaxCodeLen as frame_support :: traits :: Get < u32 > > :: get () ; frame_support :: codec :: Encode :: encode (& value) } , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" The maximum length of a contract code in bytes. This limit applies to the instrumented" , " version of the code. Therefore `instantiate_with_code` can fail even when supplying" , " a wasm binary below this maximum size." , "" , " The value should be chosen carefully taking into the account the overall memory limit" , " your runtime has, as well as the [maximum allowed callstack" , " depth](#associatedtype.CallStack). Look into the `integrity_test()` for some insights."])) , }
                    },
                    {
                        frame_support::metadata_ir::PalletConstantMetadataIR {
                            name: "MaxStorageKeyLen",
                            ty: frame_support::scale_info::meta_type::<u32>(),
                            value: {
                                let value = < < T as Config > :: MaxStorageKeyLen as frame_support :: traits :: Get < u32 > > :: get () ;
                                frame_support::codec::Encode::encode(&value)
                            },
                            docs: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    " The maximum allowable length in bytes for storage keys.",
                                ]),
                            ),
                        }
                    },
                    {
                        frame_support :: metadata_ir :: PalletConstantMetadataIR { name : "UnsafeUnstableInterface" , ty : frame_support :: scale_info :: meta_type :: < bool > () , value : { let value = < < T as Config > :: UnsafeUnstableInterface as frame_support :: traits :: Get < bool > > :: get () ; frame_support :: codec :: Encode :: encode (& value) } , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Make contract callable functions marked as `#[unstable]` available." , "" , " Contracts that use `#[unstable]` functions won\'t be able to be uploaded unless" , " this is set to `true`. This is only meant for testnets and dev nodes in order to" , " experiment with new features." , "" , " # Warning" , "" , " Do **not** set to `true` on productions chains."])) , }
                    },
                    {
                        frame_support::metadata_ir::PalletConstantMetadataIR {
                            name: "MaxDebugBufferLen",
                            ty: frame_support::scale_info::meta_type::<u32>(),
                            value: {
                                let value = < < T as Config > :: MaxDebugBufferLen as frame_support :: traits :: Get < u32 > > :: get () ;
                                frame_support::codec::Encode::encode(&value)
                            },
                            docs: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    " The maximum length of the debug buffer in bytes.",
                                ]),
                            ),
                        }
                    },
                ]),
            )
        }
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn error_metadata() -> Option<frame_support::metadata_ir::PalletErrorMetadataIR> {
            Some(frame_support::metadata_ir::PalletErrorMetadataIR {
                ty: frame_support::scale_info::meta_type::<Error<T>>(),
            })
        }
    }
    /// Type alias to `Pallet`, to be used by `construct_runtime`.
    ///
    /// Generated by `pallet` attribute macro.
    #[deprecated(note = "use `Pallet` instead")]
    #[allow(dead_code)]
    pub type Module<T> = Pallet<T>;
    impl<T: Config> frame_support::traits::GetStorageVersion for Pallet<T> {
        type CurrentStorageVersion = frame_support::traits::StorageVersion;
        fn current_storage_version() -> Self::CurrentStorageVersion {
            STORAGE_VERSION
        }
        fn on_chain_storage_version() -> frame_support::traits::StorageVersion {
            frame_support::traits::StorageVersion::get::<Self>()
        }
    }
    impl<T: Config> frame_support::traits::OnGenesis for Pallet<T> {
        fn on_genesis() {
            let storage_version: frame_support::traits::StorageVersion = STORAGE_VERSION;
            storage_version.put::<Self>();
        }
    }
    impl<T: Config> frame_support::traits::PalletInfoAccess for Pallet<T> {
        fn index() -> usize {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::index::<
                Self,
            >()
            .expect(
                "Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime",
            )
        }
        fn name() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Self,
            >()
            .expect(
                "Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime",
            )
        }
        fn module_name() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: module_name :: < Self > () . expect ("Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime")
        }
        fn crate_version() -> frame_support::traits::CrateVersion {
            frame_support::traits::CrateVersion {
                major: 4u16,
                minor: 0u8,
                patch: 0u8,
            }
        }
    }
    impl<T: Config> frame_support::traits::PalletsInfoAccess for Pallet<T> {
        fn count() -> usize {
            1
        }
        fn infos() -> frame_support::sp_std::vec::Vec<frame_support::traits::PalletInfoData> {
            use frame_support::traits::PalletInfoAccess;
            let item = frame_support::traits::PalletInfoData {
                index: Self::index(),
                name: Self::name(),
                module_name: Self::module_name(),
                crate_version: Self::crate_version(),
            };
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([item]),
            )
        }
    }
    impl<T: Config> frame_support::traits::StorageInfoTrait for Pallet<T> {
        fn storage_info() -> frame_support::sp_std::vec::Vec<frame_support::traits::StorageInfo> {
            #[allow(unused_mut)]
            let mut res = ::alloc::vec::Vec::new();
            {
                let mut storage_info =
                    <PristineCode<T> as frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <CodeStorage<T> as frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <OwnerInfoOf<T> as frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <Nonce<T> as frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <ContractInfoOf<T> as frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <DeletionQueue<T> as frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info = < DeletionQueueCounter < T > as frame_support :: traits :: StorageInfoTrait > :: storage_info () ;
                res.append(&mut storage_info);
            }
            res
        }
    }
    use frame_support::traits::{StorageInfoTrait, TrackedStorageKey, WhitelistedStorageKeys};
    impl<T: Config> WhitelistedStorageKeys for Pallet<T> {
        fn whitelisted_storage_keys() -> frame_support::sp_std::vec::Vec<TrackedStorageKey> {
            use frame_support::sp_std::vec;
            ::alloc::vec::Vec::new()
        }
    }
    mod warnings {}
    #[doc(hidden)]
    pub mod __substrate_call_check {
        #[doc(hidden)]
        pub use __is_call_part_defined_0 as is_call_part_defined;
    }
    ///Contains one variant per dispatchable that can be called by an extrinsic.
    #[codec(encode_bound())]
    #[codec(decode_bound())]
    #[scale_info(skip_type_params(T), capture_docs = "always")]
    #[allow(non_camel_case_types)]
    pub enum Call<T: Config>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(
            frame_support::sp_std::marker::PhantomData<(T,)>,
            frame_support::Never,
        ),
        /// Deprecated version if [`Self::call`] for use in an in-storage `Call`.
        #[codec(index = 0u8)]
        call_old_weight {
            #[allow(missing_docs)]
            dest: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            #[codec(compact)]
            value: BalanceOf<T>,
            #[allow(missing_docs)]
            #[codec(compact)]
            gas_limit: OldWeight,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            data: Vec<u8>,
        },
        /// Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
        #[codec(index = 1u8)]
        instantiate_with_code_old_weight {
            #[allow(missing_docs)]
            #[codec(compact)]
            value: BalanceOf<T>,
            #[allow(missing_docs)]
            #[codec(compact)]
            gas_limit: OldWeight,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            code: Vec<u8>,
            #[allow(missing_docs)]
            data: Vec<u8>,
            #[allow(missing_docs)]
            salt: Vec<u8>,
        },
        /// Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
        #[codec(index = 2u8)]
        instantiate_old_weight {
            #[allow(missing_docs)]
            #[codec(compact)]
            value: BalanceOf<T>,
            #[allow(missing_docs)]
            #[codec(compact)]
            gas_limit: OldWeight,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            code_hash: CodeHash<T>,
            #[allow(missing_docs)]
            data: Vec<u8>,
            #[allow(missing_docs)]
            salt: Vec<u8>,
        },
        /// Upload new `code` without instantiating a contract from it.
        ///
        /// If the code does not already exist a deposit is reserved from the caller
        /// and unreserved only when [`Self::remove_code`] is called. The size of the reserve
        /// depends on the instrumented size of the the supplied `code`.
        ///
        /// If the code already exists in storage it will still return `Ok` and upgrades
        /// the in storage version to the current
        /// [`InstructionWeights::version`](InstructionWeights).
        ///
        /// - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
        ///   the only way to use this code is to delegate call into it from an offchain execution.
        ///   Set to [`Determinism::Enforced`] if in doubt.
        ///
        /// # Note
        ///
        /// Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
        /// To avoid this situation a constructor could employ access control so that it can
        /// only be instantiated by permissioned entities. The same is true when uploading
        /// through [`Self::instantiate_with_code`].
        #[codec(index = 3u8)]
        upload_code {
            #[allow(missing_docs)]
            code: Vec<u8>,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            determinism: Determinism,
        },
        /// Remove the code stored under `code_hash` and refund the deposit to its owner.
        ///
        /// A code can only be removed by its original uploader (its owner) and only if it is
        /// not used by any contract.
        #[codec(index = 4u8)]
        remove_code {
            #[allow(missing_docs)]
            code_hash: CodeHash<T>,
        },
        /// Privileged function that changes the code of an existing contract.
        ///
        /// This takes care of updating refcounts and all other necessary operations. Returns
        /// an error if either the `code_hash` or `dest` do not exist.
        ///
        /// # Note
        ///
        /// This does **not** change the address of the contract in question. This means
        /// that the contract address is no longer derived from its code hash after calling
        /// this dispatchable.
        #[codec(index = 5u8)]
        set_code {
            #[allow(missing_docs)]
            dest: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            code_hash: CodeHash<T>,
        },
        /// Makes a call to an account, optionally transferring some balance.
        ///
        /// # Parameters
        ///
        /// * `dest`: Address of the contract to call.
        /// * `value`: The balance to transfer from the `origin` to `dest`.
        /// * `gas_limit`: The gas limit enforced when executing the constructor.
        /// * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
        ///   caller to pay for the storage consumed.
        /// * `data`: The input data to pass to the contract.
        ///
        /// * If the account is a smart-contract account, the associated code will be
        /// executed and any value will be transferred.
        /// * If the account is a regular account, any value will be transferred.
        /// * If no account exists and the call value is not less than `existential_deposit`,
        /// a regular account will be created and any value will be transferred.
        #[codec(index = 6u8)]
        call {
            #[allow(missing_docs)]
            dest: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            #[codec(compact)]
            value: BalanceOf<T>,
            #[allow(missing_docs)]
            gas_limit: Weight,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            data: Vec<u8>,
        },
        /// Instantiates a new contract from the supplied `code` optionally transferring
        /// some balance.
        ///
        /// This dispatchable has the same effect as calling [`Self::upload_code`] +
        /// [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
        /// also check the documentation of [`Self::upload_code`].
        ///
        /// # Parameters
        ///
        /// * `value`: The balance to transfer from the `origin` to the newly created contract.
        /// * `gas_limit`: The gas limit enforced when executing the constructor.
        /// * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
        ///   from the caller to pay for the storage consumed.
        /// * `code`: The contract code to deploy in raw bytes.
        /// * `data`: The input data to pass to the contract constructor.
        /// * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
        ///
        /// Instantiation is executed as follows:
        ///
        /// - The supplied `code` is instrumented, deployed, and a `code_hash` is created for that
        ///   code.
        /// - If the `code_hash` already exists on the chain the underlying `code` will be shared.
        /// - The destination address is computed based on the sender, code_hash and the salt.
        /// - The smart-contract account is created at the computed address.
        /// - The `value` is transferred to the new account.
        /// - The `deploy` function is executed in the context of the newly-created account.
        #[codec(index = 7u8)]
        instantiate_with_code {
            #[allow(missing_docs)]
            #[codec(compact)]
            value: BalanceOf<T>,
            #[allow(missing_docs)]
            gas_limit: Weight,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            code: Vec<u8>,
            #[allow(missing_docs)]
            data: Vec<u8>,
            #[allow(missing_docs)]
            salt: Vec<u8>,
        },
        /// Instantiates a contract from a previously deployed wasm binary.
        ///
        /// This function is identical to [`Self::instantiate_with_code`] but without the
        /// code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
        /// must be supplied.
        #[codec(index = 8u8)]
        instantiate {
            #[allow(missing_docs)]
            #[codec(compact)]
            value: BalanceOf<T>,
            #[allow(missing_docs)]
            gas_limit: Weight,
            #[allow(missing_docs)]
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            #[allow(missing_docs)]
            code_hash: CodeHash<T>,
            #[allow(missing_docs)]
            data: Vec<u8>,
            #[allow(missing_docs)]
            salt: Vec<u8>,
        },
    }
    const _: () = {
        impl<T: Config> core::fmt::Debug for Call<T>
        where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
        {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                match *self {
                    Self::__Ignore(ref _0, ref _1) => fmt
                        .debug_tuple("Call::__Ignore")
                        .field(&_0)
                        .field(&_1)
                        .finish(),
                    Self::call_old_weight {
                        ref dest,
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref data,
                    } => fmt
                        .debug_struct("Call::call_old_weight")
                        .field("dest", &dest)
                        .field("value", &value)
                        .field("gas_limit", &gas_limit)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("data", &data)
                        .finish(),
                    Self::instantiate_with_code_old_weight {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code,
                        ref data,
                        ref salt,
                    } => fmt
                        .debug_struct("Call::instantiate_with_code_old_weight")
                        .field("value", &value)
                        .field("gas_limit", &gas_limit)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("code", &code)
                        .field("data", &data)
                        .field("salt", &salt)
                        .finish(),
                    Self::instantiate_old_weight {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code_hash,
                        ref data,
                        ref salt,
                    } => fmt
                        .debug_struct("Call::instantiate_old_weight")
                        .field("value", &value)
                        .field("gas_limit", &gas_limit)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("code_hash", &code_hash)
                        .field("data", &data)
                        .field("salt", &salt)
                        .finish(),
                    Self::upload_code {
                        ref code,
                        ref storage_deposit_limit,
                        ref determinism,
                    } => fmt
                        .debug_struct("Call::upload_code")
                        .field("code", &code)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("determinism", &determinism)
                        .finish(),
                    Self::remove_code { ref code_hash } => fmt
                        .debug_struct("Call::remove_code")
                        .field("code_hash", &code_hash)
                        .finish(),
                    Self::set_code {
                        ref dest,
                        ref code_hash,
                    } => fmt
                        .debug_struct("Call::set_code")
                        .field("dest", &dest)
                        .field("code_hash", &code_hash)
                        .finish(),
                    Self::call {
                        ref dest,
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref data,
                    } => fmt
                        .debug_struct("Call::call")
                        .field("dest", &dest)
                        .field("value", &value)
                        .field("gas_limit", &gas_limit)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("data", &data)
                        .finish(),
                    Self::instantiate_with_code {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code,
                        ref data,
                        ref salt,
                    } => fmt
                        .debug_struct("Call::instantiate_with_code")
                        .field("value", &value)
                        .field("gas_limit", &gas_limit)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("code", &code)
                        .field("data", &data)
                        .field("salt", &salt)
                        .finish(),
                    Self::instantiate {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code_hash,
                        ref data,
                        ref salt,
                    } => fmt
                        .debug_struct("Call::instantiate")
                        .field("value", &value)
                        .field("gas_limit", &gas_limit)
                        .field("storage_deposit_limit", &storage_deposit_limit)
                        .field("code_hash", &code_hash)
                        .field("data", &data)
                        .field("salt", &salt)
                        .finish(),
                }
            }
        }
    };
    const _: () = {
        impl<T: Config> core::clone::Clone for Call<T>
        where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
        {
            fn clone(&self) -> Self {
                match self {
                    Self::__Ignore(ref _0, ref _1) => {
                        Self::__Ignore(core::clone::Clone::clone(_0), core::clone::Clone::clone(_1))
                    }
                    Self::call_old_weight {
                        ref dest,
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref data,
                    } => Self::call_old_weight {
                        dest: core::clone::Clone::clone(dest),
                        value: core::clone::Clone::clone(value),
                        gas_limit: core::clone::Clone::clone(gas_limit),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        data: core::clone::Clone::clone(data),
                    },
                    Self::instantiate_with_code_old_weight {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code,
                        ref data,
                        ref salt,
                    } => Self::instantiate_with_code_old_weight {
                        value: core::clone::Clone::clone(value),
                        gas_limit: core::clone::Clone::clone(gas_limit),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        code: core::clone::Clone::clone(code),
                        data: core::clone::Clone::clone(data),
                        salt: core::clone::Clone::clone(salt),
                    },
                    Self::instantiate_old_weight {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code_hash,
                        ref data,
                        ref salt,
                    } => Self::instantiate_old_weight {
                        value: core::clone::Clone::clone(value),
                        gas_limit: core::clone::Clone::clone(gas_limit),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        code_hash: core::clone::Clone::clone(code_hash),
                        data: core::clone::Clone::clone(data),
                        salt: core::clone::Clone::clone(salt),
                    },
                    Self::upload_code {
                        ref code,
                        ref storage_deposit_limit,
                        ref determinism,
                    } => Self::upload_code {
                        code: core::clone::Clone::clone(code),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        determinism: core::clone::Clone::clone(determinism),
                    },
                    Self::remove_code { ref code_hash } => Self::remove_code {
                        code_hash: core::clone::Clone::clone(code_hash),
                    },
                    Self::set_code {
                        ref dest,
                        ref code_hash,
                    } => Self::set_code {
                        dest: core::clone::Clone::clone(dest),
                        code_hash: core::clone::Clone::clone(code_hash),
                    },
                    Self::call {
                        ref dest,
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref data,
                    } => Self::call {
                        dest: core::clone::Clone::clone(dest),
                        value: core::clone::Clone::clone(value),
                        gas_limit: core::clone::Clone::clone(gas_limit),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        data: core::clone::Clone::clone(data),
                    },
                    Self::instantiate_with_code {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code,
                        ref data,
                        ref salt,
                    } => Self::instantiate_with_code {
                        value: core::clone::Clone::clone(value),
                        gas_limit: core::clone::Clone::clone(gas_limit),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        code: core::clone::Clone::clone(code),
                        data: core::clone::Clone::clone(data),
                        salt: core::clone::Clone::clone(salt),
                    },
                    Self::instantiate {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code_hash,
                        ref data,
                        ref salt,
                    } => Self::instantiate {
                        value: core::clone::Clone::clone(value),
                        gas_limit: core::clone::Clone::clone(gas_limit),
                        storage_deposit_limit: core::clone::Clone::clone(storage_deposit_limit),
                        code_hash: core::clone::Clone::clone(code_hash),
                        data: core::clone::Clone::clone(data),
                        salt: core::clone::Clone::clone(salt),
                    },
                }
            }
        }
    };
    const _: () = {
        impl<T: Config> core::cmp::Eq for Call<T> where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode
        {
        }
    };
    const _: () = {
        impl<T: Config> core::cmp::PartialEq for Call<T>
        where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
        {
            fn eq(&self, other: &Self) -> bool {
                match (self, other) {
                    (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other)) => {
                        true && _0 == _0_other && _1 == _1_other
                    }
                    (
                        Self::call_old_weight {
                            dest,
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            data,
                        },
                        Self::call_old_weight {
                            dest: _0,
                            value: _1,
                            gas_limit: _2,
                            storage_deposit_limit: _3,
                            data: _4,
                        },
                    ) => {
                        true && dest == _0
                            && value == _1
                            && gas_limit == _2
                            && storage_deposit_limit == _3
                            && data == _4
                    }
                    (
                        Self::instantiate_with_code_old_weight {
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code,
                            data,
                            salt,
                        },
                        Self::instantiate_with_code_old_weight {
                            value: _0,
                            gas_limit: _1,
                            storage_deposit_limit: _2,
                            code: _3,
                            data: _4,
                            salt: _5,
                        },
                    ) => {
                        true && value == _0
                            && gas_limit == _1
                            && storage_deposit_limit == _2
                            && code == _3
                            && data == _4
                            && salt == _5
                    }
                    (
                        Self::instantiate_old_weight {
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        },
                        Self::instantiate_old_weight {
                            value: _0,
                            gas_limit: _1,
                            storage_deposit_limit: _2,
                            code_hash: _3,
                            data: _4,
                            salt: _5,
                        },
                    ) => {
                        true && value == _0
                            && gas_limit == _1
                            && storage_deposit_limit == _2
                            && code_hash == _3
                            && data == _4
                            && salt == _5
                    }
                    (
                        Self::upload_code {
                            code,
                            storage_deposit_limit,
                            determinism,
                        },
                        Self::upload_code {
                            code: _0,
                            storage_deposit_limit: _1,
                            determinism: _2,
                        },
                    ) => true && code == _0 && storage_deposit_limit == _1 && determinism == _2,
                    (Self::remove_code { code_hash }, Self::remove_code { code_hash: _0 }) => {
                        true && code_hash == _0
                    }
                    (
                        Self::set_code { dest, code_hash },
                        Self::set_code {
                            dest: _0,
                            code_hash: _1,
                        },
                    ) => true && dest == _0 && code_hash == _1,
                    (
                        Self::call {
                            dest,
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            data,
                        },
                        Self::call {
                            dest: _0,
                            value: _1,
                            gas_limit: _2,
                            storage_deposit_limit: _3,
                            data: _4,
                        },
                    ) => {
                        true && dest == _0
                            && value == _1
                            && gas_limit == _2
                            && storage_deposit_limit == _3
                            && data == _4
                    }
                    (
                        Self::instantiate_with_code {
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code,
                            data,
                            salt,
                        },
                        Self::instantiate_with_code {
                            value: _0,
                            gas_limit: _1,
                            storage_deposit_limit: _2,
                            code: _3,
                            data: _4,
                            salt: _5,
                        },
                    ) => {
                        true && value == _0
                            && gas_limit == _1
                            && storage_deposit_limit == _2
                            && code == _3
                            && data == _4
                            && salt == _5
                    }
                    (
                        Self::instantiate {
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        },
                        Self::instantiate {
                            value: _0,
                            gas_limit: _1,
                            storage_deposit_limit: _2,
                            code_hash: _3,
                            data: _4,
                            salt: _5,
                        },
                    ) => {
                        true && value == _0
                            && gas_limit == _1
                            && storage_deposit_limit == _2
                            && code_hash == _3
                            && data == _4
                            && salt == _5
                    }
                    (Self::__Ignore { .. }, Self::call_old_weight { .. }) => false,
                    (Self::__Ignore { .. }, Self::instantiate_with_code_old_weight { .. }) => false,
                    (Self::__Ignore { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::__Ignore { .. }, Self::upload_code { .. }) => false,
                    (Self::__Ignore { .. }, Self::remove_code { .. }) => false,
                    (Self::__Ignore { .. }, Self::set_code { .. }) => false,
                    (Self::__Ignore { .. }, Self::call { .. }) => false,
                    (Self::__Ignore { .. }, Self::instantiate_with_code { .. }) => false,
                    (Self::__Ignore { .. }, Self::instantiate { .. }) => false,
                    (Self::call_old_weight { .. }, Self::__Ignore { .. }) => false,
                    (
                        Self::call_old_weight { .. },
                        Self::instantiate_with_code_old_weight { .. },
                    ) => false,
                    (Self::call_old_weight { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::call_old_weight { .. }, Self::upload_code { .. }) => false,
                    (Self::call_old_weight { .. }, Self::remove_code { .. }) => false,
                    (Self::call_old_weight { .. }, Self::set_code { .. }) => false,
                    (Self::call_old_weight { .. }, Self::call { .. }) => false,
                    (Self::call_old_weight { .. }, Self::instantiate_with_code { .. }) => false,
                    (Self::call_old_weight { .. }, Self::instantiate { .. }) => false,
                    (Self::instantiate_with_code_old_weight { .. }, Self::__Ignore { .. }) => false,
                    (
                        Self::instantiate_with_code_old_weight { .. },
                        Self::call_old_weight { .. },
                    ) => false,
                    (
                        Self::instantiate_with_code_old_weight { .. },
                        Self::instantiate_old_weight { .. },
                    ) => false,
                    (Self::instantiate_with_code_old_weight { .. }, Self::upload_code { .. }) => {
                        false
                    }
                    (Self::instantiate_with_code_old_weight { .. }, Self::remove_code { .. }) => {
                        false
                    }
                    (Self::instantiate_with_code_old_weight { .. }, Self::set_code { .. }) => false,
                    (Self::instantiate_with_code_old_weight { .. }, Self::call { .. }) => false,
                    (
                        Self::instantiate_with_code_old_weight { .. },
                        Self::instantiate_with_code { .. },
                    ) => false,
                    (Self::instantiate_with_code_old_weight { .. }, Self::instantiate { .. }) => {
                        false
                    }
                    (Self::instantiate_old_weight { .. }, Self::__Ignore { .. }) => false,
                    (Self::instantiate_old_weight { .. }, Self::call_old_weight { .. }) => false,
                    (
                        Self::instantiate_old_weight { .. },
                        Self::instantiate_with_code_old_weight { .. },
                    ) => false,
                    (Self::instantiate_old_weight { .. }, Self::upload_code { .. }) => false,
                    (Self::instantiate_old_weight { .. }, Self::remove_code { .. }) => false,
                    (Self::instantiate_old_weight { .. }, Self::set_code { .. }) => false,
                    (Self::instantiate_old_weight { .. }, Self::call { .. }) => false,
                    (Self::instantiate_old_weight { .. }, Self::instantiate_with_code { .. }) => {
                        false
                    }
                    (Self::instantiate_old_weight { .. }, Self::instantiate { .. }) => false,
                    (Self::upload_code { .. }, Self::__Ignore { .. }) => false,
                    (Self::upload_code { .. }, Self::call_old_weight { .. }) => false,
                    (Self::upload_code { .. }, Self::instantiate_with_code_old_weight { .. }) => {
                        false
                    }
                    (Self::upload_code { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::upload_code { .. }, Self::remove_code { .. }) => false,
                    (Self::upload_code { .. }, Self::set_code { .. }) => false,
                    (Self::upload_code { .. }, Self::call { .. }) => false,
                    (Self::upload_code { .. }, Self::instantiate_with_code { .. }) => false,
                    (Self::upload_code { .. }, Self::instantiate { .. }) => false,
                    (Self::remove_code { .. }, Self::__Ignore { .. }) => false,
                    (Self::remove_code { .. }, Self::call_old_weight { .. }) => false,
                    (Self::remove_code { .. }, Self::instantiate_with_code_old_weight { .. }) => {
                        false
                    }
                    (Self::remove_code { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::remove_code { .. }, Self::upload_code { .. }) => false,
                    (Self::remove_code { .. }, Self::set_code { .. }) => false,
                    (Self::remove_code { .. }, Self::call { .. }) => false,
                    (Self::remove_code { .. }, Self::instantiate_with_code { .. }) => false,
                    (Self::remove_code { .. }, Self::instantiate { .. }) => false,
                    (Self::set_code { .. }, Self::__Ignore { .. }) => false,
                    (Self::set_code { .. }, Self::call_old_weight { .. }) => false,
                    (Self::set_code { .. }, Self::instantiate_with_code_old_weight { .. }) => false,
                    (Self::set_code { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::set_code { .. }, Self::upload_code { .. }) => false,
                    (Self::set_code { .. }, Self::remove_code { .. }) => false,
                    (Self::set_code { .. }, Self::call { .. }) => false,
                    (Self::set_code { .. }, Self::instantiate_with_code { .. }) => false,
                    (Self::set_code { .. }, Self::instantiate { .. }) => false,
                    (Self::call { .. }, Self::__Ignore { .. }) => false,
                    (Self::call { .. }, Self::call_old_weight { .. }) => false,
                    (Self::call { .. }, Self::instantiate_with_code_old_weight { .. }) => false,
                    (Self::call { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::call { .. }, Self::upload_code { .. }) => false,
                    (Self::call { .. }, Self::remove_code { .. }) => false,
                    (Self::call { .. }, Self::set_code { .. }) => false,
                    (Self::call { .. }, Self::instantiate_with_code { .. }) => false,
                    (Self::call { .. }, Self::instantiate { .. }) => false,
                    (Self::instantiate_with_code { .. }, Self::__Ignore { .. }) => false,
                    (Self::instantiate_with_code { .. }, Self::call_old_weight { .. }) => false,
                    (
                        Self::instantiate_with_code { .. },
                        Self::instantiate_with_code_old_weight { .. },
                    ) => false,
                    (Self::instantiate_with_code { .. }, Self::instantiate_old_weight { .. }) => {
                        false
                    }
                    (Self::instantiate_with_code { .. }, Self::upload_code { .. }) => false,
                    (Self::instantiate_with_code { .. }, Self::remove_code { .. }) => false,
                    (Self::instantiate_with_code { .. }, Self::set_code { .. }) => false,
                    (Self::instantiate_with_code { .. }, Self::call { .. }) => false,
                    (Self::instantiate_with_code { .. }, Self::instantiate { .. }) => false,
                    (Self::instantiate { .. }, Self::__Ignore { .. }) => false,
                    (Self::instantiate { .. }, Self::call_old_weight { .. }) => false,
                    (Self::instantiate { .. }, Self::instantiate_with_code_old_weight { .. }) => {
                        false
                    }
                    (Self::instantiate { .. }, Self::instantiate_old_weight { .. }) => false,
                    (Self::instantiate { .. }, Self::upload_code { .. }) => false,
                    (Self::instantiate { .. }, Self::remove_code { .. }) => false,
                    (Self::instantiate { .. }, Self::set_code { .. }) => false,
                    (Self::instantiate { .. }, Self::call { .. }) => false,
                    (Self::instantiate { .. }, Self::instantiate_with_code { .. }) => false,
                }
            }
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[allow(non_camel_case_types)]
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for Call<T>
        where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
        {
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::call_old_weight {
                        ref dest,
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref data,
                    } => {
                        __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                        ::codec::Encode::encode_to(dest, __codec_dest_edqy);
                        {
                            :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (value) , __codec_dest_edqy) ;
                        }
                        {
                            :: codec :: Encode :: encode_to (& < < OldWeight as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , OldWeight > > :: RefType :: from (gas_limit) , __codec_dest_edqy) ;
                        }
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                    }
                    Call::instantiate_with_code_old_weight {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code,
                        ref data,
                        ref salt,
                    } => {
                        __codec_dest_edqy.push_byte(1u8 as ::core::primitive::u8);
                        {
                            :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (value) , __codec_dest_edqy) ;
                        }
                        {
                            :: codec :: Encode :: encode_to (& < < OldWeight as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , OldWeight > > :: RefType :: from (gas_limit) , __codec_dest_edqy) ;
                        }
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(code, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                        ::codec::Encode::encode_to(salt, __codec_dest_edqy);
                    }
                    Call::instantiate_old_weight {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code_hash,
                        ref data,
                        ref salt,
                    } => {
                        __codec_dest_edqy.push_byte(2u8 as ::core::primitive::u8);
                        {
                            :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (value) , __codec_dest_edqy) ;
                        }
                        {
                            :: codec :: Encode :: encode_to (& < < OldWeight as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , OldWeight > > :: RefType :: from (gas_limit) , __codec_dest_edqy) ;
                        }
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                        ::codec::Encode::encode_to(salt, __codec_dest_edqy);
                    }
                    Call::upload_code {
                        ref code,
                        ref storage_deposit_limit,
                        ref determinism,
                    } => {
                        __codec_dest_edqy.push_byte(3u8 as ::core::primitive::u8);
                        ::codec::Encode::encode_to(code, __codec_dest_edqy);
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(determinism, __codec_dest_edqy);
                    }
                    Call::remove_code { ref code_hash } => {
                        __codec_dest_edqy.push_byte(4u8 as ::core::primitive::u8);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                    }
                    Call::set_code {
                        ref dest,
                        ref code_hash,
                    } => {
                        __codec_dest_edqy.push_byte(5u8 as ::core::primitive::u8);
                        ::codec::Encode::encode_to(dest, __codec_dest_edqy);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                    }
                    Call::call {
                        ref dest,
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref data,
                    } => {
                        __codec_dest_edqy.push_byte(6u8 as ::core::primitive::u8);
                        ::codec::Encode::encode_to(dest, __codec_dest_edqy);
                        {
                            :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (value) , __codec_dest_edqy) ;
                        }
                        ::codec::Encode::encode_to(gas_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                    }
                    Call::instantiate_with_code {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code,
                        ref data,
                        ref salt,
                    } => {
                        __codec_dest_edqy.push_byte(7u8 as ::core::primitive::u8);
                        {
                            :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (value) , __codec_dest_edqy) ;
                        }
                        ::codec::Encode::encode_to(gas_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(code, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                        ::codec::Encode::encode_to(salt, __codec_dest_edqy);
                    }
                    Call::instantiate {
                        ref value,
                        ref gas_limit,
                        ref storage_deposit_limit,
                        ref code_hash,
                        ref data,
                        ref salt,
                    } => {
                        __codec_dest_edqy.push_byte(8u8 as ::core::primitive::u8);
                        {
                            :: codec :: Encode :: encode_to (& < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: EncodeAsRef < '_ , BalanceOf < T > > > :: RefType :: from (value) , __codec_dest_edqy) ;
                        }
                        ::codec::Encode::encode_to(gas_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(storage_deposit_limit, __codec_dest_edqy);
                        ::codec::Encode::encode_to(code_hash, __codec_dest_edqy);
                        ::codec::Encode::encode_to(data, __codec_dest_edqy);
                        ::codec::Encode::encode_to(salt, __codec_dest_edqy);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for Call<T> where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode
        {
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[allow(non_camel_case_types)]
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for Call<T>
        where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| e.chain("Could not decode `Call`, failed to read variant byte"))?
                {
                    __codec_x_edqy if __codec_x_edqy == 0u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::call_old_weight {
                            dest: {
                                let __codec_res_edqy =
                                    <AccountIdLookupOf<T> as ::codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::call_old_weight::dest`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            value: {
                                let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::call_old_weight::value`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy.into()
                                    }
                                }
                            },
                            gas_limit: {
                                let __codec_res_edqy = < < OldWeight as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::call_old_weight::gas_limit`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy.into()
                                    }
                                }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::call_old_weight::storage_deposit_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::call_old_weight::data`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 1u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::instantiate_with_code_old_weight {
                            value: {
                                let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code_old_weight::value`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                            },
                            gas_limit: {
                                let __codec_res_edqy = < < OldWeight as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code_old_weight::gas_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code_old_weight::storage_deposit_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            code: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code_old_weight::code`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code_old_weight::data`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            salt: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code_old_weight::salt`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 2u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::instantiate_old_weight {
                            value: {
                                let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_old_weight::value`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                            },
                            gas_limit: {
                                let __codec_res_edqy = < < OldWeight as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_old_weight::gas_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy . into () , }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_old_weight::storage_deposit_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            code_hash: {
                                let __codec_res_edqy =
                                    <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_old_weight::code_hash`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate_old_weight::data`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            salt: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate_old_weight::salt`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 3u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::upload_code {
                            code: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::upload_code::code`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::upload_code::storage_deposit_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            determinism: {
                                let __codec_res_edqy =
                                    <Determinism as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::upload_code::determinism`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 4u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::remove_code {
                            code_hash: {
                                let __codec_res_edqy =
                                    <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::remove_code::code_hash`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 5u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::set_code {
                            dest: {
                                let __codec_res_edqy =
                                    <AccountIdLookupOf<T> as ::codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::set_code::dest`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            code_hash: {
                                let __codec_res_edqy =
                                    <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::set_code::code_hash`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 6u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::call {
                            dest: {
                                let __codec_res_edqy =
                                    <AccountIdLookupOf<T> as ::codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::call::dest`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            value: {
                                let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::call::value`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy.into()
                                    }
                                }
                            },
                            gas_limit: {
                                let __codec_res_edqy =
                                    <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::call::gas_limit`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::call::storage_deposit_limit`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::call::data`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 7u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::instantiate_with_code {
                            value: {
                                let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate_with_code::value`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy.into()
                                    }
                                }
                            },
                            gas_limit: {
                                let __codec_res_edqy =
                                    <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code::gas_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate_with_code::storage_deposit_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            code: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate_with_code::code`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate_with_code::data`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            salt: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate_with_code::salt`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    __codec_x_edqy if __codec_x_edqy == 8u8 as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Call::<T>::instantiate {
                            value: {
                                let __codec_res_edqy = < < BalanceOf < T > as :: codec :: HasCompact > :: Type as :: codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::instantiate::value`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy.into()
                                    }
                                }
                            },
                            gas_limit: {
                                let __codec_res_edqy =
                                    <Weight as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate::gas_limit`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            storage_deposit_limit: {
                                let __codec_res_edqy = <Option<
                                    <BalanceOf<T> as codec::HasCompact>::Type,
                                > as ::codec::Decode>::decode(
                                    __codec_input_edqy
                                );
                                match __codec_res_edqy { :: core :: result :: Result :: Err (e) => return :: core :: result :: Result :: Err (e . chain ("Could not decode `Call::instantiate::storage_deposit_limit`")) , :: core :: result :: Result :: Ok (__codec_res_edqy) => __codec_res_edqy , }
                            },
                            code_hash: {
                                let __codec_res_edqy =
                                    <CodeHash<T> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(e.chain(
                                            "Could not decode `Call::instantiate::code_hash`",
                                        ))
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            data: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::instantiate::data`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                            salt: {
                                let __codec_res_edqy =
                                    <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `Call::instantiate::salt`"),
                                        )
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            },
                        })
                    }
                    _ => ::core::result::Result::Err(<_ as ::core::convert::Into<_>>::into(
                        "Could not decode `Call`, variant doesn't exist",
                    )),
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T: Config> ::scale_info::TypeInfo for Call<T>
        where
            <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
            frame_support::sp_std::marker::PhantomData<(T,)>: ::scale_info::TypeInfo + 'static,
            AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::scale::HasCompact,
            Option<<BalanceOf<T> as codec::HasCompact>::Type>: ::scale_info::TypeInfo + 'static,
            CodeHash<T>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Call" , "pallet_contracts::pallet")) . type_params (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([:: scale_info :: TypeParameter :: new ("T" , :: core :: option :: Option :: None)]))) . docs_always (& ["Contains one variant per dispatchable that can be called by an extrinsic."]) . variant (:: scale_info :: build :: Variants :: new () . variant ("call_old_weight" , | v | v . index (0u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < AccountIdLookupOf < T > > () . name ("dest") . type_name ("AccountIdLookupOf<T>")) . field (| f | f . compact :: < BalanceOf < T > > () . name ("value") . type_name ("BalanceOf<T>")) . field (| f | f . compact :: < OldWeight > () . name ("gas_limit") . type_name ("OldWeight")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>"))) . docs_always (& ["Deprecated version if [`Self::call`] for use in an in-storage `Call`."])) . variant ("instantiate_with_code_old_weight" , | v | v . index (1u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . compact :: < BalanceOf < T > > () . name ("value") . type_name ("BalanceOf<T>")) . field (| f | f . compact :: < OldWeight > () . name ("gas_limit") . type_name ("OldWeight")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("code") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("salt") . type_name ("Vec<u8>"))) . docs_always (& ["Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."])) . variant ("instantiate_old_weight" , | v | v . index (2u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . compact :: < BalanceOf < T > > () . name ("value") . type_name ("BalanceOf<T>")) . field (| f | f . compact :: < OldWeight > () . name ("gas_limit") . type_name ("OldWeight")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < CodeHash < T > > () . name ("code_hash") . type_name ("CodeHash<T>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("salt") . type_name ("Vec<u8>"))) . docs_always (& ["Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."])) . variant ("upload_code" , | v | v . index (3u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < Vec < u8 > > () . name ("code") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < Determinism > () . name ("determinism") . type_name ("Determinism"))) . docs_always (& ["Upload new `code` without instantiating a contract from it." , "" , "If the code does not already exist a deposit is reserved from the caller" , "and unreserved only when [`Self::remove_code`] is called. The size of the reserve" , "depends on the instrumented size of the the supplied `code`." , "" , "If the code already exists in storage it will still return `Ok` and upgrades" , "the in storage version to the current" , "[`InstructionWeights::version`](InstructionWeights)." , "" , "- `determinism`: If this is set to any other value but [`Determinism::Enforced`] then" , "  the only way to use this code is to delegate call into it from an offchain execution." , "  Set to [`Determinism::Enforced`] if in doubt." , "" , "# Note" , "" , "Anyone can instantiate a contract from any uploaded code and thus prevent its removal." , "To avoid this situation a constructor could employ access control so that it can" , "only be instantiated by permissioned entities. The same is true when uploading" , "through [`Self::instantiate_with_code`]."])) . variant ("remove_code" , | v | v . index (4u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < CodeHash < T > > () . name ("code_hash") . type_name ("CodeHash<T>"))) . docs_always (& ["Remove the code stored under `code_hash` and refund the deposit to its owner." , "" , "A code can only be removed by its original uploader (its owner) and only if it is" , "not used by any contract."])) . variant ("set_code" , | v | v . index (5u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < AccountIdLookupOf < T > > () . name ("dest") . type_name ("AccountIdLookupOf<T>")) . field (| f | f . ty :: < CodeHash < T > > () . name ("code_hash") . type_name ("CodeHash<T>"))) . docs_always (& ["Privileged function that changes the code of an existing contract." , "" , "This takes care of updating refcounts and all other necessary operations. Returns" , "an error if either the `code_hash` or `dest` do not exist." , "" , "# Note" , "" , "This does **not** change the address of the contract in question. This means" , "that the contract address is no longer derived from its code hash after calling" , "this dispatchable."])) . variant ("call" , | v | v . index (6u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < AccountIdLookupOf < T > > () . name ("dest") . type_name ("AccountIdLookupOf<T>")) . field (| f | f . compact :: < BalanceOf < T > > () . name ("value") . type_name ("BalanceOf<T>")) . field (| f | f . ty :: < Weight > () . name ("gas_limit") . type_name ("Weight")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>"))) . docs_always (& ["Makes a call to an account, optionally transferring some balance." , "" , "# Parameters" , "" , "* `dest`: Address of the contract to call." , "* `value`: The balance to transfer from the `origin` to `dest`." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the" , "  caller to pay for the storage consumed." , "* `data`: The input data to pass to the contract." , "" , "* If the account is a smart-contract account, the associated code will be" , "executed and any value will be transferred." , "* If the account is a regular account, any value will be transferred." , "* If no account exists and the call value is not less than `existential_deposit`," , "a regular account will be created and any value will be transferred."])) . variant ("instantiate_with_code" , | v | v . index (7u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . compact :: < BalanceOf < T > > () . name ("value") . type_name ("BalanceOf<T>")) . field (| f | f . ty :: < Weight > () . name ("gas_limit") . type_name ("Weight")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("code") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("salt") . type_name ("Vec<u8>"))) . docs_always (& ["Instantiates a new contract from the supplied `code` optionally transferring" , "some balance." , "" , "This dispatchable has the same effect as calling [`Self::upload_code`] +" , "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please" , "also check the documentation of [`Self::upload_code`]." , "" , "# Parameters" , "" , "* `value`: The balance to transfer from the `origin` to the newly created contract." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "* `code`: The contract code to deploy in raw bytes." , "* `data`: The input data to pass to the contract constructor." , "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]." , "" , "Instantiation is executed as follows:" , "" , "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that" , "  code." , "- If the `code_hash` already exists on the chain the underlying `code` will be shared." , "- The destination address is computed based on the sender, code_hash and the salt." , "- The smart-contract account is created at the computed address." , "- The `value` is transferred to the new account." , "- The `deploy` function is executed in the context of the newly-created account."])) . variant ("instantiate" , | v | v . index (8u8 as :: core :: primitive :: u8) . fields (:: scale_info :: build :: Fields :: named () . field (| f | f . compact :: < BalanceOf < T > > () . name ("value") . type_name ("BalanceOf<T>")) . field (| f | f . ty :: < Weight > () . name ("gas_limit") . type_name ("Weight")) . field (| f | f . ty :: < Option < < BalanceOf < T > as codec :: HasCompact > :: Type > > () . name ("storage_deposit_limit") . type_name ("Option<<BalanceOf<T> as codec::HasCompact>::Type>")) . field (| f | f . ty :: < CodeHash < T > > () . name ("code_hash") . type_name ("CodeHash<T>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("data") . type_name ("Vec<u8>")) . field (| f | f . ty :: < Vec < u8 > > () . name ("salt") . type_name ("Vec<u8>"))) . docs_always (& ["Instantiates a contract from a previously deployed wasm binary." , "" , "This function is identical to [`Self::instantiate_with_code`] but without the" , "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary" , "must be supplied."])))
            }
        };
    };
    impl<T: Config> Call<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        ///Create a call with the variant `call_old_weight`.
        pub fn new_call_variant_call_old_weight(
            dest: AccountIdLookupOf<T>,
            value: BalanceOf<T>,
            gas_limit: OldWeight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            data: Vec<u8>,
        ) -> Self {
            Self::call_old_weight {
                dest,
                value,
                gas_limit,
                storage_deposit_limit,
                data,
            }
        }
        ///Create a call with the variant `instantiate_with_code_old_weight`.
        pub fn new_call_variant_instantiate_with_code_old_weight(
            value: BalanceOf<T>,
            gas_limit: OldWeight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code: Vec<u8>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> Self {
            Self::instantiate_with_code_old_weight {
                value,
                gas_limit,
                storage_deposit_limit,
                code,
                data,
                salt,
            }
        }
        ///Create a call with the variant `instantiate_old_weight`.
        pub fn new_call_variant_instantiate_old_weight(
            value: BalanceOf<T>,
            gas_limit: OldWeight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code_hash: CodeHash<T>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> Self {
            Self::instantiate_old_weight {
                value,
                gas_limit,
                storage_deposit_limit,
                code_hash,
                data,
                salt,
            }
        }
        ///Create a call with the variant `upload_code`.
        pub fn new_call_variant_upload_code(
            code: Vec<u8>,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            determinism: Determinism,
        ) -> Self {
            Self::upload_code {
                code,
                storage_deposit_limit,
                determinism,
            }
        }
        ///Create a call with the variant `remove_code`.
        pub fn new_call_variant_remove_code(code_hash: CodeHash<T>) -> Self {
            Self::remove_code { code_hash }
        }
        ///Create a call with the variant `set_code`.
        pub fn new_call_variant_set_code(
            dest: AccountIdLookupOf<T>,
            code_hash: CodeHash<T>,
        ) -> Self {
            Self::set_code { dest, code_hash }
        }
        ///Create a call with the variant `call`.
        pub fn new_call_variant_call(
            dest: AccountIdLookupOf<T>,
            value: BalanceOf<T>,
            gas_limit: Weight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            data: Vec<u8>,
        ) -> Self {
            Self::call {
                dest,
                value,
                gas_limit,
                storage_deposit_limit,
                data,
            }
        }
        ///Create a call with the variant `instantiate_with_code`.
        pub fn new_call_variant_instantiate_with_code(
            value: BalanceOf<T>,
            gas_limit: Weight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code: Vec<u8>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> Self {
            Self::instantiate_with_code {
                value,
                gas_limit,
                storage_deposit_limit,
                code,
                data,
                salt,
            }
        }
        ///Create a call with the variant `instantiate`.
        pub fn new_call_variant_instantiate(
            value: BalanceOf<T>,
            gas_limit: Weight,
            storage_deposit_limit: Option<<BalanceOf<T> as codec::HasCompact>::Type>,
            code_hash: CodeHash<T>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> Self {
            Self::instantiate {
                value,
                gas_limit,
                storage_deposit_limit,
                code_hash,
                data,
                salt,
            }
        }
    }
    impl<T: Config> frame_support::dispatch::GetDispatchInfo for Call<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        fn get_dispatch_info(&self) -> frame_support::dispatch::DispatchInfo {
            match *self {
                Self::call_old_weight {
                    ref dest,
                    ref value,
                    ref gas_limit,
                    ref storage_deposit_limit,
                    ref data,
                } => {
                    let __pallet_base_weight = T::WeightInfo::call()
                        .saturating_add(<Pallet<T>>::compat_weight_limit(*gas_limit));
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &AccountIdLookupOf<T>,
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (dest, value, gas_limit, storage_deposit_limit, data),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &AccountIdLookupOf<T>,
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (dest, value, gas_limit, storage_deposit_limit, data),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &AccountIdLookupOf<T>,
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (dest, value, gas_limit, storage_deposit_limit, data),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::instantiate_with_code_old_weight {
                    ref value,
                    ref gas_limit,
                    ref storage_deposit_limit,
                    ref code,
                    ref data,
                    ref salt,
                } => {
                    let __pallet_base_weight = T::WeightInfo::instantiate_with_code(
                        code.len() as u32,
                        data.len() as u32,
                        salt.len() as u32,
                    )
                    .saturating_add(<Pallet<T>>::compat_weight_limit(*gas_limit));
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (value, gas_limit, storage_deposit_limit, code, data, salt),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (value, gas_limit, storage_deposit_limit, code, data, salt),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (value, gas_limit, storage_deposit_limit, code, data, salt),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::instantiate_old_weight {
                    ref value,
                    ref gas_limit,
                    ref storage_deposit_limit,
                    ref code_hash,
                    ref data,
                    ref salt,
                } => {
                    let __pallet_base_weight =
                        T::WeightInfo::instantiate(data.len() as u32, salt.len() as u32)
                            .saturating_add(<Pallet<T>>::compat_weight_limit(*gas_limit));
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &CodeHash<T>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        ),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &CodeHash<T>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        ),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &BalanceOf<T>,
                        &OldWeight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &CodeHash<T>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        ),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::upload_code {
                    ref code,
                    ref storage_deposit_limit,
                    ref determinism,
                } => {
                    let __pallet_base_weight = T::WeightInfo::upload_code(code.len() as u32);
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &Vec<u8>,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Determinism,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (code, storage_deposit_limit, determinism),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &Vec<u8>,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Determinism,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (code, storage_deposit_limit, determinism),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &Vec<u8>,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Determinism,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (code, storage_deposit_limit, determinism),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::remove_code { ref code_hash } => {
                    let __pallet_base_weight = T::WeightInfo::remove_code();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&CodeHash<T>,)>>::weigh_data(
                            &__pallet_base_weight,
                            (code_hash,),
                        );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &CodeHash<T>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight, (code_hash,)
                    );
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&CodeHash<T>,)>>::pays_fee(
                            &__pallet_base_weight,
                            (code_hash,),
                        );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_code {
                    ref dest,
                    ref code_hash,
                } => {
                    let __pallet_base_weight = T::WeightInfo::set_code();
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &AccountIdLookupOf<T>,
                        &CodeHash<T>,
                    )>>::weigh_data(
                        &__pallet_base_weight, (dest, code_hash)
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &AccountIdLookupOf<T>,
                        &CodeHash<T>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight, (dest, code_hash)
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &AccountIdLookupOf<T>,
                        &CodeHash<T>,
                    )>>::pays_fee(
                        &__pallet_base_weight, (dest, code_hash)
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::call {
                    ref dest,
                    ref value,
                    ref gas_limit,
                    ref storage_deposit_limit,
                    ref data,
                } => {
                    let __pallet_base_weight = T::WeightInfo::call().saturating_add(*gas_limit);
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &AccountIdLookupOf<T>,
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (dest, value, gas_limit, storage_deposit_limit, data),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &AccountIdLookupOf<T>,
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (dest, value, gas_limit, storage_deposit_limit, data),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &AccountIdLookupOf<T>,
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (dest, value, gas_limit, storage_deposit_limit, data),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::instantiate_with_code {
                    ref value,
                    ref gas_limit,
                    ref storage_deposit_limit,
                    ref code,
                    ref data,
                    ref salt,
                } => {
                    let __pallet_base_weight = T::WeightInfo::instantiate_with_code(
                        code.len() as u32,
                        data.len() as u32,
                        salt.len() as u32,
                    )
                    .saturating_add(*gas_limit);
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (value, gas_limit, storage_deposit_limit, code, data, salt),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (value, gas_limit, storage_deposit_limit, code, data, salt),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &Vec<u8>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (value, gas_limit, storage_deposit_limit, code, data, salt),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::instantiate {
                    ref value,
                    ref gas_limit,
                    ref storage_deposit_limit,
                    ref code_hash,
                    ref data,
                    ref salt,
                } => {
                    let __pallet_base_weight =
                        T::WeightInfo::instantiate(data.len() as u32, salt.len() as u32)
                            .saturating_add(*gas_limit);
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &CodeHash<T>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::weigh_data(
                        &__pallet_base_weight,
                        (
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        ),
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &CodeHash<T>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight,
                        (
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        ),
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &BalanceOf<T>,
                        &Weight,
                        &Option<<BalanceOf<T> as codec::HasCompact>::Type>,
                        &CodeHash<T>,
                        &Vec<u8>,
                        &Vec<u8>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (
                            value,
                            gas_limit,
                            storage_deposit_limit,
                            code_hash,
                            data,
                            salt,
                        ),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::__Ignore(_, _) => ::core::panicking::panic_fmt(format_args!(
                    "internal error: entered unreachable code: {0}",
                    format_args!("__Ignore cannot be used")
                )),
            }
        }
    }
    #[allow(deprecated)]
    impl<T: Config> frame_support::weights::GetDispatchInfo for Call<T> where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode
    {
    }
    impl<T: Config> frame_support::dispatch::GetCallName for Call<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Self::call_old_weight { .. } => "call_old_weight",
                Self::instantiate_with_code_old_weight { .. } => "instantiate_with_code_old_weight",
                Self::instantiate_old_weight { .. } => "instantiate_old_weight",
                Self::upload_code { .. } => "upload_code",
                Self::remove_code { .. } => "remove_code",
                Self::set_code { .. } => "set_code",
                Self::call { .. } => "call",
                Self::instantiate_with_code { .. } => "instantiate_with_code",
                Self::instantiate { .. } => "instantiate",
                Self::__Ignore(_, _) => ::core::panicking::panic_fmt(format_args!(
                    "internal error: entered unreachable code: {0}",
                    format_args!("__PhantomItem cannot be used.")
                )),
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &[
                "call_old_weight",
                "instantiate_with_code_old_weight",
                "instantiate_old_weight",
                "upload_code",
                "remove_code",
                "set_code",
                "call",
                "instantiate_with_code",
                "instantiate",
            ]
        }
    }
    impl<T: Config> frame_support::dispatch::GetCallIndex for Call<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        fn get_call_index(&self) -> u8 {
            match *self {
                Self::call_old_weight { .. } => 0u8,
                Self::instantiate_with_code_old_weight { .. } => 1u8,
                Self::instantiate_old_weight { .. } => 2u8,
                Self::upload_code { .. } => 3u8,
                Self::remove_code { .. } => 4u8,
                Self::set_code { .. } => 5u8,
                Self::call { .. } => 6u8,
                Self::instantiate_with_code { .. } => 7u8,
                Self::instantiate { .. } => 8u8,
                Self::__Ignore(_, _) => ::core::panicking::panic_fmt(format_args!(
                    "internal error: entered unreachable code: {0}",
                    format_args!("__PhantomItem cannot be used.")
                )),
            }
        }
        fn get_call_indices() -> &'static [u8] {
            &[0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8]
        }
    }
    impl<T: Config> frame_support::traits::UnfilteredDispatchable for Call<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        type RuntimeOrigin = frame_system::pallet_prelude::OriginFor<T>;
        fn dispatch_bypass_filter(
            self,
            origin: Self::RuntimeOrigin,
        ) -> frame_support::dispatch::DispatchResultWithPostInfo {
            frame_support::dispatch_context::run_in_context(|| match self {
                Self::call_old_weight {
                    dest,
                    value,
                    gas_limit,
                    storage_deposit_limit,
                    data,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "call_old_weight",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    #[allow(deprecated)]
                    <Pallet<T>>::call_old_weight(
                        origin,
                        dest,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        data,
                    )
                    .map(Into::into)
                    .map_err(Into::into)
                }
                Self::instantiate_with_code_old_weight {
                    value,
                    gas_limit,
                    storage_deposit_limit,
                    code,
                    data,
                    salt,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "instantiate_with_code_old_weight",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    #[allow(deprecated)]
                    <Pallet<T>>::instantiate_with_code_old_weight(
                        origin,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code,
                        data,
                        salt,
                    )
                    .map(Into::into)
                    .map_err(Into::into)
                }
                Self::instantiate_old_weight {
                    value,
                    gas_limit,
                    storage_deposit_limit,
                    code_hash,
                    data,
                    salt,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "instantiate_old_weight",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    #[allow(deprecated)]
                    <Pallet<T>>::instantiate_old_weight(
                        origin,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code_hash,
                        data,
                        salt,
                    )
                    .map(Into::into)
                    .map_err(Into::into)
                }
                Self::upload_code {
                    code,
                    storage_deposit_limit,
                    determinism,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "upload_code",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T>>::upload_code(origin, code, storage_deposit_limit, determinism)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::remove_code { code_hash } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "remove_code",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T>>::remove_code(origin, code_hash)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::set_code { dest, code_hash } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "set_code",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T>>::set_code(origin, dest, code_hash)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::call {
                    dest,
                    value,
                    gas_limit,
                    storage_deposit_limit,
                    data,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "call",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T>>::call(origin, dest, value, gas_limit, storage_deposit_limit, data)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::instantiate_with_code {
                    value,
                    gas_limit,
                    storage_deposit_limit,
                    code,
                    data,
                    salt,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "instantiate_with_code",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T>>::instantiate_with_code(
                        origin,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code,
                        data,
                        salt,
                    )
                    .map(Into::into)
                    .map_err(Into::into)
                }
                Self::instantiate {
                    value,
                    gas_limit,
                    storage_deposit_limit,
                    code_hash,
                    data,
                    salt,
                } => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "instantiate",
                                    "pallet_contracts::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("frame/contracts/src/lib.rs"),
                                    Some(175u32),
                                    Some("pallet_contracts::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span =
                                ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T>>::instantiate(
                        origin,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code_hash,
                        data,
                        salt,
                    )
                    .map(Into::into)
                    .map_err(Into::into)
                }
                Self::__Ignore(_, _) => {
                    let _ = origin;
                    ::core::panicking::panic_fmt(format_args!(
                        "internal error: entered unreachable code: {0}",
                        format_args!("__PhantomItem cannot be used.")
                    ));
                }
            })
        }
    }
    impl<T: Config> frame_support::dispatch::Callable<T> for Pallet<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        type RuntimeCall = Call<T>;
    }
    impl<T: Config> Pallet<T>
    where
        <BalanceOf<T> as HasCompact>::Type: Clone + Eq + PartialEq + Debug + TypeInfo + Encode,
    {
        #[doc(hidden)]
        pub fn call_functions() -> frame_support::metadata_ir::PalletCallMetadataIR {
            frame_support::scale_info::meta_type::<Call<T>>().into()
        }
    }
    impl<T: Config> frame_support::sp_std::fmt::Debug for Error<T> {
        fn fmt(
            &self,
            f: &mut frame_support::sp_std::fmt::Formatter<'_>,
        ) -> frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Config> Error<T> {
        #[doc(hidden)]
        pub fn as_str(&self) -> &'static str {
            match &self {
                Self::__Ignore(_, _) => ::core::panicking::panic_fmt(format_args!(
                    "internal error: entered unreachable code: {0}",
                    format_args!("`__Ignore` can never be constructed")
                )),
                Self::InvalidScheduleVersion => "InvalidScheduleVersion",
                Self::InvalidCallFlags => "InvalidCallFlags",
                Self::OutOfGas => "OutOfGas",
                Self::OutputBufferTooSmall => "OutputBufferTooSmall",
                Self::TransferFailed => "TransferFailed",
                Self::MaxCallDepthReached => "MaxCallDepthReached",
                Self::ContractNotFound => "ContractNotFound",
                Self::CodeTooLarge => "CodeTooLarge",
                Self::CodeNotFound => "CodeNotFound",
                Self::OutOfBounds => "OutOfBounds",
                Self::DecodingFailed => "DecodingFailed",
                Self::ContractTrapped => "ContractTrapped",
                Self::ValueTooLarge => "ValueTooLarge",
                Self::TerminatedWhileReentrant => "TerminatedWhileReentrant",
                Self::InputForwarded => "InputForwarded",
                Self::RandomSubjectTooLong => "RandomSubjectTooLong",
                Self::TooManyTopics => "TooManyTopics",
                Self::NoChainExtension => "NoChainExtension",
                Self::DuplicateContract => "DuplicateContract",
                Self::TerminatedInConstructor => "TerminatedInConstructor",
                Self::ReentranceDenied => "ReentranceDenied",
                Self::StorageDepositNotEnoughFunds => "StorageDepositNotEnoughFunds",
                Self::StorageDepositLimitExhausted => "StorageDepositLimitExhausted",
                Self::CodeInUse => "CodeInUse",
                Self::ContractReverted => "ContractReverted",
                Self::CodeRejected => "CodeRejected",
                Self::Indeterministic => "Indeterministic",
            }
        }
    }
    impl<T: Config> From<Error<T>> for &'static str {
        fn from(err: Error<T>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Config> From<Error<T>> for frame_support::sp_runtime::DispatchError {
        fn from(err: Error<T>) -> Self {
            use frame_support::codec::Encode;
            let index = < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: index :: < Pallet < T > > () . expect ("Every active module has an index in the runtime; qed") as u8 ;
            let mut encoded = err.encode();
            encoded.resize(frame_support::MAX_MODULE_ERROR_ENCODED_SIZE, 0);
            frame_support :: sp_runtime :: DispatchError :: Module (frame_support :: sp_runtime :: ModuleError { index , error : TryInto :: try_into (encoded) . expect ("encoded error is resized to be equal to the maximum encoded error size; qed") , message : Some (err . as_str ()) , })
        }
    }
    pub use __tt_error_token_1 as tt_error_token;
    #[doc(hidden)]
    pub mod __substrate_event_check {
        #[doc(hidden)]
        pub use __is_event_part_defined_2 as is_event_part_defined;
    }
    impl<T: Config> From<Event<T>> for () {
        fn from(_: Event<T>) {}
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn storage_metadata() -> frame_support::metadata_ir::PalletStorageMetadataIR {
            frame_support :: metadata_ir :: PalletStorageMetadataIR { prefix : < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.") , entries : { # [allow (unused_mut)] let mut entries = :: alloc :: vec :: Vec :: new () ; { < PristineCode < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" A mapping from an original code hash to the original code, untouched by instrumentation."])) , & mut entries) ; } { < CodeStorage < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" A mapping between an original code hash and instrumented wasm code, ready for execution."])) , & mut entries) ; } { < OwnerInfoOf < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" A mapping between an original code hash and its owner information."])) , & mut entries) ; } { < Nonce < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" This is a **monotonic** counter incremented on contract instantiation." , "" , " This is used in order to generate unique trie ids for contracts." , " The trie id of a new contract is calculated from hash(account_id, nonce)." , " The nonce is required because otherwise the following sequence would lead to" , " a possible collision of storage:" , "" , " 1. Create a new contract." , " 2. Terminate the contract." , " 3. Immediately recreate the contract with the same account_id." , "" , " This is bad because the contents of a trie are deleted lazily and there might be" , " storage of the old instantiation still in it when the new contract is created. Please" , " note that we can\'t replace the counter by the block number because the sequence above" , " can happen in the same block. We also can\'t keep the account counter in memory only" , " because storage is the only way to communicate across different extrinsics in the" , " same block." , "" , " # Note" , "" , " Do not use it to determine the number of contracts. It won\'t be decremented if" , " a contract is destroyed."])) , & mut entries) ; } { < ContractInfoOf < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" The code associated with a given account." , "" , " TWOX-NOTE: SAFE since `AccountId` is a secure hash."])) , & mut entries) ; } { < DeletionQueue < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Evicted contracts that await child trie deletion." , "" , " Child trie deletion is a heavy operation depending on the amount of storage items" , " stored in said trie. Therefore this operation is performed lazily in `on_idle`."])) , & mut entries) ; } { < DeletionQueueCounter < T > as frame_support :: storage :: StorageEntryMetadataBuilder > :: build_metadata (< [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" A pair of monotonic counters used to track the latest contract marked for deletion" , " and the latest deleted contract in queue."])) , & mut entries) ; } entries } , }
        }
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStoragePristineCode<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStoragePristineCode<T>
    {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "PristineCode";
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStorageCodeStorage<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageCodeStorage<T>
    {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CodeStorage";
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStorageOwnerInfoOf<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageOwnerInfoOf<T>
    {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "OwnerInfoOf";
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStorageNonce<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for _GeneratedPrefixForStorageNonce<T> {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "Nonce";
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStorageContractInfoOf<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageContractInfoOf<T>
    {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "ContractInfoOf";
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStorageDeletionQueue<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageDeletionQueue<T>
    {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "DeletionQueue";
    }
    #[doc(hidden)]
    pub(crate) struct _GeneratedPrefixForStorageDeletionQueueCounter<T>(
        core::marker::PhantomData<(T,)>,
    );
    impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageDeletionQueueCounter<T>
    {
        fn pallet_prefix() -> &'static str {
            < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T > > () . expect ("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "DeletionQueueCounter";
    }
    #[doc(hidden)]
    pub mod __substrate_inherent_check {
        #[doc(hidden)]
        pub use __is_inherent_part_defined_3 as is_inherent_part_defined;
    }
    /// Hidden instance generated to be internally used when module is used without
    /// instance.
    #[doc(hidden)]
    pub type __InherentHiddenInstance = ();
    impl<T: Config> frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Pallet<T>
    {
        fn on_finalize(n: <T as frame_system::Config>::BlockNumber) {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_finalize",
                            "pallet_contracts::pallet",
                            ::tracing::Level::TRACE,
                            Some("frame/contracts/src/lib.rs"),
                            Some(175u32),
                            Some("pallet_contracts::pallet"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(), interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_finalize (n)
        }
    }
    impl<T: Config> frame_support::traits::OnIdle<<T as frame_system::Config>::BlockNumber>
        for Pallet<T>
    {
        fn on_idle(
            n: <T as frame_system::Config>::BlockNumber,
            remaining_weight: frame_support::weights::Weight,
        ) -> frame_support::weights::Weight {
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_idle (n , remaining_weight)
        }
    }
    impl<T: Config> frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Pallet<T>
    {
        fn on_initialize(
            n: <T as frame_system::Config>::BlockNumber,
        ) -> frame_support::weights::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_initialize",
                            "pallet_contracts::pallet",
                            ::tracing::Level::TRACE,
                            Some("frame/contracts/src/lib.rs"),
                            Some(175u32),
                            Some("pallet_contracts::pallet"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(), interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_initialize (n)
        }
    }
    impl<T: Config> frame_support::traits::OnRuntimeUpgrade for Pallet<T> {
        fn on_runtime_upgrade() -> frame_support::weights::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_update",
                            "pallet_contracts::pallet",
                            ::tracing::Level::TRACE,
                            Some("frame/contracts/src/lib.rs"),
                            Some(175u32),
                            Some("pallet_contracts::pallet"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(), interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            let pallet_name = < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Self > () . unwrap_or ("<unknown pallet name>") ;
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        format_args!("✅ no migration for {0}", pallet_name),
                        lvl,
                        &(
                            frame_support::LOG_TARGET,
                            "pallet_contracts::pallet",
                            "frame/contracts/src/lib.rs",
                            175u32,
                        ),
                        ::log::__private_api::Option::None,
                    );
                }
            };
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_runtime_upgrade ()
        }
    }
    impl<T: Config> frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Pallet<T>
    {
        fn offchain_worker(n: <T as frame_system::Config>::BlockNumber) {
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: offchain_worker (n)
        }
    }
    impl<T: Config> frame_support::traits::IntegrityTest for Pallet<T> {
        fn integrity_test() {
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: integrity_test ()
        }
    }
    #[doc(hidden)]
    pub mod __substrate_genesis_config_check {
        #[doc(hidden)]
        pub use __is_genesis_config_defined_4 as is_genesis_config_defined;
        #[doc(hidden)]
        pub use __is_std_enabled_for_genesis_4 as is_std_enabled_for_genesis;
    }
    #[doc(hidden)]
    pub mod __substrate_origin_check {
        #[doc(hidden)]
        pub use __is_origin_part_defined_5 as is_origin_part_defined;
    }
    #[doc(hidden)]
    pub mod __substrate_validate_unsigned_check {
        #[doc(hidden)]
        pub use __is_validate_unsigned_part_defined_6 as is_validate_unsigned_part_defined;
    }
    pub use __tt_default_parts_7 as tt_default_parts;
}
/// The type of origins supported by the contracts pallet.
pub enum Origin<T: Config> {
    Root,
    Signed(T::AccountId),
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for Origin<T>
where
    T::AccountId: ::core::clone::Clone,
{
    #[inline]
    fn clone(&self) -> Origin<T> {
        match self {
            Origin::Root => Origin::Root,
            Origin::Signed(__self_0) => Origin::Signed(::core::clone::Clone::clone(__self_0)),
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::codec::Encode for Origin<T>
    where
        T::AccountId: ::codec::Encode,
        T::AccountId: ::codec::Encode,
    {
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                Origin::Root => {
                    __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                }
                Origin::Signed(ref aa) => {
                    __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => (),
            }
        }
    }
    #[automatically_derived]
    impl<T: Config> ::codec::EncodeLike for Origin<T>
    where
        T::AccountId: ::codec::Encode,
        T::AccountId: ::codec::Encode,
    {
    }
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::codec::Decode for Origin<T>
    where
        T::AccountId: ::codec::Decode,
        T::AccountId: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| e.chain("Could not decode `Origin`, failed to read variant byte"))?
            {
                __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                    ::core::result::Result::Ok(Origin::<T>::Root)
                }
                __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                    ::core::result::Result::Ok(Origin::<T>::Signed({
                        let __codec_res_edqy =
                            <T::AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `Origin::Signed.0`"),
                                )
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    }))
                }
                _ => ::core::result::Result::Err(<_ as ::core::convert::Into<_>>::into(
                    "Could not decode `Origin`, variant doesn't exist",
                )),
            }
        }
    }
};
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for Origin<T> {}
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for Origin<T>
where
    T::AccountId: ::core::cmp::PartialEq,
{
    #[inline]
    fn eq(&self, other: &Origin<T>) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (Origin::Signed(__self_0), Origin::Signed(__arg1_0)) => *__self_0 == *__arg1_0,
                _ => true,
            }
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<T: Config> ::scale_info::TypeInfo for Origin<T>
    where
        T::AccountId: ::scale_info::TypeInfo + 'static,
        T: Config + ::scale_info::TypeInfo + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(::scale_info::Path::new("Origin", "pallet_contracts"))
                .type_params(<[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([::scale_info::TypeParameter::new(
                        "T",
                        ::core::option::Option::Some(::scale_info::meta_type::<T>()),
                    )]),
                ))
                .docs(&["The type of origins supported by the contracts pallet."])
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant("Root", |v| v.index(0usize as ::core::primitive::u8))
                        .variant("Signed", |v| {
                            v.index(1usize as ::core::primitive::u8).fields(
                                ::scale_info::build::Fields::unnamed()
                                    .field(|f| f.ty::<T::AccountId>().type_name("T::AccountId")),
                            )
                        }),
                )
        }
    };
};
const _: () = {
    impl<T: Config> core::fmt::Debug for Origin<T> {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match *self {
                Self::Root => fmt.write_str("Origin::Root"),
                Self::Signed(ref _0) => fmt.debug_tuple("Origin::Signed").field(&_0).finish(),
            }
        }
    }
};
impl<T: Config> Origin<T> {
    /// Creates a new Signed Caller from an AccountId.
    pub fn from_account_id(account_id: T::AccountId) -> Self {
        Origin::Signed(account_id)
    }
    /// Creates a new Origin from a `RuntimeOrigin`.
    pub fn from_runtime_origin(o: OriginFor<T>) -> Result<Self, DispatchError> {
        match o.into() {
            Ok(RawOrigin::Root) => Ok(Self::Root),
            Ok(RawOrigin::Signed(t)) => Ok(Self::Signed(t)),
            _ => Err(BadOrigin.into()),
        }
    }
    /// Returns the AccountId of a Signed Origin or an error if the origin is Root.
    pub fn account_id(&self) -> Result<&T::AccountId, DispatchError> {
        match self {
            Origin::Signed(id) => Ok(id),
            Origin::Root => Err(DispatchError::RootNotAllowed),
        }
    }
}
/// Context of a contract invocation.
struct CommonInput<'a, T: Config> {
    origin: Origin<T>,
    value: BalanceOf<T>,
    data: Vec<u8>,
    gas_limit: Weight,
    storage_deposit_limit: Option<BalanceOf<T>>,
    debug_message: Option<&'a mut DebugBufferVec<T>>,
}
/// Input specific to a call into contract.
struct CallInput<T: Config> {
    dest: T::AccountId,
    determinism: Determinism,
}
/// Input specific to a contract instantiation invocation.
struct InstantiateInput<T: Config> {
    code: Code<CodeHash<T>>,
    salt: Vec<u8>,
}
/// Determines whether events should be collected during execution.
pub enum CollectEvents {
    /// Collect events.
    ///
    /// # Note
    ///
    /// Events should only be collected when called off-chain, as this would otherwise
    /// collect all the Events emitted in the block so far and put them into the PoV.
    ///
    /// **Never** use this mode for on-chain execution.
    UnsafeCollect,
    /// Skip event collection.
    Skip,
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for CollectEvents {}
#[automatically_derived]
impl ::core::cmp::PartialEq for CollectEvents {
    #[inline]
    fn eq(&self, other: &CollectEvents) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
    }
}
/// Determines whether debug messages will be collected.
pub enum DebugInfo {
    /// Collect debug messages.
    /// # Note
    ///
    /// This should only ever be set to `UnsafeDebug` when executing as an RPC because
    /// it adds allocations and could be abused to drive the runtime into an OOM panic.
    UnsafeDebug,
    /// Skip collection of debug messages.
    Skip,
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for DebugInfo {}
#[automatically_derived]
impl ::core::cmp::PartialEq for DebugInfo {
    #[inline]
    fn eq(&self, other: &DebugInfo) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
    }
}
/// Return type of private helper functions.
struct InternalOutput<T: Config, O> {
    /// The gas meter that was used to execute the call.
    gas_meter: GasMeter<T>,
    /// The storage deposit used by the call.
    storage_deposit: StorageDeposit<BalanceOf<T>>,
    /// The result of the call.
    result: Result<O, ExecError>,
}
/// Helper trait to wrap contract execution entry points into a single function
/// [`Invokable::run_guarded`].
trait Invokable<T: Config> {
    /// What is returned as a result of a successful invocation.
    type Output;
    /// Single entry point to contract execution.
    /// Downstream execution flow is branched by implementations of [`Invokable`] trait:
    ///
    /// - [`InstantiateInput::run`] runs contract instantiation,
    /// - [`CallInput::run`] runs contract call.
    ///
    /// We enforce a re-entrancy guard here by initializing and checking a boolean flag through a
    /// global reference.
    fn run_guarded(&self, common: CommonInput<T>) -> InternalOutput<T, Self::Output> {
        #[allow(non_camel_case_types)]
        struct executing_contract {
            __private_field: (),
        }
        const GLOBAL: ::std::thread::LocalKey<::environmental::GlobalInner<bool>> = {
            #[inline]
            fn __init() -> ::environmental::GlobalInner<bool> {
                Default::default()
            }
            #[inline]
            unsafe fn __getit(
                init: ::std::option::Option<
                    &mut ::std::option::Option<::environmental::GlobalInner<bool>>,
                >,
            ) -> ::std::option::Option<&'static ::environmental::GlobalInner<bool>> {
                #[thread_local]
                static __KEY: ::std::thread::__LocalKeyInner<::environmental::GlobalInner<bool>> =
                    ::std::thread::__LocalKeyInner::<::environmental::GlobalInner<bool>>::new();
                #[allow(unused_unsafe)]
                unsafe {
                    __KEY.get(move || {
                        if let ::std::option::Option::Some(init) = init {
                            if let ::std::option::Option::Some(value) = init.take() {
                                return value;
                            } else if true {
                                ::core::panicking::panic_fmt(format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("missing default value")
                                ));
                            }
                        }
                        __init()
                    })
                }
            }
            unsafe { ::std::thread::LocalKey::new(__getit) }
        };
        impl executing_contract {
            #[allow(unused_imports)]
            #[allow(dead_code)]
            pub fn using<R, F: FnOnce() -> R>(protected: &mut bool, f: F) -> R {
                ::environmental::using(&GLOBAL, protected, f)
            }
            #[allow(dead_code)]
            pub fn with<R, F: FnOnce(&mut bool) -> R>(f: F) -> Option<R> {
                ::environmental::with(&GLOBAL, |x| f(x))
            }
            #[allow(dead_code)]
            pub fn using_once<R, F: FnOnce() -> R>(protected: &mut bool, f: F) -> R {
                ::environmental::using_once(&GLOBAL, protected, f)
            }
        }
        let gas_limit = common.gas_limit;
        if let Err(e) = self.ensure_origin(common.origin.clone()) {
            return InternalOutput {
                gas_meter: GasMeter::new(gas_limit),
                storage_deposit: Default::default(),
                result: Err(ExecError {
                    error: e.into(),
                    origin: ErrorOrigin::Caller,
                }),
            };
        }
        executing_contract::using_once(
            &mut false,
            || {
            executing_contract :: with (
                | f | {
                    if * f {
                        return Err (())
                    }
                    * f = true ;
                    Ok (())
                })
                .expect ("Returns `Ok` if called within `using_once`. It is syntactically obvious that this is the case; qed")
                . map_or_else (
                    | _ | InternalOutput {
                        gas_meter : GasMeter :: new (gas_limit) ,
                        storage_deposit : Default :: default () ,
                        result : Err (
                            ExecError {
                                error : < Error < T > > :: ReentranceDenied . into () ,
                                origin : ErrorOrigin :: Caller ,
                            }) ,
                    } ,
                    | _ | self . run (common , GasMeter :: new (gas_limit)))
        })
    }
    /// Method that does the actual call to a contract. It can be either a call to a deployed
    /// contract or a instantiation of a new one.
    ///
    /// Called by dispatchables and public functions through the [`Invokable::run_guarded`].
    fn run(
        &self,
        common: CommonInput<T>,
        gas_meter: GasMeter<T>,
    ) -> InternalOutput<T, Self::Output>;
    /// This method ensures that the given `origin` is allowed to invoke the current `Invokable`.
    ///
    /// Called by dispatchables and public functions through the [`Invokable::run_guarded`].
    fn ensure_origin(&self, origin: Origin<T>) -> Result<(), DispatchError>;
}
impl<T: Config> Invokable<T> for CallInput<T> {
    type Output = ExecReturnValue;
    fn run(
        &self,
        common: CommonInput<T>,
        mut gas_meter: GasMeter<T>,
    ) -> InternalOutput<T, Self::Output> {
        let CallInput { dest, determinism } = self;
        let CommonInput {
            origin,
            value,
            data,
            debug_message,
            ..
        } = common;
        let mut storage_meter =
            match StorageMeter::new(&origin, common.storage_deposit_limit, common.value) {
                Ok(meter) => meter,
                Err(err) => {
                    return InternalOutput {
                        result: Err(err.into()),
                        gas_meter,
                        storage_deposit: Default::default(),
                    }
                }
            };
        let schedule = T::Schedule::get();
        let result = ExecStack::<T, PrefabWasmModule<T>>::run_call(
            origin.clone(),
            dest.clone(),
            &mut gas_meter,
            &mut storage_meter,
            &schedule,
            value,
            data.clone(),
            debug_message,
            *determinism,
        );
        match storage_meter.try_into_deposit(&origin) {
            Ok(storage_deposit) => InternalOutput {
                gas_meter,
                storage_deposit,
                result,
            },
            Err(err) => InternalOutput {
                gas_meter,
                storage_deposit: Default::default(),
                result: Err(err.into()),
            },
        }
    }
    fn ensure_origin(&self, _origin: Origin<T>) -> Result<(), DispatchError> {
        Ok(())
    }
}
impl<T: Config> Invokable<T> for InstantiateInput<T> {
    type Output = (AccountIdOf<T>, ExecReturnValue);
    fn run(
        &self,
        mut common: CommonInput<T>,
        mut gas_meter: GasMeter<T>,
    ) -> InternalOutput<T, Self::Output> {
        let mut storage_deposit = Default::default();
        let try_exec = || {
            let schedule = T::Schedule::get();
            let InstantiateInput { salt, .. } = self;
            let CommonInput {
                origin: contract_origin,
                ..
            } = common;
            let origin = contract_origin.account_id()?;
            let (extra_deposit, executable) = match &self.code {
                Code::Upload(binary) => {
                    let executable = PrefabWasmModule::from_code(
                        binary.clone(),
                        &schedule,
                        origin.clone(),
                        Determinism::Enforced,
                        TryInstantiate::Skip,
                    )
                    .map_err(|(err, msg)| {
                        common
                            .debug_message
                            .as_mut()
                            .map(|buffer| buffer.try_extend(&mut msg.bytes()));
                        err
                    })?;
                    (executable.open_deposit(), executable)
                }
                Code::Existing(hash) => (
                    Default::default(),
                    PrefabWasmModule::from_storage(*hash, &schedule, &mut gas_meter)?,
                ),
            };
            let contract_origin = Origin::from_account_id(origin.clone());
            let mut storage_meter = StorageMeter::new(
                &contract_origin,
                common.storage_deposit_limit,
                common.value.saturating_add(extra_deposit),
            )?;
            let CommonInput {
                value,
                data,
                debug_message,
                ..
            } = common;
            let result = ExecStack::<T, PrefabWasmModule<T>>::run_instantiate(
                origin.clone(),
                executable,
                &mut gas_meter,
                &mut storage_meter,
                &schedule,
                value,
                data.clone(),
                &salt,
                debug_message,
            );
            storage_deposit = storage_meter
                .try_into_deposit(&contract_origin)?
                .saturating_add(&StorageDeposit::Charge(extra_deposit));
            result
        };
        InternalOutput {
            result: try_exec(),
            gas_meter,
            storage_deposit,
        }
    }
    fn ensure_origin(&self, origin: Origin<T>) -> Result<(), DispatchError> {
        match origin {
            Origin::Signed(_) => Ok(()),
            Origin::Root => Err(DispatchError::RootNotAllowed),
        }
    }
}
impl<T: Config> Pallet<T> {
    /// Perform a call to a specified contract.
    ///
    /// This function is similar to [`Self::call`], but doesn't perform any address lookups
    /// and better suitable for calling directly from Rust.
    ///
    /// # Note
    ///
    /// If `debug` is set to `DebugInfo::UnsafeDebug` it returns additional human readable debugging
    /// information.
    ///
    /// If `collect_events` is set to `CollectEvents::UnsafeCollect` it collects all the Events
    /// emitted in the block so far and the ones emitted during the execution of this contract.
    pub fn bare_call(
        origin: T::AccountId,
        dest: T::AccountId,
        value: BalanceOf<T>,
        gas_limit: Weight,
        storage_deposit_limit: Option<BalanceOf<T>>,
        data: Vec<u8>,
        debug: DebugInfo,
        collect_events: CollectEvents,
        determinism: Determinism,
    ) -> ContractExecResult<BalanceOf<T>, EventRecordOf<T>> {
        let mut debug_message = if match debug {
            DebugInfo::UnsafeDebug => true,
            _ => false,
        } {
            Some(DebugBufferVec::<T>::default())
        } else {
            None
        };
        let origin = Origin::from_account_id(origin);
        let common = CommonInput {
            origin,
            value,
            data,
            gas_limit,
            storage_deposit_limit,
            debug_message: debug_message.as_mut(),
        };
        let output = CallInput::<T> { dest, determinism }.run_guarded(common);
        let events = if match collect_events {
            CollectEvents::UnsafeCollect => true,
            _ => false,
        } {
            Some(
                System::<T>::read_events_no_consensus()
                    .map(|e| *e)
                    .collect(),
            )
        } else {
            None
        };
        ContractExecResult {
            result: output.result.map_err(|r| r.error),
            gas_consumed: output.gas_meter.gas_consumed(),
            gas_required: output.gas_meter.gas_required(),
            storage_deposit: output.storage_deposit,
            debug_message: debug_message.unwrap_or_default().to_vec(),
            events,
        }
    }
    /// Instantiate a new contract.
    ///
    /// This function is similar to [`Self::instantiate`], but doesn't perform any address lookups
    /// and better suitable for calling directly from Rust.
    ///
    /// It returns the execution result, account id and the amount of used weight.
    ///
    /// # Note
    ///
    /// If `debug` is set to `DebugInfo::UnsafeDebug` it returns additional human readable debugging
    /// information.
    ///
    /// If `collect_events` is set to `CollectEvents::UnsafeCollect` it collects all the Events
    /// emitted in the block so far.
    pub fn bare_instantiate(
        origin: T::AccountId,
        value: BalanceOf<T>,
        gas_limit: Weight,
        storage_deposit_limit: Option<BalanceOf<T>>,
        code: Code<CodeHash<T>>,
        data: Vec<u8>,
        salt: Vec<u8>,
        debug: DebugInfo,
        collect_events: CollectEvents,
    ) -> ContractInstantiateResult<T::AccountId, BalanceOf<T>, EventRecordOf<T>> {
        let mut debug_message = if debug == DebugInfo::UnsafeDebug {
            Some(DebugBufferVec::<T>::default())
        } else {
            None
        };
        let common = CommonInput {
            origin: Origin::from_account_id(origin),
            value,
            data,
            gas_limit,
            storage_deposit_limit,
            debug_message: debug_message.as_mut(),
        };
        let output = InstantiateInput::<T> { code, salt }.run_guarded(common);
        let events = if collect_events == CollectEvents::UnsafeCollect {
            Some(
                System::<T>::read_events_no_consensus()
                    .map(|e| *e)
                    .collect(),
            )
        } else {
            None
        };
        ContractInstantiateResult {
            result: output
                .result
                .map(|(account_id, result)| InstantiateReturnValue { result, account_id })
                .map_err(|e| e.error),
            gas_consumed: output.gas_meter.gas_consumed(),
            gas_required: output.gas_meter.gas_required(),
            storage_deposit: output.storage_deposit,
            debug_message: debug_message.unwrap_or_default().to_vec(),
            events,
        }
    }
    /// Upload new code without instantiating a contract from it.
    ///
    /// This function is similar to [`Self::upload_code`], but doesn't perform any address lookups
    /// and better suitable for calling directly from Rust.
    pub fn bare_upload_code(
        origin: T::AccountId,
        code: Vec<u8>,
        storage_deposit_limit: Option<BalanceOf<T>>,
        determinism: Determinism,
    ) -> CodeUploadResult<CodeHash<T>, BalanceOf<T>> {
        let schedule = T::Schedule::get();
        let module = PrefabWasmModule::from_code(
            code,
            &schedule,
            origin,
            determinism,
            TryInstantiate::Instantiate,
        )
        .map_err(|(err, _)| err)?;
        let deposit = module.open_deposit();
        if let Some(storage_deposit_limit) = storage_deposit_limit {
            {
                if !(storage_deposit_limit >= deposit) {
                    {
                        return Err(<Error<T>>::StorageDepositLimitExhausted.into());
                    };
                }
            };
        }
        let result = CodeUploadReturnValue {
            code_hash: *module.code_hash(),
            deposit,
        };
        module.store()?;
        Ok(result)
    }
    /// Query storage of a specified contract under a specified key.
    pub fn get_storage(address: T::AccountId, key: Vec<u8>) -> GetStorageResult {
        let contract_info =
            ContractInfoOf::<T>::get(&address).ok_or(ContractAccessError::DoesntExist)?;
        let maybe_value = contract_info.read(
            &Key::<T>::try_from_var(key)
                .map_err(|_| ContractAccessError::KeyDecodingFailed)?
                .into(),
        );
        Ok(maybe_value)
    }
    /// Determine the address of a contract.
    ///
    /// This is the address generation function used by contract instantiation. See
    /// [`DefaultAddressGenerator`] for the default implementation.
    pub fn contract_address(
        deploying_address: &T::AccountId,
        code_hash: &CodeHash<T>,
        input_data: &[u8],
        salt: &[u8],
    ) -> T::AccountId {
        T::AddressGenerator::contract_address(deploying_address, code_hash, input_data, salt)
    }
    /// Returns the code hash of the contract specified by `account` ID.
    pub fn code_hash(account: &AccountIdOf<T>) -> Option<CodeHash<T>> {
        ContractInfo::<T>::load_code_hash(account)
    }
    /// Deposit a pallet contracts event. Handles the conversion to the overarching event type.
    fn deposit_event(topics: Vec<T::Hash>, event: Event<T>) {
        <frame_system::Pallet<T>>::deposit_event_indexed(
            &topics,
            <T as Config>::RuntimeEvent::from(event).into(),
        )
    }
    /// Return the existential deposit of [`Config::Currency`].
    fn min_balance() -> BalanceOf<T> {
        <T::Currency as Inspect<AccountIdOf<T>>>::minimum_balance()
    }
    /// Convert gas_limit from 1D Weight to a 2D Weight.
    ///
    /// Used by backwards compatible extrinsics. We cannot just set the proof_size weight limit to
    /// zero or an old `Call` will just fail with OutOfGas.
    fn compat_weight_limit(gas_limit: OldWeight) -> Weight {
        Weight::from_parts(gas_limit, u64::from(T::MaxCodeLen::get()) * 2)
    }
}
#[doc(hidden)]
#[allow(dead_code)]
#[allow(deprecated)]
pub mod runtime_decl_for_contracts_api {
    pub use super::*;
    /// The API used to dry-run contract interactions.
    pub trait ContractsApiV2<
        Block: sp_api::BlockT,
        AccountId,
        Balance,
        BlockNumber,
        Hash,
        EventRecord,
    >
    where
        AccountId: Codec,
        Balance: Codec,
        BlockNumber: Codec,
        Hash: Codec,
        EventRecord: Codec,
    {
        /// Perform a call from a specified account to a given contract.
        ///
        /// See [`crate::Pallet::bare_call`].
        fn call(
            origin: AccountId,
            dest: AccountId,
            value: Balance,
            gas_limit: Option<Weight>,
            storage_deposit_limit: Option<Balance>,
            input_data: Vec<u8>,
        ) -> ContractExecResult<Balance, EventRecord>;
        /// Instantiate a new contract.
        ///
        /// See `[crate::Pallet::bare_instantiate]`.
        fn instantiate(
            origin: AccountId,
            value: Balance,
            gas_limit: Option<Weight>,
            storage_deposit_limit: Option<Balance>,
            code: Code<Hash>,
            data: Vec<u8>,
            salt: Vec<u8>,
        ) -> ContractInstantiateResult<AccountId, Balance, EventRecord>;
        /// Upload new code without instantiating a contract from it.
        ///
        /// See [`crate::Pallet::bare_upload_code`].
        fn upload_code(
            origin: AccountId,
            code: Vec<u8>,
            storage_deposit_limit: Option<Balance>,
            determinism: Determinism,
        ) -> CodeUploadResult<Hash, Balance>;
        /// Query a given storage key in a given contract.
        ///
        /// Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
        /// specified account and `Ok(None)` if it doesn't. If the account specified by the address
        /// doesn't exist, or doesn't have a contract then `Err` is returned.
        fn get_storage(address: AccountId, key: Vec<u8>) -> GetStorageResult;
    }
    pub use ContractsApiV2 as ContractsApi;
    #[inline(always)]
    pub fn runtime_metadata<
        Block: sp_api::BlockT,
        AccountId,
        Balance,
        BlockNumber,
        Hash,
        EventRecord,
    >() -> sp_api::metadata_ir::RuntimeApiMetadataIR
    where
        AccountId: sp_api::scale_info::TypeInfo + 'static,
        AccountId: sp_api::scale_info::TypeInfo + 'static,
        Balance: sp_api::scale_info::TypeInfo + 'static,
        Option<Weight>: sp_api::scale_info::TypeInfo + 'static,
        Option<Balance>: sp_api::scale_info::TypeInfo + 'static,
        Vec<u8>: sp_api::scale_info::TypeInfo + 'static,
        ContractExecResult<Balance, EventRecord>: sp_api::scale_info::TypeInfo + 'static,
        AccountId: sp_api::scale_info::TypeInfo + 'static,
        Balance: sp_api::scale_info::TypeInfo + 'static,
        Option<Weight>: sp_api::scale_info::TypeInfo + 'static,
        Option<Balance>: sp_api::scale_info::TypeInfo + 'static,
        Code<Hash>: sp_api::scale_info::TypeInfo + 'static,
        Vec<u8>: sp_api::scale_info::TypeInfo + 'static,
        Vec<u8>: sp_api::scale_info::TypeInfo + 'static,
        ContractInstantiateResult<AccountId, Balance, EventRecord>:
            sp_api::scale_info::TypeInfo + 'static,
        AccountId: sp_api::scale_info::TypeInfo + 'static,
        Vec<u8>: sp_api::scale_info::TypeInfo + 'static,
        Option<Balance>: sp_api::scale_info::TypeInfo + 'static,
        Determinism: sp_api::scale_info::TypeInfo + 'static,
        CodeUploadResult<Hash, Balance>: sp_api::scale_info::TypeInfo + 'static,
        AccountId: sp_api::scale_info::TypeInfo + 'static,
        Vec<u8>: sp_api::scale_info::TypeInfo + 'static,
        GetStorageResult: sp_api::scale_info::TypeInfo + 'static,
    {
        sp_api :: metadata_ir :: RuntimeApiMetadataIR { name : "ContractsApi" , methods : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([sp_api :: metadata_ir :: RuntimeApiMethodMetadataIR { name : "call" , inputs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "origin" , ty : sp_api :: scale_info :: meta_type :: < AccountId > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "dest" , ty : sp_api :: scale_info :: meta_type :: < AccountId > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "value" , ty : sp_api :: scale_info :: meta_type :: < Balance > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "gas_limit" , ty : sp_api :: scale_info :: meta_type :: < Option < Weight > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "storage_deposit_limit" , ty : sp_api :: scale_info :: meta_type :: < Option < Balance > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "input_data" , ty : sp_api :: scale_info :: meta_type :: < Vec < u8 > > () , }])) , output : sp_api :: scale_info :: meta_type :: < ContractExecResult < Balance , EventRecord > > () , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Perform a call from a specified account to a given contract." , "" , " See [`crate::Pallet::bare_call`]."])) , } , sp_api :: metadata_ir :: RuntimeApiMethodMetadataIR { name : "instantiate" , inputs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "origin" , ty : sp_api :: scale_info :: meta_type :: < AccountId > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "value" , ty : sp_api :: scale_info :: meta_type :: < Balance > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "gas_limit" , ty : sp_api :: scale_info :: meta_type :: < Option < Weight > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "storage_deposit_limit" , ty : sp_api :: scale_info :: meta_type :: < Option < Balance > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "code" , ty : sp_api :: scale_info :: meta_type :: < Code < Hash > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "data" , ty : sp_api :: scale_info :: meta_type :: < Vec < u8 > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "salt" , ty : sp_api :: scale_info :: meta_type :: < Vec < u8 > > () , }])) , output : sp_api :: scale_info :: meta_type :: < ContractInstantiateResult < AccountId , Balance , EventRecord > > () , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Instantiate a new contract." , "" , " See `[crate::Pallet::bare_instantiate]`."])) , } , sp_api :: metadata_ir :: RuntimeApiMethodMetadataIR { name : "upload_code" , inputs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "origin" , ty : sp_api :: scale_info :: meta_type :: < AccountId > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "code" , ty : sp_api :: scale_info :: meta_type :: < Vec < u8 > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "storage_deposit_limit" , ty : sp_api :: scale_info :: meta_type :: < Option < Balance > > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "determinism" , ty : sp_api :: scale_info :: meta_type :: < Determinism > () , }])) , output : sp_api :: scale_info :: meta_type :: < CodeUploadResult < Hash , Balance > > () , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Upload new code without instantiating a contract from it." , "" , " See [`crate::Pallet::bare_upload_code`]."])) , } , sp_api :: metadata_ir :: RuntimeApiMethodMetadataIR { name : "get_storage" , inputs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "address" , ty : sp_api :: scale_info :: meta_type :: < AccountId > () , } , sp_api :: metadata_ir :: RuntimeApiMethodParamMetadataIR { name : "key" , ty : sp_api :: scale_info :: meta_type :: < Vec < u8 > > () , }])) , output : sp_api :: scale_info :: meta_type :: < GetStorageResult > () , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" Query a given storage key in a given contract." , "" , " Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the" , " specified account and `Ok(None)` if it doesn\'t. If the account specified by the address" , " doesn\'t exist, or doesn\'t have a contract then `Err` is returned."])) , }])) , docs : < [_] > :: into_vec (# [rustc_box] :: alloc :: boxed :: Box :: new ([" The API used to dry-run contract interactions."])) , }
    }
    pub const VERSION: u32 = 2u32;
    pub const ID: [u8; 8] = [104u8, 182u8, 107u8, 161u8, 34u8, 201u8, 63u8, 167u8];
}
/// The API used to dry-run contract interactions.
#[cfg(any(feature = "std", test))]
pub trait ContractsApi<Block: sp_api::BlockT, AccountId, Balance, BlockNumber, Hash, EventRecord>:
    sp_api::Core<Block>
where
    AccountId: Codec,
    Balance: Codec,
    BlockNumber: Codec,
    Hash: Codec,
    EventRecord: Codec,
{
    /// Perform a call from a specified account to a given contract.
    ///
    /// See [`crate::Pallet::bare_call`].
    fn call(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        origin: AccountId,
        dest: AccountId,
        value: Balance,
        gas_limit: Option<Weight>,
        storage_deposit_limit: Option<Balance>,
        input_data: Vec<u8>,
    ) -> std::result::Result<ContractExecResult<Balance, EventRecord>, sp_api::ApiError> {
        let __runtime_api_impl_params_encoded__ = sp_api::Encode::encode(&(
            &origin,
            &dest,
            &value,
            &gas_limit,
            &storage_deposit_limit,
            &input_data,
        ));
        <Self as ContractsApi<_, _, _, _, _, _>>::__runtime_api_internal_call_api_at(
            self,
            __runtime_api_at_param__,
            sp_api::ExecutionContext::OffchainCall(None),
            __runtime_api_impl_params_encoded__,
            &(|_version| "ContractsApi_call"),
        )
        .and_then(|r| {
            std::result::Result::map_err(
                <ContractExecResult<Balance, EventRecord> as sp_api::Decode>::decode(&mut &r[..]),
                |err| sp_api::ApiError::FailedToDecodeReturnValue {
                    function: "ContractsApi_call",
                    error: err,
                },
            )
        })
    }
    /// Perform a call from a specified account to a given contract.
    ///
    /// See [`crate::Pallet::bare_call`].
    fn call_with_context(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        context: sp_api::ExecutionContext,
        origin: AccountId,
        dest: AccountId,
        value: Balance,
        gas_limit: Option<Weight>,
        storage_deposit_limit: Option<Balance>,
        input_data: Vec<u8>,
    ) -> std::result::Result<ContractExecResult<Balance, EventRecord>, sp_api::ApiError> {
        let __runtime_api_impl_params_encoded__ = sp_api::Encode::encode(&(
            &origin,
            &dest,
            &value,
            &gas_limit,
            &storage_deposit_limit,
            &input_data,
        ));
        <Self as ContractsApi<_, _, _, _, _, _>>::__runtime_api_internal_call_api_at(
            self,
            __runtime_api_at_param__,
            context,
            __runtime_api_impl_params_encoded__,
            &(|_version| "ContractsApi_call"),
        )
        .and_then(|r| {
            std::result::Result::map_err(
                <ContractExecResult<Balance, EventRecord> as sp_api::Decode>::decode(&mut &r[..]),
                |err| sp_api::ApiError::FailedToDecodeReturnValue {
                    function: "ContractsApi_call",
                    error: err,
                },
            )
        })
    }
    /// Instantiate a new contract.
    ///
    /// See `[crate::Pallet::bare_instantiate]`.
    fn instantiate(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        origin: AccountId,
        value: Balance,
        gas_limit: Option<Weight>,
        storage_deposit_limit: Option<Balance>,
        code: Code<Hash>,
        data: Vec<u8>,
        salt: Vec<u8>,
    ) -> std::result::Result<
        ContractInstantiateResult<AccountId, Balance, EventRecord>,
        sp_api::ApiError,
    > {
        let __runtime_api_impl_params_encoded__ = sp_api::Encode::encode(&(
            &origin,
            &value,
            &gas_limit,
            &storage_deposit_limit,
            &code,
            &data,
            &salt,
        ));
        < Self as ContractsApi < _ , _ , _ , _ , _ , _ > > :: __runtime_api_internal_call_api_at (self , __runtime_api_at_param__ , sp_api :: ExecutionContext :: OffchainCall (None) , __runtime_api_impl_params_encoded__ , & (| _version | { "ContractsApi_instantiate" })) . and_then (| r | std :: result :: Result :: map_err (< ContractInstantiateResult < AccountId , Balance , EventRecord > as sp_api :: Decode > :: decode (& mut & r [..]) , | err | sp_api :: ApiError :: FailedToDecodeReturnValue { function : "ContractsApi_instantiate" , error : err , }))
    }
    /// Instantiate a new contract.
    ///
    /// See `[crate::Pallet::bare_instantiate]`.
    fn instantiate_with_context(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        context: sp_api::ExecutionContext,
        origin: AccountId,
        value: Balance,
        gas_limit: Option<Weight>,
        storage_deposit_limit: Option<Balance>,
        code: Code<Hash>,
        data: Vec<u8>,
        salt: Vec<u8>,
    ) -> std::result::Result<
        ContractInstantiateResult<AccountId, Balance, EventRecord>,
        sp_api::ApiError,
    > {
        let __runtime_api_impl_params_encoded__ = sp_api::Encode::encode(&(
            &origin,
            &value,
            &gas_limit,
            &storage_deposit_limit,
            &code,
            &data,
            &salt,
        ));
        < Self as ContractsApi < _ , _ , _ , _ , _ , _ > > :: __runtime_api_internal_call_api_at (self , __runtime_api_at_param__ , context , __runtime_api_impl_params_encoded__ , & (| _version | { "ContractsApi_instantiate" })) . and_then (| r | std :: result :: Result :: map_err (< ContractInstantiateResult < AccountId , Balance , EventRecord > as sp_api :: Decode > :: decode (& mut & r [..]) , | err | sp_api :: ApiError :: FailedToDecodeReturnValue { function : "ContractsApi_instantiate" , error : err , }))
    }
    /// Upload new code without instantiating a contract from it.
    ///
    /// See [`crate::Pallet::bare_upload_code`].
    fn upload_code(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        origin: AccountId,
        code: Vec<u8>,
        storage_deposit_limit: Option<Balance>,
        determinism: Determinism,
    ) -> std::result::Result<CodeUploadResult<Hash, Balance>, sp_api::ApiError> {
        let __runtime_api_impl_params_encoded__ =
            sp_api::Encode::encode(&(&origin, &code, &storage_deposit_limit, &determinism));
        <Self as ContractsApi<_, _, _, _, _, _>>::__runtime_api_internal_call_api_at(
            self,
            __runtime_api_at_param__,
            sp_api::ExecutionContext::OffchainCall(None),
            __runtime_api_impl_params_encoded__,
            &(|_version| "ContractsApi_upload_code"),
        )
        .and_then(|r| {
            std::result::Result::map_err(
                <CodeUploadResult<Hash, Balance> as sp_api::Decode>::decode(&mut &r[..]),
                |err| sp_api::ApiError::FailedToDecodeReturnValue {
                    function: "ContractsApi_upload_code",
                    error: err,
                },
            )
        })
    }
    /// Upload new code without instantiating a contract from it.
    ///
    /// See [`crate::Pallet::bare_upload_code`].
    fn upload_code_with_context(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        context: sp_api::ExecutionContext,
        origin: AccountId,
        code: Vec<u8>,
        storage_deposit_limit: Option<Balance>,
        determinism: Determinism,
    ) -> std::result::Result<CodeUploadResult<Hash, Balance>, sp_api::ApiError> {
        let __runtime_api_impl_params_encoded__ =
            sp_api::Encode::encode(&(&origin, &code, &storage_deposit_limit, &determinism));
        <Self as ContractsApi<_, _, _, _, _, _>>::__runtime_api_internal_call_api_at(
            self,
            __runtime_api_at_param__,
            context,
            __runtime_api_impl_params_encoded__,
            &(|_version| "ContractsApi_upload_code"),
        )
        .and_then(|r| {
            std::result::Result::map_err(
                <CodeUploadResult<Hash, Balance> as sp_api::Decode>::decode(&mut &r[..]),
                |err| sp_api::ApiError::FailedToDecodeReturnValue {
                    function: "ContractsApi_upload_code",
                    error: err,
                },
            )
        })
    }
    /// Query a given storage key in a given contract.
    ///
    /// Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
    /// specified account and `Ok(None)` if it doesn't. If the account specified by the address
    /// doesn't exist, or doesn't have a contract then `Err` is returned.
    fn get_storage(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        address: AccountId,
        key: Vec<u8>,
    ) -> std::result::Result<GetStorageResult, sp_api::ApiError> {
        let __runtime_api_impl_params_encoded__ = sp_api::Encode::encode(&(&address, &key));
        <Self as ContractsApi<_, _, _, _, _, _>>::__runtime_api_internal_call_api_at(
            self,
            __runtime_api_at_param__,
            sp_api::ExecutionContext::OffchainCall(None),
            __runtime_api_impl_params_encoded__,
            &(|_version| "ContractsApi_get_storage"),
        )
        .and_then(|r| {
            std::result::Result::map_err(
                <GetStorageResult as sp_api::Decode>::decode(&mut &r[..]),
                |err| sp_api::ApiError::FailedToDecodeReturnValue {
                    function: "ContractsApi_get_storage",
                    error: err,
                },
            )
        })
    }
    /// Query a given storage key in a given contract.
    ///
    /// Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
    /// specified account and `Ok(None)` if it doesn't. If the account specified by the address
    /// doesn't exist, or doesn't have a contract then `Err` is returned.
    fn get_storage_with_context(
        &self,
        __runtime_api_at_param__: <Block as sp_api::BlockT>::Hash,
        context: sp_api::ExecutionContext,
        address: AccountId,
        key: Vec<u8>,
    ) -> std::result::Result<GetStorageResult, sp_api::ApiError> {
        let __runtime_api_impl_params_encoded__ = sp_api::Encode::encode(&(&address, &key));
        <Self as ContractsApi<_, _, _, _, _, _>>::__runtime_api_internal_call_api_at(
            self,
            __runtime_api_at_param__,
            context,
            __runtime_api_impl_params_encoded__,
            &(|_version| "ContractsApi_get_storage"),
        )
        .and_then(|r| {
            std::result::Result::map_err(
                <GetStorageResult as sp_api::Decode>::decode(&mut &r[..]),
                |err| sp_api::ApiError::FailedToDecodeReturnValue {
                    function: "ContractsApi_get_storage",
                    error: err,
                },
            )
        })
    }
    /// !!INTERNAL USE ONLY!!
    #[doc(hidden)]
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <Block as sp_api::BlockT>::Hash,
        context: sp_api::ExecutionContext,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError>;
}
#[cfg(any(feature = "std", test))]
impl<Block: sp_api::BlockT, AccountId, Balance, BlockNumber, Hash, EventRecord>
    sp_api::RuntimeApiInfo
    for dyn ContractsApi<Block, AccountId, Balance, BlockNumber, Hash, EventRecord>
{
    const ID: [u8; 8] = [104u8, 182u8, 107u8, 161u8, 34u8, 201u8, 63u8, 167u8];
    const VERSION: u32 = 2u32;
}
